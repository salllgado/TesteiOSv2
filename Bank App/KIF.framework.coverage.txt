/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/CAAnimation+KIFAdditions.m:
    1|       |//
    2|       |//  CAAnimation+KIFAdditions.m
    3|       |//  Pods
    4|       |//
    5|       |//  Created by Justin Martin on 6/6/16.
    6|       |//
    7|       |
    8|       |#import "CAAnimation+KIFAdditions.h"
    9|       |
   10|       |
   11|       |@implementation CAAnimation (KIFAdditions)
   12|       |
   13|       |- (double)KIF_completionTime;
   14|      0|{
   15|      0|    if (self.repeatDuration > 0) {
   16|      0|        return self.beginTime + self.repeatDuration;
   17|      0|    } else if (self.repeatCount == HUGE_VALF) {
   18|      0|        return HUGE_VALF;
   19|      0|    } else if (self.repeatCount > 0) {
   20|      0|        return self.beginTime + (self.repeatCount * self.duration);
   21|      0|    } else {
   22|      0|        return self.beginTime + self.duration;
   23|      0|    }
   24|      0|}
   25|       |
   26|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/CALayer-KIFAdditions.m:
    1|       |//
    2|       |//  CALayer-KIFAdditions.m
    3|       |//  Pods
    4|       |//
    5|       |//  Created by Radu Ciobanu on 28/01/2016.
    6|       |//  Licensed to Square, Inc. under one or more contributor license agreements.
    7|       |//  See the LICENSE file distributed with this work for the terms under
    8|       |//  which Square, Inc. licenses this file to you.
    9|       |//
   10|       |
   11|       |#import "CALayer-KIFAdditions.h"
   12|       |#import "CAAnimation+KIFAdditions.h"
   13|       |
   14|       |
   15|       |@implementation CALayer (KIFAdditions)
   16|       |
   17|       |- (float)KIF_absoluteSpeed
   18|      0|{
   19|      0|    __block float speed = 1.0f;
   20|      0|    [self performBlockOnAncestorLayers:^(CALayer *layer) {
   21|      0|        speed = speed * layer.speed;
   22|      0|    }];
   23|      0|    return speed;
   24|      0|}
   25|       |
   26|       |- (BOOL)hasAnimations
   27|      0|{
   28|      0|    __block BOOL result = NO;
   29|      0|    [self performBlockOnDescendentLayers:^(CALayer *layer, BOOL *stop) {
   30|      0|      // explicitly exclude _UIParallaxMotionEffect as it is used in alertviews, and we don't want every alertview to be paused)
   31|      0|      BOOL hasAnimation = layer.animationKeys.count != 0 && ![layer.animationKeys isEqualToArray:@[@"_UIParallaxMotionEffect"]];
   32|      0|      if (hasAnimation && !layer.hidden) {
   33|      0|          double currentTime = CACurrentMediaTime() * [layer KIF_absoluteSpeed];
   34|      0|
   35|      0|          [layer.animationKeys enumerateObjectsUsingBlock:^(NSString *animationKey, NSUInteger idx, BOOL *innerStop) {
   36|      0|              CAAnimation *animation = [layer animationForKey:animationKey];
   37|      0|              double beginTime = [animation beginTime];
   38|      0|              double completionTime = [animation KIF_completionTime];
   39|      0|
   40|      0|              // Ignore infinitely repeating animations
   41|      0|              if (currentTime >= beginTime && completionTime != HUGE_VALF && currentTime < completionTime) {
   42|      0|                  result = YES;
   43|      0|                  *innerStop = YES;
   44|      0|                  *stop = YES;
   45|      0|              }
   46|      0|          }];
   47|      0|      }
   48|      0|    }];
   49|      0|    return result;
   50|      0|}
   51|       |
   52|       |- (void)performBlockOnDescendentLayers:(void (^)(CALayer *layer, BOOL *stop))block
   53|      0|{
   54|      0|    BOOL stop = NO;
   55|      0|    [self performBlockOnDescendentLayers:block stop:&stop];
   56|      0|}
   57|       |
   58|       |- (void)performBlockOnDescendentLayers:(void (^)(CALayer *, BOOL *))block stop:(BOOL *)stop
   59|      0|{
   60|      0|    block(self, stop);
   61|      0|    if (*stop) {
   62|      0|        return;
   63|      0|    }
   64|      0|
   65|      0|    for (CALayer *layer in self.sublayers) {
   66|      0|        [layer performBlockOnDescendentLayers:block stop:stop];
   67|      0|        if (*stop) {
   68|      0|            return;
   69|      0|        }
   70|      0|    }
   71|      0|}
   72|       |
   73|       |- (void)performBlockOnAncestorLayers:(void (^)(CALayer *))block;
   74|      0|{
   75|      0|    block(self);
   76|      0|
   77|      0|    if (self.superlayer != nil) {
   78|      0|        [self.superlayer performBlockOnAncestorLayers:block];
   79|      0|    }
   80|      0|}
   81|       |
   82|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/CGGeometry-KIFAdditions.h:
    1|       |//
    2|       |//  CGGeometry-KIFAdditions.h
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Eric Firestone on 5/22/11.
    6|       |//  Licensed to Square, Inc. under one or more contributor license agreements.
    7|       |//  See the LICENSE file distributed with this work for the terms under
    8|       |//  which Square, Inc. licenses this file to you.
    9|       |
   10|       |#import <CoreGraphics/CGGeometry.h>
   11|       |
   12|     31|CG_INLINE CGPoint CGPointCenteredInRect(CGRect bounds) {
   13|     31|    return CGPointMake(bounds.origin.x + bounds.size.width * 0.5f, bounds.origin.y + bounds.size.height * 0.5f);
   14|     31|}
  ------------------
  | Unexecuted instantiation: CGGeometry-KIFAdditions.m:CGPointCenteredInRect
  ------------------
  | Unexecuted instantiation: KIFTypist.m:CGPointCenteredInRect
  ------------------
  | Unexecuted instantiation: KIFUITestActor.m:CGPointCenteredInRect
  ------------------
  | Unexecuted instantiation: UITableView-KIFAdditions.m:CGPointCenteredInRect
  ------------------
  | UIView-KIFAdditions.m:CGPointCenteredInRect:
  |   12|     31|CG_INLINE CGPoint CGPointCenteredInRect(CGRect bounds) {
  |   13|     31|    return CGPointMake(bounds.origin.x + bounds.size.width * 0.5f, bounds.origin.y + bounds.size.height * 0.5f);
  |   14|     31|}
  ------------------
   15|       |
   16|      0|CG_INLINE CGPoint CGPointMidPoint(CGPoint point1, CGPoint point2) {
   17|      0|    return CGPointMake((point1.x + point2.x) / 2.0f, (point1.y + point2.y) / 2.0f);
   18|      0|}
  ------------------
  | Unexecuted instantiation: CGGeometry-KIFAdditions.m:CGPointMidPoint
  ------------------
  | Unexecuted instantiation: KIFTypist.m:CGPointMidPoint
  ------------------
  | Unexecuted instantiation: KIFUITestActor.m:CGPointMidPoint
  ------------------
  | Unexecuted instantiation: UITableView-KIFAdditions.m:CGPointMidPoint
  ------------------
  | Unexecuted instantiation: UIView-KIFAdditions.m:CGPointMidPoint
  ------------------

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/NSBundle-KIFAdditions.m:
    1|       |//
    2|       |//  NSBundle+KIFAdditions.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Brian Nickel on 7/27/13.
    6|       |//
    7|       |//
    8|       |
    9|       |#import "NSBundle-KIFAdditions.h"
   10|       |#import "KIFTestCase.h"
   11|       |#import "LoadableCategory.h"
   12|       |
   13|       |MAKE_CATEGORIES_LOADABLE(NSBundle_KIFAdditions)
   14|       |
   15|       |@implementation NSBundle (KIFAdditions)
   16|       |
   17|       |+ (NSBundle *)KIFTestBundle
   18|      0|{
   19|      0|    static NSBundle *bundle;
   20|      0|    static dispatch_once_t onceToken;
   21|      0|    dispatch_once(&onceToken, ^{
   22|      0|        bundle = [self bundleForClass:[KIFTestCase class]];
   23|      0|    });
   24|      0|    return bundle;
   25|      0|}
   26|       |
   27|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/NSError-KIFAdditions.m:
    1|       |//
    2|       |//  NSError+KIFAdditions.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Brian Nickel on 7/27/13.
    6|       |//
    7|       |//
    8|       |
    9|       |#import "NSError-KIFAdditions.h"
   10|       |#import "LoadableCategory.h"
   11|       |#import "KIFTestActor.h"
   12|       |
   13|       |MAKE_CATEGORIES_LOADABLE(NSError_KIFAdditions)
   14|       |
   15|       |@implementation NSError (KIFAdditions)
   16|       |
   17|       |+ (instancetype)KIFErrorWithFormat:(NSString *)format, ...
   18|      1|{
   19|      1|    va_list args;
   20|      1|    va_start(args, format);
   21|      1|    NSString *description = [[NSString alloc] initWithFormat:format arguments:args];
   22|      1|    va_end(args);
   23|      1|    
   24|      1|    return [self errorWithDomain:@"KIFTest" code:KIFTestStepResultFailure userInfo:@{NSLocalizedDescriptionKey: description}];
   25|      1|}
   26|       |
   27|       |+ (instancetype)KIFErrorWithUnderlyingError:(NSError *)underlyingError format:(NSString *)format, ...
   28|      0|{
   29|      0|    va_list args;
   30|      0|    va_start(args, format);
   31|      0|    NSString *description = [[NSString alloc] initWithFormat:format arguments:args];
   32|      0|    va_end(args);
   33|      0|    
   34|      0|    NSDictionary *userInfo = [[NSDictionary alloc] initWithObjectsAndKeys:description, NSLocalizedDescriptionKey, underlyingError, NSUnderlyingErrorKey, nil];
   35|      0|    
   36|      0|    return [self errorWithDomain:@"KIFTest" code:KIFTestStepResultFailure userInfo:userInfo];
   37|      0|}
   38|       |
   39|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/NSException-KIFAdditions.m:
    1|       |//
    2|       |//  NSException-KIFAdditions.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Tony DiPasquale on 12/20/13.
    6|       |//
    7|       |//
    8|       |
    9|       |#import "NSException-KIFAdditions.h"
   10|       |
   11|       |@implementation NSException (KIFAdditions)
   12|       |
   13|       |+ (NSException *)failureInFile:(NSString *)file atLine:(NSInteger)line withDescription:(NSString *)formatString, ...
   14|      0|{
   15|      0|    va_list argumentList;
   16|      0|    va_start(argumentList, formatString);
   17|      0|
   18|      0|    NSString *reason = [[NSString alloc] initWithFormat:formatString arguments:argumentList];
   19|      0|
   20|      0|    va_end(argumentList);
   21|      0|
   22|      0|    return [NSException exceptionWithName:@"KIFFailureException"
   23|      0|                                   reason: reason
   24|      0|                                 userInfo:@{@"FilenameKey": file,
   25|      0|                                            @"LineNumberKey": @(line)}];
   26|      0|}
   27|       |
   28|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/NSFileManager-KIFAdditions.m:
    1|       |//
    2|       |//  NSFileManager-KIFAdditions.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Michael Thole on 6/1/11.
    6|       |//  Licensed to Square, Inc. under one or more contributor license agreements.
    7|       |//  See the LICENSE file distributed with this work for the terms under
    8|       |//  which Square, Inc. licenses this file to you.
    9|       |
   10|       |#import "NSFileManager-KIFAdditions.h"
   11|       |#import "LoadableCategory.h"
   12|       |
   13|       |
   14|       |MAKE_CATEGORIES_LOADABLE(NSFileManager_KIFAdditions)
   15|       |
   16|       |
   17|       |@implementation NSFileManager (KIFAdditions)
   18|       |
   19|       |#pragma mark Public Methods
   20|       |
   21|       |- (NSString *)createUserDirectory:(NSSearchPathDirectory)searchPath;
   22|      0|{
   23|      0|    NSArray *paths = NSSearchPathForDirectoriesInDomains(searchPath, NSUserDomainMask, YES);
   24|      0|    if (!paths.count) {
   25|      0|        return nil;
   26|      0|    }
   27|      0|    
   28|      0|    NSString *rootDirectory = paths[0];
   29|      0|
   30|      0|    BOOL isDir;
   31|      0|    BOOL created = NO;
   32|      0|    if ([self fileExistsAtPath:rootDirectory isDirectory:&isDir] && isDir) {
   33|      0|        created = YES;
   34|      0|    } else {
   35|      0|        created = [self recursivelyCreateDirectory:rootDirectory];
   36|      0|    }
   37|      0|
   38|      0|    return created ? rootDirectory : nil;
   39|      0|}
   40|       |
   41|       |- (BOOL)recursivelyCreateDirectory:(NSString *)path;
   42|      0|{
   43|      0|    BOOL isDir = NO;
   44|      0|    BOOL isParentADir = NO;
   45|      0|    NSString *parentDir = nil;
   46|      0|
   47|      0|    if (![self fileExistsAtPath:path isDirectory:&isDir]) {
   48|      0|        // if file doesn't exist, first create parent
   49|      0|        parentDir = [path stringByDeletingLastPathComponent];
   50|      0|
   51|      0|        if (!parentDir.length || [parentDir isEqualToString:@"/"]) {
   52|      0|            isParentADir = YES;
   53|      0|        } else {
   54|      0|            isParentADir = [self recursivelyCreateDirectory:parentDir];
   55|      0|        }
   56|      0|
   57|      0|        if (isParentADir) {
   58|      0|            isDir = [self createDirectoryAtPath:path withIntermediateDirectories:NO attributes:nil error:nil];
   59|      0|        } else {
   60|      0|            return NO;
   61|      0|        }
   62|      0|    }
   63|      0|
   64|      0|    return isDir;
   65|      0|}
   66|       |
   67|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/NSPredicate+KIFAdditions.m:
    1|       |//
    2|       |//  NSPredicate+KIFAdditions.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Alex Odawa on 2/3/15.
    6|       |//
    7|       |//
    8|       |
    9|       |#import <objc/runtime.h>
   10|       |#import "NSPredicate+KIFAdditions.h"
   11|       |
   12|       |@implementation NSPredicate (KIFAdditions)
   13|       |
   14|       |- (NSArray *)flatten
   15|      0|{
   16|      0|    NSMutableArray *result = [[NSMutableArray alloc] init];
   17|      0|    
   18|      0|    if ([self isKindOfClass:[NSCompoundPredicate class]]) {
   19|      0|        for (NSPredicate *predicate in ((NSCompoundPredicate *)self).subpredicates) {
   20|      0|            [result addObjectsFromArray:[predicate flatten]];
   21|      0|        }
   22|      0|    } else {
   23|      0|        [result addObject:self];
   24|      0|    }
   25|      0|    
   26|      0|    return result;
   27|      0|}
   28|       |
   29|       |- (NSCompoundPredicate *)minusSubpredicatesFrom:(NSPredicate *)otherPredicate;
   30|      0|{
   31|      0|    if (self == otherPredicate) {
   32|      0|        return nil;
   33|      0|    }
   34|      0|    NSMutableSet *subpredicates = [NSMutableSet setWithArray:[self flatten]];
   35|      0|    NSMutableSet *otherSubpredicates = [NSMutableSet setWithArray:[otherPredicate flatten]];
   36|      0|    [subpredicates minusSet:otherSubpredicates];
   37|      0|    return [[NSCompoundPredicate alloc] initWithType:NSAndPredicateType
   38|      0|                                       subpredicates:[subpredicates allObjects]];
   39|      0|}
   40|       |
   41|       |- (void)setKifPredicateDescription:(NSString *)description;
   42|      0|{
   43|      0|    NSString *desc = description.copy;
   44|      0|    objc_setAssociatedObject(self, @selector(kifPredicateDescription), desc, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
   45|      0|}
   46|       |
   47|       |- (NSString *)kifPredicateDescription;
   48|      0|{
   49|      0|    id object = objc_getAssociatedObject(self, @selector(kifPredicateDescription));
   50|      0|    if (object) {
   51|      0|        return object;
   52|      0|    }
   53|      0|    // Compound predicates containing subpredicates with the kifPredicateDescription set should still get our pretty formatting.
   54|      0|    if ([self isKindOfClass:[NSCompoundPredicate class]]) {
   55|      0|        NSArray *subpredicates = [self flatten];
   56|      0|        NSString *description = @"";
   57|      0|        
   58|      0|        for (NSPredicate *predicate in subpredicates) {
   59|      0|            if (description.length > 0) {
   60|      0|                description = [description stringByAppendingString:@", "];
   61|      0|            }
   62|      0|            description = [description stringByAppendingString:predicate.kifPredicateDescription];
   63|      0|        }
   64|      0|        if (description.length > 0) {
   65|      0|            return description;
   66|      0|        }
   67|      0|    }
   68|      0|    
   69|      0|    return self.description;
   70|      0|}
   71|       |
   72|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/NSString+KIFAdditions.m:
    1|       |//
    2|       |//  NSString+KIFAdditions.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Alex Odawa on 1/28/16.
    6|       |//
    7|       |//
    8|       |
    9|       |#import "NSString+KIFAdditions.h"
   10|       |
   11|       |#pragma mark - NSString
   12|       |@implementation NSString (KIFAdditions)
   13|       |
   14|       |- (BOOL)KIF_isEqualToStringOrAttributedString:(id)aString;
   15|      0|{
   16|      0|    // Somtimes Accessibility Elements will return an AXAttributedString.
   17|      0|    // This compares the raw backing string against a vanilla NSString, ignoring any attributes.
   18|      0|    if ([aString respondsToSelector:@selector(string)]) {
   19|      0|        return [self isEqualToString:[(id)aString string]];
   20|      0|    }
   21|      0|    return [self isEqualToString:aString];
   22|      0|}
   23|       |
   24|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/UIAccessibilityElement-KIFAdditions.m:
    1|       |//
    2|       |//  UIAccessibilityElement-KIFAdditions.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Eric Firestone on 5/23/11.
    6|       |//  Licensed to Square, Inc. under one or more contributor license agreements.
    7|       |//  See the LICENSE file distributed with this work for the terms under
    8|       |//  which Square, Inc. licenses this file to you.
    9|       |
   10|       |#import "NSError-KIFAdditions.h"
   11|       |#import "NSPredicate+KIFAdditions.h"
   12|       |#import "UIAccessibilityElement-KIFAdditions.h"
   13|       |#import "UIApplication-KIFAdditions.h"
   14|       |#import "UIScrollView-KIFAdditions.h"
   15|       |#import "UIView-KIFAdditions.h"
   16|       |#import "LoadableCategory.h"
   17|       |#import "KIFTestActor.h"
   18|       |#import "KIFUITestActor.h"
   19|       |
   20|       |MAKE_CATEGORIES_LOADABLE(UIAccessibilityElement_KIFAdditions)
   21|       |
   22|       |@interface UIAccessibilityElement (KIFAdditions_Private)
   23|       |
   24|       |- (id)tableViewCell; // UITableViewCellAccessibilityElement
   25|       |
   26|       |@end
   27|       |
   28|       |@implementation UIAccessibilityElement (KIFAdditions)
   29|       |
   30|       |+ (UIView *)viewContainingAccessibilityElement:(UIAccessibilityElement *)element;
   31|     31|{
   32|     31|    while (element && ![element isKindOfClass:[UIView class]]) {
   33|      0|        // Sometimes accessibilityContainer will return a view that's too far up the view hierarchy
   34|      0|        // UIAccessibilityElement instances will sometimes respond to view, so try to use that and then fall back to accessibilityContainer
   35|      0|        id view = [element respondsToSelector:@selector(view)] ? [(id)element view]
   36|      0|        : [element respondsToSelector:@selector(tableViewCell)] ? [(id)element tableViewCell]
   37|      0|        : nil;
   38|      0|        
   39|      0|        if (view) {
   40|      0|            element = view;
   41|      0|        } else {
   42|      0|            element = [element accessibilityContainer];
   43|      0|        }
   44|      0|    }
   45|     31|    
   46|     31|    return (UIView *)element;
   47|     31|}
   48|       |
   49|       |+ (BOOL)accessibilityElement:(out UIAccessibilityElement **)foundElement view:(out UIView **)foundView withLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits tappable:(BOOL)mustBeTappable error:(out NSError **)error
   50|      4|{
   51|      4|    return [self accessibilityElement:foundElement view:foundView withLabel:label value:value traits:traits fromRootView:NULL tappable:mustBeTappable error:error];
   52|      4|}
   53|       |
   54|       |+ (BOOL)accessibilityElement:(out UIAccessibilityElement **)foundElement view:(out UIView **)foundView withLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits fromRootView:(UIView *)fromView tappable:(BOOL)mustBeTappable error:(out NSError **)error
   55|      4|{
   56|      4|    UIAccessibilityElement *element = [self accessibilityElementWithLabel:label value:value traits:traits fromRootView:fromView error:error];
   57|      4|    if (!element) {
   58|      1|        return NO;
   59|      1|    }
   60|      3|    
   61|      3|    UIView *view = [self viewContainingAccessibilityElement:element tappable:mustBeTappable error:error];
   62|      3|    if (!view) {
   63|      0|        return NO;
   64|      0|    }
   65|      3|    
   66|      3|    // viewContainingAccessibilityElement:.. can cause scrolling, which can cause cell reuse.
   67|      3|    // If this happens, the element we kept a reference to might have been reconfigured, and a
   68|      3|    // different element might be the one that matches.
   69|      3|    if (![UIView accessibilityElement:element hasLabel:label accessibilityValue:value traits:traits]) {
   70|      0|        return NO;
   71|      0|    }
   72|      3|    
   73|      3|    if (foundElement) { *foundElement = element; }
   74|      3|    if (foundView) { *foundView = view; }
   75|      3|    return YES;
   76|      3|}
   77|       |
   78|       |+ (BOOL)accessibilityElement:(out UIAccessibilityElement **)foundElement view:(out UIView **)foundView withElementMatchingPredicate:(NSPredicate *)predicate tappable:(BOOL)mustBeTappable error:(out NSError **)error;
   79|      0|{
   80|      0|    UIAccessibilityElement *element = [[UIApplication sharedApplication] accessibilityElementMatchingBlock:^BOOL(UIAccessibilityElement *element) {
   81|      0|        return [predicate evaluateWithObject:element];
   82|      0|    }];
   83|      0|    
   84|      0|    if (!element) {
   85|      0|        if (error) {
   86|      0|            *error = [self errorForFailingPredicate:predicate];
   87|      0|        }
   88|      0|        return NO;
   89|      0|    }
   90|      0|    
   91|      0|    UIView *view = [UIAccessibilityElement viewContainingAccessibilityElement:element tappable:mustBeTappable error:error];
   92|      0|    if (!view) {
   93|      0|        return NO;
   94|      0|    }
   95|      0|    
   96|      0|    if (foundElement) { *foundElement = element; }
   97|      0|    if (foundView) { *foundView = view; }
   98|      0|    return YES;
   99|      0|}
  100|       |
  101|       |+ (BOOL)accessibilityElement:(out UIAccessibilityElement *__autoreleasing *)foundElement view:(out UIView *__autoreleasing *)foundView withElementMatchingPredicate:(NSPredicate *)predicate fromRootView:(UIView *)fromView tappable:(BOOL)mustBeTappable error:(out NSError *__autoreleasing *)error
  102|      0|{
  103|      0|    UIAccessibilityElement *element = [fromView accessibilityElementMatchingBlock:^BOOL(UIAccessibilityElement *element) {
  104|      0|        return [predicate evaluateWithObject:element];
  105|      0|    }];
  106|      0|    
  107|      0|    if (!element) {
  108|      0|        if (error) {
  109|      0|            *error = [NSError KIFErrorWithFormat:@"Could not find view matching: %@", predicate];
  110|      0|        }
  111|      0|        return NO;
  112|      0|    }
  113|      0|    
  114|      0|    UIView *view = [UIAccessibilityElement viewContainingAccessibilityElement:element tappable:mustBeTappable error:error];
  115|      0|    if (!view) {
  116|      0|        return NO;
  117|      0|    }
  118|      0|    
  119|      0|    if (foundElement) { *foundElement = element; }
  120|      0|    if (foundView) { *foundView = view; }
  121|      0|    return YES;
  122|      0|}
  123|       |
  124|       |+ (UIAccessibilityElement *)accessibilityElementWithLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits error:(out NSError **)error
  125|      0|{
  126|      0|    return [self accessibilityElementWithLabel:label value:value traits:traits fromRootView:NULL error:error];
  127|      0|}
  128|       |
  129|       |+ (UIAccessibilityElement *)accessibilityElementWithLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits fromRootView:(UIView *)fromView error:(out NSError **)error;
  130|      4|{
  131|      4|    UIAccessibilityElement *element = NULL;
  132|      4|    if (fromView == NULL) {
  133|      4|        element = [[UIApplication sharedApplication] accessibilityElementWithLabel:label accessibilityValue:value traits:traits];
  134|      4|    } else {
  135|      0|        element = [fromView accessibilityElementWithLabel:label accessibilityValue:value traits:traits];
  136|      0|    }
  137|      4|    if (element || !error) {
  138|      3|        return element;
  139|      3|    }
  140|      1|    
  141|      1|    element = [[UIApplication sharedApplication] accessibilityElementWithLabel:label accessibilityValue:nil traits:traits];
  142|      1|    // For purposes of a better error message, see if we can find the view, just not a view with the specified value.
  143|      1|    if (value && element) {
  144|      0|        *error = [NSError KIFErrorWithFormat:@"Found an accessibility element with the label \"%@\", but with the value \"%@\", not \"%@\"", label, element.accessibilityValue, value];
  145|      0|        return nil;
  146|      0|    }
  147|      1|    
  148|      1|    // Check the traits, too.
  149|      1|    element = [[UIApplication sharedApplication] accessibilityElementWithLabel:label accessibilityValue:nil traits:UIAccessibilityTraitNone];
  150|      1|    if (traits != UIAccessibilityTraitNone && element) {
  151|      0|        *error = [NSError KIFErrorWithFormat:@"Found an accessibility element with the label \"%@\", but not with the traits \"%llu\"", label, traits];
  152|      0|        return nil;
  153|      0|    }
  154|      1|    
  155|      1|    *error = [NSError KIFErrorWithFormat:@"Failed to find accessibility element with the label \"%@\"", label];
  156|      1|    return nil;
  157|      1|}
  158|       |
  159|       |+ (UIView *)viewContainingAccessibilityElement:(UIAccessibilityElement *)element tappable:(BOOL)mustBeTappable error:(NSError **)error;
  160|      3|{
  161|      3|    // Small safety mechanism.  If someone calls this method after a failing call to accessibilityElementWithLabel:..., we don't want to wipe out the error message.
  162|      3|    if (!element && error && *error) {
  163|      0|        return nil;
  164|      0|    }
  165|      3|    
  166|      3|    // Make sure the element is visible
  167|      3|    UIView *view = [UIAccessibilityElement viewContainingAccessibilityElement:element];
  168|      3|    if (!view) {
  169|      0|        if (error) {
  170|      0|            *error = [NSError KIFErrorWithFormat:@"Cannot find view containing accessibility element with the label \"%@\"", element.accessibilityLabel];
  171|      0|        }
  172|      0|        return nil;
  173|      0|    }
  174|      3|
  175|      3|    // Scroll the view (and superviews) to be visible if necessary
  176|      3|    UIView *superview = view;
  177|     33|    while (superview) {
  178|     30|        // Fix for iOS7 table view cells containing scroll views
  179|     30|        if ([superview.superview isKindOfClass:[UITableViewCell class]]) {
  180|      0|            break;
  181|      0|        }
  182|     30|
  183|     30|        if ([superview isKindOfClass:[UIScrollView class]]) {
  184|      3|            UIScrollView *scrollView = (UIScrollView *)superview;
  185|      3|            BOOL animationEnabled = [KIFUITestActor testActorAnimationsEnabled];
  186|      3|            
  187|      3|            if (((UIAccessibilityElement *)view == element) && ![view isKindOfClass:[UITableViewCell class]]) {
  188|      3|                [scrollView scrollViewToVisible:view animated:animationEnabled];
  189|      3|            } else {
  190|      0|                if ([view isKindOfClass:[UITableViewCell class]] && [scrollView.superview isKindOfClass:[UITableView class]]) {
  191|      0|                    UITableViewCell *cell = (UITableViewCell *)view;
  192|      0|                    UITableView *tableView = (UITableView *)scrollView.superview;
  193|      0|                    NSIndexPath *indexPath = [tableView indexPathForCell:cell];
  194|      0|                    [tableView scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionNone animated:animationEnabled];
  195|      0|                } else {
  196|      0|                    CGRect elementFrame = [view.window convertRect:element.accessibilityFrame toView:scrollView];
  197|      0|                    CGRect visibleRect = CGRectMake(scrollView.contentOffset.x, scrollView.contentOffset.y, CGRectGetWidth(scrollView.bounds), CGRectGetHeight(scrollView.bounds));
  198|      0|
  199|      0|                    UIEdgeInsets contentInset;
  200|      0|#ifdef __IPHONE_11_0
  201|      0|                        if (@available(iOS 11.0, *)) {
  202|      0|                            contentInset = scrollView.adjustedContentInset;
  203|      0|                        } else {
  204|      0|                            contentInset = scrollView.contentInset;
  205|      0|                        }
  206|       |#else
  207|       |                        contentInset = scrollView.contentInset;
  208|       |#endif
  209|       |                    visibleRect = UIEdgeInsetsInsetRect(visibleRect, contentInset);
  210|      0|
  211|      0|                    // Only call scrollRectToVisible if the element isn't already visible
  212|      0|                    // iOS 8 will sometimes incorrectly scroll table views so the element scrolls out of view
  213|      0|                    if (!CGRectContainsRect(visibleRect, elementFrame)) {
  214|      0|                        [scrollView scrollRectToVisible:elementFrame animated:animationEnabled];
  215|      0|                    }
  216|      0|                }
  217|      0|
  218|      0|                // Give the scroll view a small amount of time to perform the scroll.
  219|      0|                CFTimeInterval delay = animationEnabled ? 0.3 : 0.05;
  220|      0|                KIFRunLoopRunInModeRelativeToAnimationSpeed(kCFRunLoopDefaultMode, delay, false);
  221|      0|            }
  222|      3|        }
  223|     30|        
  224|     30|        superview = superview.superview;
  225|     30|    }
  226|      3|
  227|      3|    if ([[UIApplication sharedApplication] isIgnoringInteractionEvents]) {
  228|      0|        if (error) {
  229|      0|            *error = [NSError KIFErrorWithFormat:@"Application is ignoring interaction events"];
  230|      0|        }
  231|      0|        return nil;
  232|      0|    }
  233|      3|    
  234|      3|    // If we don't require tappability, at least make sure it's not hidden
  235|      3|    if ([view isHidden]) {
  236|      0|        if (error) {
  237|      0|            *error = [NSError KIFErrorWithFormat:@"Accessibility element with label \"%@\" is hidden.", element.accessibilityLabel];
  238|      0|        }
  239|      0|        return nil;
  240|      0|    }
  241|      3|    
  242|      3|    if (mustBeTappable && !view.isProbablyTappable) {
  243|      0|        if (error) {
  244|      0|            *error = [NSError KIFErrorWithFormat:@"Accessibility element %@ for view %@ with label \"%@\" is not tappable. It may be blocked by other views.", element, view, element.accessibilityLabel];
  245|      0|        }
  246|      0|        return nil;
  247|      0|    }
  248|      3|    
  249|      3|    return view;
  250|      3|}
  251|       |
  252|       |+ (NSError *)errorForFailingPredicate:(NSPredicate*)failingPredicate;
  253|      0|{
  254|      0|    NSPredicate *closestMatchingPredicate = [self findClosestMatchingPredicate:failingPredicate];
  255|      0|    if (closestMatchingPredicate) {
  256|      0|        return [NSError KIFErrorWithFormat:@"Found element with %@ but not %@", \
  257|      0|                closestMatchingPredicate.kifPredicateDescription, \
  258|      0|                [failingPredicate minusSubpredicatesFrom:closestMatchingPredicate].kifPredicateDescription];
  259|      0|    }
  260|      0|    return [NSError KIFErrorWithFormat:@"Could not find element with %@", failingPredicate.kifPredicateDescription];
  261|      0|}
  262|       |
  263|       |+ (NSPredicate *)findClosestMatchingPredicate:(NSPredicate *)aPredicate;
  264|      0|{
  265|      0|    if (!aPredicate) {
  266|      0|        return nil;
  267|      0|    }
  268|      0|    
  269|      0|    UIAccessibilityElement *match = [[UIApplication sharedApplication] accessibilityElementMatchingBlock:^BOOL (UIAccessibilityElement *element) {
  270|      0|        return [aPredicate evaluateWithObject:element];
  271|      0|    }];
  272|      0|    if (match) {
  273|      0|        return aPredicate;
  274|      0|    }
  275|      0|    
  276|      0|    // Breadth-First algorithm to match as many subpredicates as possible
  277|      0|    NSMutableArray *queue = [NSMutableArray arrayWithObject:aPredicate];
  278|      0|    while (queue.count > 0) {
  279|      0|        // Dequeuing
  280|      0|        NSPredicate *predicate = [queue firstObject];
  281|      0|        [queue removeObject:predicate];
  282|      0|        
  283|      0|        // Remove one subpredicate at a time an then check if an element would match this resulting predicate
  284|      0|        for (NSPredicate *subpredicate in [predicate flatten]) {
  285|      0|            NSPredicate *predicateMinusOneCondition = [predicate minusSubpredicatesFrom:subpredicate];
  286|      0|            if (predicateMinusOneCondition) {
  287|      0|                UIAccessibilityElement *match = [[UIApplication sharedApplication] accessibilityElementMatchingBlock:^BOOL (UIAccessibilityElement *element) {
  288|      0|                    return [predicateMinusOneCondition evaluateWithObject:element];
  289|      0|                }];
  290|      0|                if (match) {
  291|      0|                    return predicateMinusOneCondition;
  292|      0|                }
  293|      0|                [queue addObject:predicateMinusOneCondition];
  294|      0|            }
  295|      0|        }
  296|      0|    }
  297|      0|    return nil;
  298|      0|}
  299|       |
  300|       |+ (NSString *)stringFromAccessibilityTraits:(UIAccessibilityTraits)traits;
  301|      0|{
  302|      0|    if (traits == UIAccessibilityTraitNone) {
  303|      0|        return  @"UIAccessibilityTraitNone";
  304|      0|    }
  305|      0|    
  306|      0|    NSString *string = @"";
  307|      0|    
  308|      0|    NSArray *allTraits = @[
  309|      0|                           @(UIAccessibilityTraitButton),
  310|      0|                           @(UIAccessibilityTraitLink),
  311|      0|                           @(UIAccessibilityTraitHeader),
  312|      0|                           @(UIAccessibilityTraitSearchField),
  313|      0|                           @(UIAccessibilityTraitImage),
  314|      0|                           @(UIAccessibilityTraitSelected),
  315|      0|                           @(UIAccessibilityTraitPlaysSound),
  316|      0|                           @(UIAccessibilityTraitKeyboardKey),
  317|      0|                           @(UIAccessibilityTraitStaticText),
  318|      0|                           @(UIAccessibilityTraitSummaryElement),
  319|      0|                           @(UIAccessibilityTraitNotEnabled),
  320|      0|                           @(UIAccessibilityTraitUpdatesFrequently),
  321|      0|                           @(UIAccessibilityTraitStartsMediaSession),
  322|      0|                           @(UIAccessibilityTraitAdjustable),
  323|      0|                           @(UIAccessibilityTraitAllowsDirectInteraction),
  324|      0|                           @(UIAccessibilityTraitCausesPageTurn)
  325|      0|                           ];
  326|      0|    
  327|      0|    NSArray *traitNames = @[
  328|      0|                            @"UIAccessibilityTraitButton",
  329|      0|                            @"UIAccessibilityTraitLink",
  330|      0|                            @"UIAccessibilityTraitHeader",
  331|      0|                            @"UIAccessibilityTraitSearchField",
  332|      0|                            @"UIAccessibilityTraitImage",
  333|      0|                            @"UIAccessibilityTraitSelected",
  334|      0|                            @"UIAccessibilityTraitPlaysSound",
  335|      0|                            @"UIAccessibilityTraitKeyboardKey",
  336|      0|                            @"UIAccessibilityTraitStaticText",
  337|      0|                            @"UIAccessibilityTraitSummaryElement",
  338|      0|                            @"UIAccessibilityTraitNotEnabled",
  339|      0|                            @"UIAccessibilityTraitUpdatesFrequently",
  340|      0|                            @"UIAccessibilityTraitStartsMediaSession",
  341|      0|                            @"UIAccessibilityTraitAdjustable",
  342|      0|                            @"UIAccessibilityTraitAllowsDirectInteraction",
  343|      0|                            @"UIAccessibilityTraitCausesPageTurn"
  344|      0|                            ];
  345|      0|                            
  346|      0|    
  347|      0|    for (NSNumber *trait in allTraits) {
  348|      0|        if ((traits & trait.longLongValue) == trait.longLongValue) {
  349|      0|            NSString *name = [traitNames objectAtIndex:[allTraits indexOfObject:trait]];
  350|      0|            if (string.length > 0) {
  351|      0|                string = [string stringByAppendingString:@", "];
  352|      0|            }
  353|      0|            string = [string stringByAppendingString:name];
  354|      0|            traits &= ~trait.longLongValue;
  355|      0|        }
  356|      0|    }
  357|      0|    if (traits != UIAccessibilityTraitNone) {
  358|      0|        if (string.length > 0) {
  359|      0|            string = [string stringByAppendingString:@", "];
  360|      0|        }
  361|      0|        string = [string stringByAppendingFormat:@"UNKNOWN ACCESSIBILITY TRAIT: %llu", traits];
  362|      0|    }
  363|      0|    return string;
  364|      0|}
  365|       |
  366|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/UIApplication-KIFAdditions.h:
    1|       |//
    2|       |//  UIApplication-KIFAdditions.h
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Eric Firestone on 5/20/11.
    6|       |//  Licensed to Square, Inc. under one or more contributor license agreements.
    7|       |//  See the LICENSE file distributed with this work for the terms under
    8|       |//  which Square, Inc. licenses this file to you.
    9|       |
   10|       |#import <UIKit/UIKit.h>
   11|       |
   12|       |
   13|      0|#define UIApplicationCurrentRunMode ([[UIApplication sharedApplication] currentRunLoopMode])
   14|       |
   15|       |/*!
   16|       | @abstract When mocking @c -openURL: or -openURL:options:completionHandler:, this notification is posted.
   17|       | */
   18|       |UIKIT_EXTERN NSString *const UIApplicationDidMockOpenURLNotification;
   19|       |
   20|       |/*!
   21|       | @abstract When mocking @c -canOpenURL:, this notification is posted.
   22|       | */
   23|       |UIKIT_EXTERN NSString *const UIApplicationDidMockCanOpenURLNotification;
   24|       |
   25|       |/*!
   26|       | @abstract The key for the opened URL in the @c UIApplicationDidMockOpenURLNotification notification.
   27|       | */
   28|       |UIKIT_EXTERN NSString *const UIApplicationOpenedURLKey;
   29|       |
   30|       |/*!
   31|       | @abstract A wrapper for CFRunLoopRunInMode that scales the seconds parameter relative to the animation speed.
   32|       | */
   33|       |CF_EXPORT SInt32 KIFRunLoopRunInModeRelativeToAnimationSpeed(CFStringRef mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled);
   34|       |
   35|       |@interface UIApplication (KIFAdditions)
   36|       |
   37|       |/*!
   38|       | @abstract Finds an accessibility element with a matching label, value, and traits across all windows in the application starting at the frontmost window.
   39|       | @param label The accessibility label of the element to search for.
   40|       | @param value The accessibility value of the element to search for.  If @c nil, all values will be accepted.
   41|       | @param traits The accessibility traits of the element to search for. Elements that do not include at least these traits are ignored.
   42|       | @return The found accessibility element or @c nil if the element could not be found.
   43|       | */
   44|       |- (UIAccessibilityElement *)accessibilityElementWithLabel:(NSString *)label accessibilityValue:(NSString *)value traits:(UIAccessibilityTraits)traits;
   45|       |
   46|       |/*!
   47|       | @abstract Finds an accessibility element where @c matchBlock returns @c YES, across all windows in the application starting at the fronmost window.
   48|       | @discussion This method should be used if @c accessibilityElementWithLabel:accessibilityValue:traits: does not meet your requirements.  For example, if you are searching for an element that begins with a pattern or if of a certain view type.
   49|       | @param matchBlock  A block to be performed on each element to see if it passes.
   50|       | */
   51|       |- (UIAccessibilityElement *)accessibilityElementMatchingBlock:(BOOL(^)(UIAccessibilityElement *))matchBlock;
   52|       |
   53|       |/*!
   54|       | @returns The window containing the keyboard or @c nil if the keyboard is not visible.
   55|       | */
   56|       |- (UIWindow *)keyboardWindow;
   57|       |
   58|       |/*!
   59|       | @returns The topmost window containing a @c UIDatePicker.
   60|       | */
   61|       |- (UIWindow *)datePickerWindow;
   62|       |
   63|       |/*!
   64|       | @returns The topmost window containing a @c UIPickerView.
   65|       | */
   66|       |- (UIWindow *)pickerViewWindow;
   67|       |
   68|       |/*!
   69|       | @returns The topmost window containing a @c UIDimmingView.
   70|       | */
   71|       |- (UIWindow *)dimmingViewWindow;
   72|       |
   73|       |/*!
   74|       | @returns All windows in the application, including the key window even if it does not appear in @c -windows.
   75|       | */
   76|       |- (NSArray *)windowsWithKeyWindow;
   77|       |
   78|       |/*!
   79|       | The current Core Animation speed of the keyWindow's CALayer.
   80|       | */
   81|       |@property (nonatomic, assign) float animationSpeed;
   82|       |
   83|       |/*!
   84|       | @abstract Writes a screenshot to disk.
   85|       | @discussion This method only works if the @c KIF_SCREENSHOTS environment variable is set.
   86|       | @param lineNumber The line number in the code at which the screenshot was taken.
   87|       | @param filename The name of the file in which the screenshot was taken.
   88|       | @param description An optional description of the scene being captured.
   89|       | @param error If the method returns @c YES, this optional parameter provides additional information as to why it failed.
   90|       | @returns @c YES if the screenshot was written to disk, otherwise @c NO.
   91|       | */
   92|       |- (BOOL)writeScreenshotForLine:(NSUInteger)lineNumber inFile:(NSString *)filename description:(NSString *)description error:(NSError **)error;
   93|       |
   94|       |/*!
   95|       | @returns The current run loop mode.
   96|       | */
   97|       |- (CFStringRef)currentRunLoopMode;
   98|       |
   99|       |/*!
  100|       | @abstract Swizzles the run loop modes so KIF can better switch between them.
  101|       | */
  102|       |+ (void)swizzleRunLoop;
  103|       |
  104|       |/*!
  105|       | @abstract Starts mocking requests to @c -openURL:, announcing all requests with a notification.
  106|       | @discussion After calling this method, whenever @c -openURL: is called a notification named @c UIApplicationDidMockOpenURLNotification with the URL in the @c UIApplicationOpenedURL will be raised and the normal behavior will be cancelled.
  107|       | @param returnValue The value to return when @c -openURL: is called.
  108|       | */
  109|       |+ (void)startMockingOpenURLWithReturnValue:(BOOL)returnValue;
  110|       |
  111|       |/*!
  112|       | @abstract Stops the application from mocking requests to @c -openURL:.
  113|       | */
  114|       |+ (void)stopMockingOpenURL;
  115|       |
  116|       |@end
  117|       |
  118|       |@interface UIApplication (Private)
  119|       |- (UIWindow *)statusBarWindow;
  120|       |@property(getter=isStatusBarHidden) BOOL statusBarHidden;
  121|       |@end
  122|       |

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/UIApplication-KIFAdditions.m:
    1|       |//
    2|       |//  UIApplication-KIFAdditions.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Eric Firestone on 5/20/11.
    6|       |//  Licensed to Square, Inc. under one or more contributor license agreements.
    7|       |//  See the LICENSE file distributed with this work for the terms under
    8|       |//  which Square, Inc. licenses this file to you.
    9|       |
   10|       |#import "UIApplication-KIFAdditions.h"
   11|       |#import "LoadableCategory.h"
   12|       |#import "UIView-KIFAdditions.h"
   13|       |#import "NSError-KIFAdditions.h"
   14|       |#import <QuartzCore/QuartzCore.h>
   15|       |#import <objc/runtime.h>
   16|       |#import <objc/message.h>
   17|       |
   18|       |MAKE_CATEGORIES_LOADABLE(UIApplication_KIFAdditions)
   19|       |
   20|       |static BOOL _KIF_UIApplicationMockOpenURL = NO;
   21|       |static BOOL _KIF_UIApplicationMockOpenURL_returnValue = NO;
   22|       |
   23|       |SInt32 KIFRunLoopRunInModeRelativeToAnimationSpeed(CFStringRef mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)
   24|      0|{
   25|      0|    CFTimeInterval scaledSeconds = seconds / [UIApplication sharedApplication].animationSpeed;
   26|      0|    return CFRunLoopRunInMode(mode, scaledSeconds, returnAfterSourceHandled);
   27|      0|}
   28|       |
   29|       |@interface UIApplication (Undocumented)
   30|       |- (void)pushRunLoopMode:(id)arg1;
   31|       |- (void)pushRunLoopMode:(id)arg1 requester:(id)requester;
   32|       |- (void)popRunLoopMode:(id)arg1;
   33|       |- (void)popRunLoopMode:(id)arg1 requester:(id)requester;
   34|       |@end
   35|       |
   36|       |NSString *const UIApplicationDidMockOpenURLNotification = @"UIApplicationDidMockOpenURLNotification";
   37|       |NSString *const UIApplicationDidMockCanOpenURLNotification = @"UIApplicationDidMockCanOpenURLNotification";
   38|       |NSString *const UIApplicationOpenedURLKey = @"UIApplicationOpenedURL";
   39|       |static const void *KIFRunLoopModesKey = &KIFRunLoopModesKey;
   40|       |
   41|       |@implementation UIApplication (KIFAdditions)
   42|       |
   43|       |#pragma mark - Finding elements
   44|       |
   45|       |- (UIAccessibilityElement *)accessibilityElementWithLabel:(NSString *)label accessibilityValue:(NSString *)value traits:(UIAccessibilityTraits)traits;
   46|      6|{
   47|      6|    // Go through the array of windows in reverse order to process the frontmost window first.
   48|      6|    // When several elements with the same accessibilitylabel are present the one in front will be picked.
   49|     12|    for (UIWindow *window in [self.windowsWithKeyWindow reverseObjectEnumerator]) {
   50|     12|        if (window.hidden) {
   51|      0|            continue;
   52|      0|        }
   53|     12|        UIAccessibilityElement *element = [window accessibilityElementWithLabel:label accessibilityValue:value traits:traits];
   54|     12|        if (element) {
   55|      3|            return element;
   56|      3|        }
   57|     12|    }
   58|      6|    
   59|      6|    return nil;
   60|      6|}
   61|       |
   62|       |- (UIAccessibilityElement *)accessibilityElementMatchingBlock:(BOOL(^)(UIAccessibilityElement *))matchBlock;
   63|      0|{
   64|      0|    for (UIWindow *window in [self.windowsWithKeyWindow reverseObjectEnumerator]) {
   65|      0|        UIAccessibilityElement *element = [window accessibilityElementMatchingBlock:matchBlock];
   66|      0|        if (element) {
   67|      0|            return element;
   68|      0|        }
   69|      0|    }
   70|      0|    
   71|      0|    return nil;
   72|      0|}
   73|       |
   74|       |#pragma mark - Interesting windows
   75|       |
   76|       |- (UIWindow *)keyboardWindow;
   77|      0|{
   78|      0|    for (UIWindow *window in self.windowsWithKeyWindow) {
   79|      0|        if ([NSStringFromClass([window class]) isEqual:@"UITextEffectsWindow"]) {
   80|      0|            return window;
   81|      0|        }
   82|      0|    }
   83|      0|    
   84|      0|    return nil;
   85|      0|}
   86|       |
   87|       |- (UIWindow *)datePickerWindow;
   88|      0|{
   89|      0|    return [self getWindowForSubviewClass:@"UIDatePicker"];
   90|      0|}
   91|       |
   92|       |- (UIWindow *)pickerViewWindow;
   93|      0|{
   94|      0|    return [self getWindowForSubviewClass:@"UIPickerView"];
   95|      0|}
   96|       |
   97|       |- (UIWindow *)dimmingViewWindow;
   98|      0|{
   99|      0|    return [self getWindowForSubviewClass:@"UIDimmingView"];
  100|      0|}
  101|       |
  102|       |- (UIWindow *)getWindowForSubviewClass:(NSString*)className;
  103|      0|{
  104|      0|    for (UIWindow *window in self.windowsWithKeyWindow) {
  105|      0|        NSArray *subViews = [window subviewsWithClassNameOrSuperClassNamePrefix:className];
  106|      0|        if (subViews.count > 0) {
  107|      0|            return window;
  108|      0|        }
  109|      0|    }
  110|      0|
  111|      0|    return nil;
  112|      0|}
  113|       |
  114|       |- (NSArray *)windowsWithKeyWindow
  115|      6|{
  116|      6|    NSMutableArray *windows = self.windows.mutableCopy;
  117|      6|    UIWindow *keyWindow = self.keyWindow;
  118|      6|    if (![windows containsObject:keyWindow]) {
  119|      0|        [windows addObject:keyWindow];
  120|      0|    }
  121|      6|    return windows;
  122|      6|}
  123|       |
  124|       |- (float)animationSpeed
  125|      0|{
  126|      0|    if (!self.keyWindow) {
  127|      0|        return 1.0f;
  128|      0|    }
  129|      0|    return self.keyWindow.layer.speed;
  130|      0|}
  131|       |
  132|       |- (void)setAnimationSpeed:(float)animationSpeed
  133|      0|{
  134|      0|    self.keyWindow.layer.speed = animationSpeed;
  135|      0|}
  136|       |
  137|       |#pragma mark - Screenshotting
  138|       |
  139|       |- (BOOL)writeScreenshotForLine:(NSUInteger)lineNumber inFile:(NSString *)filename description:(NSString *)description error:(NSError **)error;
  140|      0|{
  141|      0|    NSString *outputPath = [[[NSProcessInfo processInfo] environment] objectForKey:@"KIF_SCREENSHOTS"];
  142|      0|    if (!outputPath) {
  143|      0|        if (error) {
  144|      0|            *error = [NSError KIFErrorWithFormat:@"Screenshot path not defined. Please set KIF_SCREENSHOTS environment variable."];
  145|      0|        }
  146|      0|        return NO;
  147|      0|    }
  148|      0|    
  149|      0|    NSArray *windows = [self windowsWithKeyWindow];
  150|      0|    if (windows.count == 0) {
  151|      0|        if (error) {
  152|      0|            *error = [NSError KIFErrorWithFormat:@"Could not take screenshot.  No windows were available."];
  153|      0|        }
  154|      0|        return NO;
  155|      0|    }
  156|      0|    
  157|      0|    if (!filename.length) {
  158|      0|        if (error) {
  159|      0|            *error = [NSError KIFErrorWithFormat:@"Missing screenshot filename."];
  160|      0|        }
  161|      0|        return NO;
  162|      0|    }
  163|      0|    
  164|      0|    UIGraphicsBeginImageContextWithOptions([[windows objectAtIndex:0] bounds].size, YES, 0);
  165|      0|    for (UIWindow *window in windows) {
  166|      0|		//avoid https://github.com/kif-framework/KIF/issues/679
  167|      0|		if (window.hidden) {
  168|      0|			continue;
  169|      0|		}
  170|      0|
  171|      0|        if ([window respondsToSelector:@selector(drawViewHierarchyInRect:afterScreenUpdates:)]) {
  172|      0|            [window drawViewHierarchyInRect:window.bounds afterScreenUpdates:YES];
  173|      0|        } else {
  174|      0|            [window.layer renderInContext:UIGraphicsGetCurrentContext()];
  175|      0|        }
  176|      0|    }
  177|      0|    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
  178|      0|    UIGraphicsEndImageContext();
  179|      0|
  180|      0|    outputPath = [outputPath stringByExpandingTildeInPath];
  181|      0|
  182|      0|    NSError *directoryCreationError = nil;
  183|      0|    if (![[NSFileManager defaultManager] createDirectoryAtPath:outputPath withIntermediateDirectories:YES attributes:nil error:&directoryCreationError]) {
  184|      0|        if (directoryCreationError) {
  185|      0|            *error = [NSError KIFErrorWithFormat:@"Couldn't create directory at path %@ (details: %@)", outputPath, directoryCreationError];
  186|      0|        }
  187|      0|        return NO;
  188|      0|    }
  189|      0|
  190|      0|    NSString *imageName = [self imageNameForFile:filename lineNumber:lineNumber description:description];
  191|      0|    
  192|      0|    outputPath = [outputPath stringByAppendingPathComponent:imageName];
  193|      0|    outputPath = [outputPath stringByAppendingPathExtension:@"png"];
  194|      0|
  195|      0|    if (![UIImagePNGRepresentation(image) writeToFile:outputPath atomically:YES]) {
  196|      0|        if (error) {
  197|      0|            *error = [NSError KIFErrorWithFormat:@"Could not write file at path %@", outputPath];
  198|      0|        }
  199|      0|        return NO;
  200|      0|    }
  201|      0|    
  202|      0|    return YES;
  203|      0|}
  204|       |
  205|      0|- (NSString *)imageNameForFile:(NSString *)filename lineNumber:(NSUInteger)lineNumber description:(NSString *)description {
  206|      0|    if (!filename.length) {
  207|      0|        return nil;
  208|      0|    }
  209|      0|    
  210|      0|    NSString *imageName = [filename lastPathComponent];
  211|      0|    
  212|      0|    if (lineNumber > 0) {
  213|      0|        imageName = [imageName stringByAppendingFormat:@", line %lu", (unsigned long)lineNumber];
  214|      0|    }
  215|      0|    
  216|      0|    if (description.length) {
  217|      0|        imageName = [imageName stringByAppendingFormat:@", %@", description];
  218|      0|    }
  219|      0|
  220|      0|    return imageName;
  221|      0|}
  222|       |
  223|       |#pragma mark - Run loop monitoring
  224|       |
  225|       |- (NSMutableArray *)KIF_runLoopModes;
  226|      1|{
  227|      1|    NSMutableArray *modes = objc_getAssociatedObject(self, KIFRunLoopModesKey);
  228|      1|    if (!modes) {
  229|      1|        modes = [NSMutableArray arrayWithObject:(id)kCFRunLoopDefaultMode];
  230|      1|        objc_setAssociatedObject(self, KIFRunLoopModesKey, modes, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  231|      1|    }
  232|      1|    return modes;
  233|      1|}
  234|       |
  235|       |- (CFStringRef)currentRunLoopMode;
  236|      1|{
  237|      1|    return (__bridge CFStringRef)[self KIF_runLoopModes].lastObject;
  238|      1|}
  239|       |
  240|       |- (void)KIF_pushRunLoopMode:(NSString *)mode;
  241|      0|{
  242|      0|    [[self KIF_runLoopModes] addObject:mode];
  243|      0|    [self KIF_pushRunLoopMode:mode];
  244|      0|}
  245|       |
  246|       |- (void)KIF_pushRunLoopMode:(NSString *)mode requester:(id)requester;
  247|      0|{
  248|      0|    [[self KIF_runLoopModes] addObject:mode];
  249|      0|    [self KIF_pushRunLoopMode:mode requester:requester];
  250|      0|}
  251|       |
  252|       |- (void)KIF_popRunLoopMode:(NSString *)mode;
  253|      0|{
  254|      0|    [[self KIF_runLoopModes] removeLastObject];
  255|      0|    [self KIF_popRunLoopMode:mode];
  256|      0|}
  257|       |
  258|       |
  259|       |- (void)KIF_popRunLoopMode:(NSString *)mode requester:(id)requester;
  260|      0|{
  261|      0|    [[self KIF_runLoopModes] removeLastObject];
  262|      0|    [self KIF_popRunLoopMode:mode requester:requester];
  263|      0|}
  264|       |
  265|       |- (BOOL)KIF_openURL:(NSURL *)URL;
  266|      0|{
  267|      0|    if (_KIF_UIApplicationMockOpenURL) {
  268|      0|        [[NSNotificationCenter defaultCenter] postNotificationName:UIApplicationDidMockOpenURLNotification object:self userInfo:@{UIApplicationOpenedURLKey: URL}];
  269|      0|        return _KIF_UIApplicationMockOpenURL_returnValue;
  270|      0|    } else {
  271|      0|        return [self KIF_openURL:URL];
  272|      0|    }
  273|      0|}
  274|       |
  275|       |#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 100000
  276|       |- (BOOL)KIF_openURL:(NSURL *)URL options:(NSDictionary<NSString *, id> *)options completionHandler:(void (^ __nullable)(BOOL success))completionHandler;
  277|      0|{
  278|      0|    if (_KIF_UIApplicationMockOpenURL) {
  279|      0|        [[NSNotificationCenter defaultCenter] postNotificationName:UIApplicationDidMockOpenURLNotification object:self userInfo:@{UIApplicationOpenedURLKey: URL}];
  280|      0|        return _KIF_UIApplicationMockOpenURL_returnValue;
  281|      0|    } else {
  282|      0|        return [self KIF_openURL:URL options: options completionHandler: completionHandler];
  283|      0|    }
  284|      0|}
  285|       |#endif
  286|       |
  287|       |- (BOOL)KIF_canOpenURL:(NSURL *)URL;
  288|      0|{
  289|      0|    if (_KIF_UIApplicationMockOpenURL) {
  290|      0|        [[NSNotificationCenter defaultCenter] postNotificationName:UIApplicationDidMockCanOpenURLNotification object:self userInfo:@{UIApplicationOpenedURLKey: URL}];
  291|      0|        return _KIF_UIApplicationMockOpenURL_returnValue;
  292|      0|    } else {
  293|      0|        return [self KIF_canOpenURL:URL];
  294|      0|    }
  295|      0|}
  296|       |
  297|       |static inline void Swizzle(Class c, SEL orig, SEL new)
  298|      4|{
  299|      4|    Method origMethod = class_getInstanceMethod(c, orig);
  300|      4|    Method newMethod = class_getInstanceMethod(c, new);
  301|      4|    if(class_addMethod(c, orig, method_getImplementation(newMethod), method_getTypeEncoding(newMethod)))
  302|      0|        class_replaceMethod(c, new, method_getImplementation(origMethod), method_getTypeEncoding(origMethod));
  303|      4|    else
  304|      4|        method_exchangeImplementations(origMethod, newMethod);
  305|      4|}
  306|       |
  307|       |+ (void)swizzleRunLoop;
  308|      1|{
  309|      1|    static dispatch_once_t onceToken;
  310|      1|    dispatch_once(&onceToken, ^{
  311|      1|        Swizzle(self, @selector(pushRunLoopMode:), @selector(KIF_pushRunLoopMode:));
  312|      1|        Swizzle(self, @selector(pushRunLoopMode:requester:), @selector(KIF_pushRunLoopMode:requester:));
  313|      1|        Swizzle(self, @selector(popRunLoopMode:), @selector(KIF_popRunLoopMode:));
  314|      1|        Swizzle(self, @selector(popRunLoopMode:requester:), @selector(KIF_popRunLoopMode:requester:));
  315|      1|    });
  316|      1|}
  317|       |
  318|       |#pragma mark - openURL mocking
  319|       |
  320|       |+ (void)startMockingOpenURLWithReturnValue:(BOOL)returnValue;
  321|      0|{
  322|      0|    static dispatch_once_t onceToken;
  323|      0|    dispatch_once(&onceToken, ^{
  324|      0|        Swizzle(self, @selector(openURL:), @selector(KIF_openURL:));
  325|      0|        #if __IPHONE_OS_VERSION_MAX_ALLOWED >= 100000
  326|      0|            Swizzle(self, @selector(openURL:options:completionHandler:), @selector(KIF_openURL:options:completionHandler:));
  327|      0|        #endif
  328|      0|        Swizzle(self, @selector(canOpenURL:), @selector(KIF_canOpenURL:));
  329|      0|    });
  330|      0|
  331|      0|    _KIF_UIApplicationMockOpenURL = YES;
  332|      0|    _KIF_UIApplicationMockOpenURL_returnValue = returnValue;
  333|      0|}
  334|       |
  335|       |+ (void)stopMockingOpenURL;
  336|      0|{
  337|      0|    _KIF_UIApplicationMockOpenURL = NO;
  338|      0|}
  339|       |
  340|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/UIEvent+KIFAdditions.m:
    1|       |//
    2|       |//  UIEvent+KIFAdditions.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Thomas on 3/1/15.
    6|       |//
    7|       |//
    8|       |
    9|       |#import "UIEvent+KIFAdditions.h"
   10|       |#import "LoadableCategory.h"
   11|       |#import "IOHIDEvent+KIF.h"
   12|       |
   13|       |MAKE_CATEGORIES_LOADABLE(UIEvent_KIFAdditions)
   14|       |
   15|       |//
   16|       |// GSEvent is an undeclared object. We don't need to use it ourselves but some
   17|       |// Apple APIs (UIScrollView in particular) require the x and y fields to be present.
   18|       |//
   19|       |@interface KIFGSEventProxy : NSObject
   20|       |{
   21|       |@public
   22|       |    unsigned int flags;
   23|       |    unsigned int type;
   24|       |    unsigned int ignored1;
   25|       |    float x1;
   26|       |    float y1;
   27|       |    float x2;
   28|       |    float y2;
   29|       |    unsigned int ignored2[10];
   30|       |    unsigned int ignored3[7];
   31|       |    float sizeX;
   32|       |    float sizeY;
   33|       |    float x3;
   34|       |    float y3;
   35|       |    unsigned int ignored4[3];
   36|       |}
   37|       |@end
   38|       |
   39|       |@implementation KIFGSEventProxy
   40|       |@end
   41|       |
   42|       |typedef struct __GSEvent * GSEventRef;
   43|       |
   44|       |@interface UIEvent (KIFAdditionsMorePrivateHeaders)
   45|       |- (void)_setGSEvent:(GSEventRef)event;
   46|       |- (void)_setHIDEvent:(IOHIDEventRef)event;
   47|       |- (void)_setTimestamp:(NSTimeInterval)timestemp;
   48|       |@end
   49|       |
   50|       |@implementation UIEvent (KIFAdditions)
   51|       |
   52|       |- (void)kif_setEventWithTouches:(NSArray *)touches
   53|      0|{
   54|      0|    NSOperatingSystemVersion iOS8 = {8, 0, 0};
   55|      0|    if ([NSProcessInfo instancesRespondToSelector:@selector(isOperatingSystemAtLeastVersion:)]
   56|      0|        && [[NSProcessInfo new] isOperatingSystemAtLeastVersion:iOS8]) {
   57|      0|        [self kif_setIOHIDEventWithTouches:touches];
   58|      0|    } else {
   59|      0|        [self kif_setGSEventWithTouches:touches];
   60|      0|    }
   61|      0|}
   62|       |
   63|       |- (void)kif_setGSEventWithTouches:(NSArray *)touches
   64|      0|{
   65|      0|    UITouch *touch = touches[0];
   66|      0|    CGPoint location = [touch locationInView:touch.window];
   67|      0|    KIFGSEventProxy *gsEventProxy = [[KIFGSEventProxy alloc] init];
   68|      0|    gsEventProxy->x1 = location.x;
   69|      0|    gsEventProxy->y1 = location.y;
   70|      0|    gsEventProxy->x2 = location.x;
   71|      0|    gsEventProxy->y2 = location.y;
   72|      0|    gsEventProxy->x3 = location.x;
   73|      0|    gsEventProxy->y3 = location.y;
   74|      0|    gsEventProxy->sizeX = 1.0;
   75|      0|    gsEventProxy->sizeY = 1.0;
   76|      0|    gsEventProxy->flags = ([touch phase] == UITouchPhaseEnded) ? 0x1010180 : 0x3010180;
   77|      0|    gsEventProxy->type = 3001;
   78|      0|    
   79|      0|    [self _setGSEvent:(GSEventRef)gsEventProxy];
   80|      0|    
   81|      0|    [self _setTimestamp:(((UITouch*)touches[0]).timestamp)];
   82|      0|}
   83|       |
   84|       |- (void)kif_setIOHIDEventWithTouches:(NSArray *)touches
   85|      0|{
   86|      0|    IOHIDEventRef event = kif_IOHIDEventWithTouches(touches);
   87|      0|    [self _setHIDEvent:event];
   88|      0|    CFRelease(event);
   89|      0|}
   90|       |
   91|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/UIScreen+KIFAdditions.m:
    1|       |//
    2|       |//  UIScreen+KIFAdditions.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Steven King on 25/02/2016.
    6|       |//
    7|       |//
    8|       |
    9|       |#import "UIScreen+KIFAdditions.h"
   10|       |
   11|       |@implementation UIScreen (KIFAdditions)
   12|       |
   13|      0|- (CGFloat)majorSwipeDisplacement {
   14|      0|    return self.bounds.size.width * 0.5;
   15|      0|}
   16|       |
   17|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/UIScrollView-KIFAdditions.m:
    1|       |//
    2|       |//  UIScrollView-KIFAdditions.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Eric Firestone on 5/22/11.
    6|       |//  Licensed to Square, Inc. under one or more contributor license agreements.
    7|       |//  See the LICENSE file distributed with this work for the terms under
    8|       |//  which Square, Inc. licenses this file to you.
    9|       |
   10|       |#import "UIScrollView-KIFAdditions.h"
   11|       |#import "LoadableCategory.h"
   12|       |#import "UIApplication-KIFAdditions.h"
   13|       |#import "UIView-KIFAdditions.h"
   14|       |
   15|       |
   16|       |MAKE_CATEGORIES_LOADABLE(UIScrollView_KIFAdditions)
   17|       |
   18|       |
   19|       |@implementation UIScrollView (KIFAdditions)
   20|       |
   21|       |- (void)scrollViewToVisible:(UIView *)view animated:(BOOL)animated;
   22|      3|{
   23|      3|    CGRect viewFrame = [self convertRect:view.bounds fromView:view];
   24|      3|    CGPoint contentOffset = self.contentOffset;
   25|      3|    
   26|      3|    if (CGRectGetMaxX(viewFrame) > self.contentOffset.x + CGRectGetWidth(self.bounds)) {
   27|      0|        contentOffset.x = MIN(CGRectGetMaxX(viewFrame) - CGRectGetWidth(self.bounds), CGRectGetMinX(viewFrame));
   28|      3|    } else if (CGRectGetMinX(viewFrame) < self.contentOffset.x) {
   29|      0|        contentOffset.x = MAX(CGRectGetMaxX(viewFrame) - CGRectGetWidth(self.bounds), CGRectGetMinX(viewFrame));
   30|      0|    }
   31|      3|    
   32|      3|    if (CGRectGetMaxY(viewFrame) > self.contentOffset.y + CGRectGetHeight(self.bounds)) {
   33|      0|        contentOffset.y = MIN(CGRectGetMaxY(viewFrame) - CGRectGetHeight(self.bounds), CGRectGetMinY(viewFrame));
   34|      3|    } else if (CGRectGetMinY(viewFrame) < self.contentOffset.y) {
   35|      0|        contentOffset.y = MAX(CGRectGetMaxY(viewFrame) - CGRectGetHeight(self.bounds), CGRectGetMinY(viewFrame));
   36|      0|    }
   37|      3|
   38|      3|    UIEdgeInsets contentInset;
   39|      3|#ifdef __IPHONE_11_0
   40|      3|        if (@available(iOS 11.0, *)) {
   41|      3|            contentInset = self.adjustedContentInset;
   42|      3|        } else {
   43|      0|            contentInset = self.contentInset;
   44|      0|        }
   45|       |#else
   46|       |    contentInset = self.contentInset;
   47|       |#endif
   48|       |    CGFloat minX = -self.contentInset.left;
   49|      3|    CGFloat maxX = minX + MAX(0, self.contentSize.width + contentInset.right - CGRectGetWidth(self.bounds));
   50|      3|    CGFloat minY = -self.contentInset.top;
   51|      3|    CGFloat maxY = minY + MAX(0, self.contentSize.height + contentInset.bottom - CGRectGetHeight(self.bounds));
   52|      3|    contentOffset.x = MAX(minX, MIN(contentOffset.x, maxX));
   53|      3|    contentOffset.y = MAX(minY, MIN(contentOffset.y, maxY));
   54|      3|    
   55|      3|    if (!CGPointEqualToPoint(contentOffset, self.contentOffset)) {
   56|      0|        [self setContentOffset:contentOffset animated:animated];
   57|      0|        KIFRunLoopRunInModeRelativeToAnimationSpeed(kCFRunLoopDefaultMode, 0.2, false);
   58|      0|    }
   59|      3|}
   60|       |
   61|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/UITableView-KIFAdditions.m:
    1|       |//
    2|       |//  UITableView-KIFAdditions.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Hilton Campbell on 4/12/14.
    6|       |//  Licensed to Square, Inc. under one or more contributor license agreements.
    7|       |//  See the LICENSE file distributed with this work for the terms under
    8|       |//  which Square, Inc. licenses this file to you.
    9|       |
   10|       |#import "UITableView-KIFAdditions.h"
   11|       |#import "UIView-KIFAdditions.h"
   12|       |#import "UIApplication-KIFAdditions.h"
   13|       |#import "UITouch-KIFAdditions.h"
   14|       |#import "CGGeometry-KIFAdditions.h"
   15|       |#import "NSError-KIFAdditions.h"
   16|       |
   17|       |@implementation UITableView (KIFAdditions)
   18|       |
   19|      0|#define DRAG_STEP_DISTANCE 5
   20|       |
   21|       |- (BOOL)dragCell:(UITableViewCell *)cell toIndexPath:(NSIndexPath *)indexPath error:(NSError **)error;
   22|      0|{
   23|      0|    UIView *sourceReorderControl = [[cell subviewsWithClassNameOrSuperClassNamePrefix:@"UITableViewCellReorderControl"] lastObject];
   24|      0|    if (!sourceReorderControl) {
   25|      0|        if (error) {
   26|      0|            *error = [NSError KIFErrorWithFormat:@"Failed to find reorder control for cell"];
   27|      0|        }
   28|      0|        return NO;
   29|      0|    }
   30|      0|    
   31|      0|    CGPoint sourcePoint = [self convertPoint:CGPointCenteredInRect(sourceReorderControl.bounds) fromView:sourceReorderControl];
   32|      0|    
   33|      0|    // If section < 0, search from the end of the table.
   34|      0|    if (indexPath.section < 0) {
   35|      0|        indexPath = [NSIndexPath indexPathForRow:indexPath.row inSection:self.numberOfSections + indexPath.section];
   36|      0|    }
   37|      0|    
   38|      0|    // If row < 0, search from the end of the section.
   39|      0|    if (indexPath.row < 0) {
   40|      0|        indexPath = [NSIndexPath indexPathForRow:[self numberOfRowsInSection:indexPath.section] + indexPath.row inSection:indexPath.section];
   41|      0|    }
   42|      0|    
   43|      0|    CGRect destinationCellRect = [self rectForRowAtIndexPath:indexPath];
   44|      0|    CGFloat destinationDragY = CGPointCenteredInRect(destinationCellRect).y;
   45|      0|
   46|      0|    // In iOS11, the behavior for dragging table rows has been changed to be dependent on the direction that they are being dragged
   47|      0|    NSOperatingSystemVersion iOS11 = {11, 0, 0};
   48|      0|    if ([NSProcessInfo instancesRespondToSelector:@selector(isOperatingSystemAtLeastVersion:)] && [[NSProcessInfo new] isOperatingSystemAtLeastVersion:iOS11]) {
   49|      0|        if (destinationDragY - sourcePoint.y > 0) {
   50|      0|            // Dragging Down
   51|      0|            destinationDragY += destinationCellRect.size.height;
   52|      0|        }
   53|      0|    }
   54|      0|    CGPoint destinationPoint = CGPointMake(sourcePoint.x, destinationDragY);
   55|      0|    
   56|      0|    // Create the touch (there should only be one touch object for the whole drag)
   57|      0|    UITouch *touch = [[UITouch alloc] initAtPoint:sourcePoint inView:self];
   58|      0|    [touch setPhaseAndUpdateTimestamp:UITouchPhaseBegan];
   59|      0|    
   60|      0|    UIEvent *eventDown = [self eventWithTouch:touch];
   61|      0|    [[UIApplication sharedApplication] sendEvent:eventDown];
   62|      0|    
   63|      0|    // Hold long enough to enter reordering mode
   64|      0|    CFRunLoopRunInMode(UIApplicationCurrentRunMode, 0.2, false);
   65|      0|    
   66|      0|    CGPoint currentLocation = sourcePoint;
   67|      0|    while (currentLocation.y < destinationPoint.y - DRAG_STEP_DISTANCE || currentLocation.y > destinationPoint.y + DRAG_STEP_DISTANCE) {
   68|      0|        if (currentLocation.y < destinationPoint.y) {
   69|      0|            currentLocation.y += DRAG_STEP_DISTANCE;
   70|      0|        } else {
   71|      0|            currentLocation.y -= DRAG_STEP_DISTANCE;
   72|      0|        }
   73|      0|        
   74|      0|        [touch setLocationInWindow:[self.window convertPoint:currentLocation fromView:self]];
   75|      0|        [touch setPhaseAndUpdateTimestamp:UITouchPhaseMoved];
   76|      0|        
   77|      0|        UIEvent *eventDrag = [self eventWithTouch:touch];
   78|      0|        [[UIApplication sharedApplication] sendEvent:eventDrag];
   79|      0|        
   80|      0|        CFRunLoopRunInMode(UIApplicationCurrentRunMode, 0.01, false);
   81|      0|    }
   82|      0|    
   83|      0|    // Hold long enough for the animations to catch up
   84|      0|    CFRunLoopRunInMode(UIApplicationCurrentRunMode, 0.2, false);
   85|      0|    
   86|      0|    [touch setPhaseAndUpdateTimestamp:UITouchPhaseEnded];
   87|      0|    
   88|      0|    UIEvent *eventUp = [self eventWithTouch:touch];
   89|      0|    [[UIApplication sharedApplication] sendEvent:eventUp];
   90|      0|    
   91|      0|    // Dispatching the event doesn't actually update the first responder, so fake it
   92|      0|    if (touch.view == self && [self canBecomeFirstResponder]) {
   93|      0|        [self becomeFirstResponder];
   94|      0|    }
   95|      0|    return YES;
   96|      0|}
   97|       |
   98|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/UITouch-KIFAdditions.m:
    1|       |//
    2|       |//  UITouch-KIFAdditions.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Eric Firestone on 5/20/11.
    6|       |//  Licensed to Square, Inc. under one or more contributor license agreements.
    7|       |//  See the LICENSE file distributed with this work for the terms under
    8|       |//  which Square, Inc. licenses this file to you.
    9|       |
   10|       |#import "UITouch-KIFAdditions.h"
   11|       |#import "LoadableCategory.h"
   12|       |#import <objc/runtime.h>
   13|       |#import "IOHIDEvent+KIF.h"
   14|       |
   15|       |MAKE_CATEGORIES_LOADABLE(UITouch_KIFAdditions)
   16|       |
   17|       |typedef struct {
   18|       |    unsigned int _firstTouchForView:1;
   19|       |    unsigned int _isTap:1;
   20|       |    unsigned int _isDelayed:1;
   21|       |    unsigned int _sentTouchesEnded:1;
   22|       |    unsigned int _abandonForwardingRecord:1;
   23|       |} UITouchFlags;
   24|       |
   25|       |@interface UITouch ()
   26|       |
   27|       |
   28|       |- (void)setWindow:(UIWindow *)window;
   29|       |- (void)setView:(UIView *)view;
   30|       |- (void)setTapCount:(NSUInteger)tapCount;
   31|       |- (void)setIsTap:(BOOL)isTap;
   32|       |- (void)setTimestamp:(NSTimeInterval)timestamp;
   33|       |- (void)setPhase:(UITouchPhase)touchPhase;
   34|       |- (void)setGestureView:(UIView *)view;
   35|       |- (void)_setLocationInWindow:(CGPoint)location resetPrevious:(BOOL)resetPrevious;
   36|       |- (void)_setIsFirstTouchForView:(BOOL)firstTouchForView;
   37|       |
   38|       |- (void)_setHidEvent:(IOHIDEventRef)event;
   39|       |
   40|       |@end
   41|       |
   42|       |@implementation UITouch (KIFAdditions)
   43|       |
   44|       |- (id)initInView:(UIView *)view;
   45|      0|{
   46|      0|    CGRect frame = view.frame;    
   47|      0|    CGPoint centerPoint = CGPointMake(frame.size.width * 0.5f, frame.size.height * 0.5f);
   48|      0|    return [self initAtPoint:centerPoint inView:view];
   49|      0|}
   50|       |
   51|       |- (id)initAtPoint:(CGPoint)point inWindow:(UIWindow *)window;
   52|      0|{
   53|      0|	self = [super init];
   54|      0|	if (self == nil) {
   55|      0|        return nil;
   56|      0|    }
   57|      0|    
   58|      0|    // Create a fake tap touch
   59|      0|    [self setWindow:window]; // Wipes out some values.  Needs to be first.
   60|      0|    
   61|      0|    [self setTapCount:1];
   62|      0|    [self _setLocationInWindow:point resetPrevious:YES];
   63|      0|    
   64|      0|	UIView *hitTestView = [window hitTest:point withEvent:nil];
   65|      0|    
   66|      0|    [self setView:hitTestView];
   67|      0|    [self setPhase:UITouchPhaseBegan];
   68|      0|    [self _setIsFirstTouchForView:YES];
   69|      0|    [self setIsTap:YES];
   70|      0|    [self setTimestamp:[[NSProcessInfo processInfo] systemUptime]];
   71|      0|    
   72|      0|    if ([self respondsToSelector:@selector(setGestureView:)]) {
   73|      0|        [self setGestureView:hitTestView];
   74|      0|    }
   75|      0|    
   76|      0|    // Starting with iOS 9, internal IOHIDEvent must be set for UITouch object
   77|      0|    NSOperatingSystemVersion iOS9 = {9, 0, 0};
   78|      0|    if ([NSProcessInfo instancesRespondToSelector:@selector(isOperatingSystemAtLeastVersion:)] && [[NSProcessInfo new] isOperatingSystemAtLeastVersion:iOS9]) {
   79|      0|        [self kif_setHidEvent];
   80|      0|    }
   81|      0|    
   82|      0|	return self;
   83|      0|}
   84|       |
   85|       |- (id)initAtPoint:(CGPoint)point inView:(UIView *)view;
   86|      0|{
   87|      0|    return [self initAtPoint:[view.window convertPoint:point fromView:view] inWindow:view.window];
   88|      0|}
   89|       |
   90|       |//
   91|       |// setLocationInWindow:
   92|       |//
   93|       |// Setter to allow access to the _locationInWindow member.
   94|       |//
   95|       |- (void)setLocationInWindow:(CGPoint)location
   96|      0|{
   97|      0|    [self setTimestamp:[[NSProcessInfo processInfo] systemUptime]];
   98|      0|    [self _setLocationInWindow:location resetPrevious:NO];
   99|      0|}
  100|       |
  101|       |- (void)setPhaseAndUpdateTimestamp:(UITouchPhase)phase
  102|      0|{
  103|      0|    [self setTimestamp:[[NSProcessInfo processInfo] systemUptime]];
  104|      0|    [self setPhase:phase];
  105|      0|}
  106|       |
  107|      0|- (void)kif_setHidEvent {
  108|      0|    IOHIDEventRef event = kif_IOHIDEventWithTouches(@[self]);
  109|      0|    [self _setHidEvent:event];
  110|      0|    CFRelease(event);
  111|      0|}
  112|       |
  113|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/UIView-Debugging.m:
    1|       |//
    2|       |//  UIView+Debugging.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Graeme Arthur on 02/05/15.
    6|       |//
    7|       |
    8|       |#import "UIView-Debugging.h"
    9|       |
   10|       |@implementation UIView (Debugging)
   11|       |
   12|      0|+(void)printViewHierarchy {
   13|      0|    NSArray* windows = [UIApplication sharedApplication].windows;
   14|      0|    if(windows.count == 1) {
   15|      0|        [windows[0] printViewHierarchy];
   16|      0|    } else {
   17|      0|        //more than one window, also print some information about each window
   18|      0|        for (UIWindow* window in windows) {
   19|      0|            printf("Window level %f", window.windowLevel);
   20|      0|            if(window.isKeyWindow) printf(" (key window)");
   21|      0|            printf("\n");
   22|      0|            [window printViewHierarchy];
   23|      0|            printf("\n");
   24|      0|        }
   25|      0|    }
   26|      0|}
   27|       |
   28|      0|- (void)printViewHierarchy {
   29|      0|    [self printViewHierarchyWithIndentation:0];
   30|      0|}
   31|       |
   32|      0|- (void)printViewHierarchyWithIndentation:(int)indent {
   33|      0|    [self printIndentation:indent];
   34|      0|    [self printClassName];
   35|      0|
   36|      0|    [self printAccessibilityInfo];
   37|      0|
   38|      0|    if(self.hidden) {
   39|      0|        printf(" (invisible)");
   40|      0|    }
   41|      0|
   42|      0|    if([self isKindOfClass:[UIImageView class]]) {
   43|      0|        [self printImageHighlightedState];
   44|      0|    }
   45|      0|
   46|      0|    if([self isKindOfClass:[UIControl class]]) {
   47|      0|        [self printControlState];
   48|      0|    }
   49|      0|    printf("\n");
   50|      0|
   51|      0|    [self printAccessibilityElementsWithIndentation:indent];
   52|      0|
   53|      0|    for (UIView *subview in self.subviews) {
   54|      0|        [subview printViewHierarchyWithIndentation:indent+1];
   55|      0|    }
   56|      0|}
   57|       |
   58|      0|- (void)printIndentation:(int)indent {
   59|      0|    for(int i = 0; i < indent; ++i) {
   60|      0|        printf("|\t");
   61|      0|    }
   62|      0|}
   63|       |
   64|      0|- (void)printClassName {
   65|      0|    NSString* name = NSStringFromClass([self class]);
   66|      0|    printf("%s", name.UTF8String);
   67|      0|}
   68|       |
   69|      0|- (void)printAccessibilityInfo {
   70|      0|    NSString* label = self.accessibilityLabel;
   71|      0|    NSString* identifier = self.accessibilityIdentifier;
   72|      0|    if(label != nil) {
   73|      0|        printf(", label: %s", label.UTF8String);
   74|      0|    } else if(identifier != nil) {
   75|      0|        printf(", identifier: %s", identifier.UTF8String);
   76|      0|    }
   77|      0|}
   78|       |
   79|      0|- (void)printImageHighlightedState {
   80|      0|    if(((UIImageView*)self).highlighted) {
   81|      0|        printf(" (highlighted)");
   82|      0|    } else {
   83|      0|        printf(" (not highlighted)");
   84|      0|    }
   85|      0|}
   86|       |
   87|      0|- (void)printControlState {
   88|      0|    UIControl* ctrl = (UIControl*)self;
   89|      0|    ctrl.enabled ? printf(" (enabled)") : printf(" (not enabled)");
   90|      0|    ctrl.selected ? printf(" (selected)") : printf(" (not selected)");
   91|      0|    ctrl.highlighted ? printf(" (highlighted)") : printf(" (not highlighted)");
   92|      0|}
   93|       |
   94|      0|- (void)printAccessibilityElementsWithIndentation:(int)indent {
   95|      0|    NSInteger numOfAccElements = self.accessibilityElementCount;
   96|      0|    if(numOfAccElements != NSNotFound) {
   97|      0|        for (NSInteger i = 0; i < numOfAccElements; ++i) {
   98|      0|            [self printIndentation:indent];
   99|      0|            UIAccessibilityElement *e = [(UIAccessibilityElement*)self accessibilityElementAtIndex:i];
  100|      0|            printf("%s, label: %s", NSStringFromClass([e class]).UTF8String, e.accessibilityLabel.UTF8String);
  101|      0|            if(e.accessibilityValue && e.accessibilityValue.length > 0) {
  102|      0|                printf(", value: %s", e.accessibilityValue.UTF8String);
  103|      0|            }
  104|      0|            if(e.accessibilityHint && e.accessibilityHint.length > 0) {
  105|      0|                printf(", hint: %s", e.accessibilityHint.UTF8String);
  106|      0|            }
  107|      0|            printf(", ");
  108|      0|            [self printAccessibilityTraits:e.accessibilityTraits];
  109|      0|            printf("\n");
  110|      0|        }
  111|      0|    }
  112|      0|}
  113|       |
  114|      0|- (void)printAccessibilityTraits:(UIAccessibilityTraits)traits {
  115|      0|    
  116|      0|    printf("traits: ");
  117|      0|    bool didPrintOne = false;
  118|      0|    if(traits == UIAccessibilityTraitNone) {
  119|      0|        printf("none");
  120|      0|        didPrintOne = true;
  121|      0|    }
  122|      0|    if(traits & UIAccessibilityTraitButton) {
  123|      0|        if(didPrintOne) printf(", ");
  124|      0|        printf("button");
  125|      0|        didPrintOne = true;
  126|      0|    }
  127|      0|    if(traits & UIAccessibilityTraitLink) {
  128|      0|        if(didPrintOne) printf(", ");
  129|      0|        printf("link");
  130|      0|        didPrintOne = true;
  131|      0|    }
  132|      0|    if(traits & UIAccessibilityTraitHeader) {
  133|      0|        if(didPrintOne) printf(", ");
  134|      0|        printf("header");
  135|      0|        didPrintOne = true;
  136|      0|    }
  137|      0|    if(traits & UIAccessibilityTraitSearchField) {
  138|      0|        if(didPrintOne) printf(", ");
  139|      0|        printf("search field");
  140|      0|        didPrintOne = true;
  141|      0|    }
  142|      0|    if(traits & UIAccessibilityTraitImage) {
  143|      0|        if(didPrintOne) printf(", ");
  144|      0|        printf("image");
  145|      0|        didPrintOne = true;
  146|      0|    }
  147|      0|    if(traits & UIAccessibilityTraitSelected) {
  148|      0|        if(didPrintOne) printf(", ");
  149|      0|        printf("selected");
  150|      0|        didPrintOne = true;
  151|      0|    }
  152|      0|    if(traits & UIAccessibilityTraitPlaysSound) {
  153|      0|        if(didPrintOne) printf(", ");
  154|      0|        printf("plays sound");
  155|      0|        didPrintOne = true;
  156|      0|    }
  157|      0|    if(traits & UIAccessibilityTraitKeyboardKey) {
  158|      0|        if(didPrintOne) printf(", ");
  159|      0|        printf("keyboard key");
  160|      0|        didPrintOne = true;
  161|      0|    }
  162|      0|    if(traits & UIAccessibilityTraitStaticText) {
  163|      0|        if(didPrintOne) printf(", ");
  164|      0|        printf("static text");
  165|      0|        didPrintOne = true;
  166|      0|    }
  167|      0|    if(traits & UIAccessibilityTraitSummaryElement) {
  168|      0|        if(didPrintOne) printf(", ");
  169|      0|        printf("summary element");
  170|      0|        didPrintOne = true;
  171|      0|    }
  172|      0|    if(traits & UIAccessibilityTraitNotEnabled) {
  173|      0|        if(didPrintOne) printf(", ");
  174|      0|        printf("not enabled");
  175|      0|        didPrintOne = true;
  176|      0|    }
  177|      0|    if(traits & UIAccessibilityTraitUpdatesFrequently) {
  178|      0|        if(didPrintOne) printf(", ");
  179|      0|        printf("updates frequently");
  180|      0|        didPrintOne = true;
  181|      0|    }
  182|      0|    if(traits & UIAccessibilityTraitStartsMediaSession) {
  183|      0|        if(didPrintOne) printf(", ");
  184|      0|        printf("starts media session");
  185|      0|        didPrintOne = true;
  186|      0|    }
  187|      0|    if(traits & UIAccessibilityTraitAdjustable) {
  188|      0|        if(didPrintOne) printf(", ");
  189|      0|        printf("adjustable");
  190|      0|        didPrintOne = true;
  191|      0|    }
  192|      0|    if(traits & UIAccessibilityTraitAllowsDirectInteraction) {
  193|      0|        if(didPrintOne) printf(", ");
  194|      0|        printf("allows direct interaction");
  195|      0|        didPrintOne = true;
  196|      0|    }
  197|      0|    if(traits & UIAccessibilityTraitCausesPageTurn) {
  198|      0|        if(didPrintOne) printf(", ");
  199|      0|        printf("causes page turn");
  200|      0|        didPrintOne = true;
  201|      0|    }
  202|      0|    if(!didPrintOne) {
  203|      0|        printf("unknown flags (0x%llx)", traits);
  204|      0|    }
  205|      0|}
  206|       |
  207|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/UIView-KIFAdditions.m:
    1|       |//
    2|       |//  UIView-KIFAdditions.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Eric Firestone on 5/20/11.
    6|       |//  Licensed to Square, Inc. under one or more contributor license agreements.
    7|       |//  See the LICENSE file distributed with this work for the terms under
    8|       |//  which Square, Inc. licenses this file to you.
    9|       |
   10|       |#import "UIView-KIFAdditions.h"
   11|       |#import "CGGeometry-KIFAdditions.h"
   12|       |#import "UIAccessibilityElement-KIFAdditions.h"
   13|       |#import "UIApplication-KIFAdditions.h"
   14|       |#import "UITouch-KIFAdditions.h"
   15|       |#import <objc/runtime.h>
   16|       |#import "UIEvent+KIFAdditions.h"
   17|       |#import "KIFUITestActor.h"
   18|       |
   19|      0|double KIFDegreesToRadians(double deg) {
   20|      0|    return (deg) / 180.0 * M_PI;
   21|      0|}
   22|       |
   23|      0|double KIFRadiansToDegrees(double rad) {
   24|      0|    return ((rad) * (180.0 / M_PI));
   25|      0|}
   26|       |
   27|       |static CGFloat const kTwoFingerConstantWidth = 40;
   28|       |
   29|       |@interface UIApplication (KIFAdditionsPrivate)
   30|       |- (UIEvent *)_touchesEvent;
   31|       |@end
   32|       |
   33|       |@interface NSObject (UIWebDocumentViewInternal)
   34|       |
   35|       |- (void)tapInteractionWithLocation:(CGPoint)point;
   36|       |
   37|       |@end
   38|       |
   39|       |// On iOS 6 the accessibility label may contain line breaks, so when trying to find the
   40|       |// element, these line breaks are necessary. But on iOS 7 the system replaces them with
   41|       |// spaces. So the same test breaks on either iOS 6 or iOS 7. iOS8 befuddles this again by
   42|       |//limiting replacement to spaces in between strings. To work around this replace
   43|       |// the line breaks in both and try again.
   44|    298|NS_INLINE BOOL StringsMatchExceptLineBreaks(NSString *expected, NSString *actual) {
   45|    298|    if (expected == actual) {
   46|      3|        return YES;
   47|      3|    }
   48|    295|    
   49|    295|    if (expected.length != actual.length) {
   50|    275|        return NO;
   51|    275|    }
   52|     20|    
   53|     20|    if ([expected isEqualToString:actual]) {
   54|      6|        return YES;
   55|      6|    }
   56|     14|    
   57|     14|    if ([expected rangeOfString:@"\n"].location == NSNotFound &&
   58|     14|        [actual rangeOfString:@"\n"].location == NSNotFound) {
   59|     14|        return NO;
   60|     14|    }
   61|      0|    
   62|      0|    for (NSUInteger i = 0; i < expected.length; i ++) {
   63|      0|        unichar expectedChar = [expected characterAtIndex:i];
   64|      0|        unichar actualChar = [actual characterAtIndex:i];
   65|      0|        if (expectedChar != actualChar &&
   66|      0|           !(expectedChar == '\n' && actualChar == ' ') &&
   67|      0|           !(expectedChar == ' '  && actualChar == '\n')) {
   68|      0|            return NO;
   69|      0|        }
   70|      0|    }
   71|      0|    
   72|      0|    return YES;
   73|      0|}
   74|       |
   75|       |
   76|       |@implementation UIView (KIFAdditions)
   77|       |
   78|       |+ (NSSet *)classesToSkipAccessibilitySearchRecursion
   79|    155|{
   80|    155|    static NSSet *classesToSkip;
   81|    155|    static dispatch_once_t onceToken;
   82|    155|    dispatch_once(&onceToken, ^{
   83|      1|        // UIDatePicker contains hundreds of thousands of placeholder accessibility elements that aren't useful to KIF,
   84|      1|        // so don't recurse into a date picker when searching for matching accessibility elements
   85|      1|        classesToSkip = [[NSSet alloc] initWithObjects:[UIDatePicker class], nil];
   86|      1|    });
   87|    155|    
   88|    155|    return classesToSkip;
   89|    155|}
   90|       |
   91|       |- (UIAccessibilityElement *)accessibilityElementWithLabel:(NSString *)label
   92|      0|{
   93|      0|    return [self accessibilityElementWithLabel:label traits:UIAccessibilityTraitNone];
   94|      0|}
   95|       |
   96|       |- (UIAccessibilityElement *)accessibilityElementWithLabel:(NSString *)label traits:(UIAccessibilityTraits)traits;
   97|      0|{
   98|      0|    return [self accessibilityElementWithLabel:label accessibilityValue:nil traits:traits];
   99|      0|}
  100|       |
  101|       |- (UIAccessibilityElement *)accessibilityElementWithLabel:(NSString *)label accessibilityValue:(NSString *)value traits:(UIAccessibilityTraits)traits;
  102|     12|{
  103|    295|    return [self accessibilityElementMatchingBlock:^(UIAccessibilityElement *element) {
  104|    295|        
  105|    295|        return [UIView accessibilityElement:element hasLabel:label accessibilityValue:value traits:traits];
  106|    295|        
  107|    295|    }];
  108|     12|}
  109|       |
  110|       |+ (BOOL)accessibilityElement:(UIAccessibilityElement *)element hasLabel:(NSString *)label accessibilityValue:(NSString *)value traits:(UIAccessibilityTraits)traits
  111|    298|{
  112|    298|    // TODO: This is a temporary fix for an SDK defect.
  113|    298|    NSString *accessibilityValue = nil;
  114|    298|    @try {
  115|    298|        accessibilityValue = element.accessibilityValue;
  116|    298|    }
  117|    298|    @catch (NSException *exception) {
  118|    298|        NSLog(@"KIF: Unable to access accessibilityValue for element %@ because of exception: %@", element, exception.reason);
  119|    298|    }
  120|    298|    
  121|    298|    if ([accessibilityValue isKindOfClass:[NSAttributedString class]]) {
  122|      0|        accessibilityValue = [(NSAttributedString *)accessibilityValue string];
  123|      0|    }
  124|    298|    
  125|    298|    BOOL labelsMatch = StringsMatchExceptLineBreaks(label, element.accessibilityLabel);
  126|    298|    BOOL traitsMatch = ((element.accessibilityTraits) & traits) == traits;
  127|    298|    BOOL valuesMatch = !value || [value isEqual:accessibilityValue];
  128|    298|    
  129|    298|    return (BOOL)(labelsMatch && traitsMatch && valuesMatch);
  130|    298|}
  131|       |
  132|       |- (UIAccessibilityElement *)accessibilityElementMatchingBlock:(BOOL(^)(UIAccessibilityElement *))matchBlock;
  133|    157|{
  134|    157|    return [self accessibilityElementMatchingBlock:matchBlock notHidden:YES];
  135|    157|}
  136|       |
  137|       |- (UIAccessibilityElement *)accessibilityElementMatchingBlock:(BOOL(^)(UIAccessibilityElement *))matchBlock notHidden:(BOOL)notHidden;
  138|    157|{
  139|    157|    if (notHidden && self.hidden) {
  140|      0|        return nil;
  141|      0|    }
  142|    157|    
  143|    157|    // In case multiple elements with the same label exist, prefer ones that are currently visible
  144|    157|    UIAccessibilityElement *matchingButOccludedElement = nil;
  145|    157|    
  146|    157|    BOOL elementMatches = matchBlock((UIAccessibilityElement *)self);
  147|    157|
  148|    157|    if (elementMatches) {
  149|      3|        if (self.isTappable) {
  150|      2|            return (UIAccessibilityElement *)self;
  151|      2|        } else {
  152|      1|            matchingButOccludedElement = (UIAccessibilityElement *)self;
  153|      1|        }
  154|      3|    }
  155|    157|    
  156|    157|    if ([[[self class] classesToSkipAccessibilitySearchRecursion] containsObject:[self class]]) {
  157|      0|        return matchingButOccludedElement;
  158|      0|    }
  159|    155|    
  160|    155|    // Check the subviews first. Even if the receiver says it's an accessibility container,
  161|    155|    // the returned objects are UIAccessibilityElementMockViews (which aren't actually views)
  162|    155|    // rather than the real subviews it contains. We want the real views if possible.
  163|    155|    // UITableViewCell is such an offender.
  164|    155|    for (UIView *view in [self.subviews reverseObjectEnumerator]) {
  165|    145|        UIAccessibilityElement *element = [view accessibilityElementMatchingBlock:matchBlock];
  166|    145|        if (!element) {
  167|    118|            continue;
  168|    118|        }
  169|     27|        
  170|     27|        UIView *viewForElement = [UIAccessibilityElement viewContainingAccessibilityElement:element];
  171|     27|        CGRect accessibilityFrame = [viewForElement.window convertRect:element.accessibilityFrame toView:viewForElement];
  172|     27|        
  173|     27|        if ([viewForElement isTappableInRect:accessibilityFrame]) {
  174|     20|            return element;
  175|     20|        } else {
  176|      7|            matchingButOccludedElement = element;
  177|      7|        }
  178|     27|    }
  179|    155|    
  180|    155|    NSMutableArray *elementStack = [NSMutableArray arrayWithObject:self];
  181|    135|    
  182|    273|    while (elementStack.count) {
  183|    138|        UIAccessibilityElement *element = [elementStack lastObject];
  184|    138|        [elementStack removeLastObject];
  185|    138|        
  186|    138|        BOOL elementMatches = matchBlock(element);
  187|    138|
  188|    138|        if (elementMatches) {
  189|      1|            UIView *viewForElement = [UIAccessibilityElement viewContainingAccessibilityElement:element];
  190|      1|            CGRect accessibilityFrame = [viewForElement.window convertRect:element.accessibilityFrame toView:viewForElement];
  191|      1|
  192|      1|            if ([viewForElement isTappableInRect:accessibilityFrame]) {
  193|      0|                return element;
  194|      1|            } else {
  195|      1|                matchingButOccludedElement = element;
  196|      1|                continue;
  197|      1|            }
  198|    137|        }
  199|    137|
  200|    137|        // Avoid crash within accessibilityElementCount while traversing map subviews
  201|    137|        // See https://github.com/kif-framework/KIF/issues/802
  202|    137|        if ([element isKindOfClass:NSClassFromString(@"MKBasicMapView")]) {
  203|      0|            continue;
  204|      0|        }
  205|    137|
  206|    137|        // If the view is an accessibility container, and we didn't find a matching subview,
  207|    137|        // then check the actual accessibility elements
  208|    137|        NSInteger accessibilityElementCount = element.accessibilityElementCount;
  209|    137|        if (accessibilityElementCount == 0 || accessibilityElementCount == NSNotFound) {
  210|    134|            continue;
  211|    134|        }
  212|      3|        
  213|      6|        for (NSInteger accessibilityElementIndex = 0; accessibilityElementIndex < accessibilityElementCount; accessibilityElementIndex++) {
  214|      3|            UIAccessibilityElement *subelement = [element accessibilityElementAtIndex:accessibilityElementIndex];
  215|      3|            
  216|      3|            if (subelement) {
  217|      3|                // Skip table view cell accessibility elements, they're handled below
  218|      3|                if ([subelement isKindOfClass:NSClassFromString(@"UITableViewCellAccessibilityElement")]) {
  219|      0|                    continue;
  220|      0|                }
  221|      3|                
  222|      3|                [elementStack addObject:subelement];
  223|      3|            }
  224|      3|        }
  225|      3|    }
  226|    135|    
  227|    135|    if (!matchingButOccludedElement && self.window) {
  228|    118|        CGPoint scrollContentOffset = {-1.0, -1.0};
  229|    118|        UIScrollView *scrollView = nil;
  230|    118|        if ([self isKindOfClass:[UITableView class]]) {
  231|      0|            NSString * subViewName = nil;
  232|      0|            //special case for UIPickerView (which has a private class UIPickerTableView)
  233|      0|            for (UIView *view in [self subviews])
  234|      0|            {
  235|      0|                subViewName = [NSString stringWithFormat:@"%@", [view class]];
  236|      0|                if ([subViewName containsString:@"UIPicker"] )
  237|      0|                {
  238|      0|                    scrollView = (UIScrollView*)self;
  239|      0|                    scrollContentOffset = [scrollView contentOffset];
  240|      0|                    break;
  241|      0|                }
  242|      0|            }
  243|      0|
  244|      0|            UITableView *tableView = (UITableView *)self;
  245|      0|            __block NSIndexPath *firstIndexPath = nil;
  246|      0|
  247|      0|            // Because of a bug in [UITableView indexPathsForVisibleRows] http://openradar.appspot.com/radar?id=5191284490764288
  248|      0|            // We use [UITableView visibleCells] to determine the index path of the visible cells
  249|      0|            NSMutableArray *indexPathsForVisibleRows = [[NSMutableArray alloc] init];
  250|      0|            [[tableView visibleCells] enumerateObjectsUsingBlock:^(UITableViewCell *cell, NSUInteger idx, BOOL *stop) {
  251|      0|                NSIndexPath *indexPath = [tableView indexPathForCell:cell];
  252|      0|                if (indexPath) {
  253|      0|                    [indexPathsForVisibleRows addObject:indexPath];
  254|      0|                }
  255|      0|                if (!firstIndexPath || ([firstIndexPath compare:indexPath] == NSOrderedDescending)) {
  256|      0|                    firstIndexPath = indexPath;
  257|      0|                }
  258|      0|            }];
  259|      0|
  260|      0|            BOOL animationEnabled = [KIFUITestActor testActorAnimationsEnabled];
  261|      0|            CFTimeInterval delay = animationEnabled ? 0.5 : 0.05;
  262|      0|            for (NSUInteger section = 0, numberOfSections = [tableView numberOfSections]; section < numberOfSections; section++) {
  263|      0|                for (NSUInteger row = 0, numberOfRows = [tableView numberOfRowsInSection:section]; row < numberOfRows; row++) {
  264|      0|                    if (!self.window) {
  265|      0|                        break;
  266|      0|                    }
  267|      0|
  268|      0|                    // Skip visible rows because they are already handled.
  269|      0|                    NSIndexPath *indexPath = [NSIndexPath indexPathForRow:row inSection:section];
  270|      0|                    if ([indexPathsForVisibleRows containsObject:indexPath]) {
  271|      0|                        @autoreleasepool {
  272|      0|                            //scroll to the last row of each section before continuing. Attemps to ensure we can get to sections that are off screen. KIF tests (e.g. testButtonAbsentAfterRemoveFromSuperview) fails without this line. Also without this... we can't expose the next section (in code downstream)
  273|      0|                            [tableView scrollToRowAtIndexPath:[indexPathsForVisibleRows lastObject] atScrollPosition:UITableViewScrollPositionNone animated:animationEnabled];
  274|      0|                            continue;
  275|      0|                        }
  276|      0|                    }
  277|      0|
  278|      0|                    //expose the next section (unless it's a UIPicker View).
  279|      0|                    if (subViewName && ![subViewName containsString:@"UIPicker"] )
  280|      0|                    {
  281|      0|                        CGRect sectionRect = [tableView rectForSection:section];
  282|      0|                        [tableView scrollRectToVisible:sectionRect animated:NO];
  283|      0|                    }
  284|      0|
  285|      0|                    @autoreleasepool {
  286|      0|                        // Scroll to the cell and wait for the animation to complete. Using animations here may not be optimal.
  287|      0|                        [tableView scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionNone animated:animationEnabled];
  288|      0|
  289|      0|                        UITableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath];
  290|      0|                        UIAccessibilityElement *element = [cell accessibilityElementMatchingBlock:matchBlock notHidden:NO];
  291|      0|
  292|      0|                        // Skip this cell if it isn't the one we're looking for
  293|      0|                        if (!element) {
  294|      0|                            continue;
  295|      0|                        }
  296|      0|                    }
  297|      0|
  298|      0|                    // Note: using KIFRunLoopRunInModeRelativeToAnimationSpeed here may cause tests to stall
  299|      0|                    CFRunLoopRunInMode(UIApplicationCurrentRunMode, delay, false);
  300|      0|                    return [self accessibilityElementMatchingBlock:matchBlock];
  301|      0|                }
  302|      0|            }
  303|      0|            if (firstIndexPath) {
  304|      0|                [tableView scrollToRowAtIndexPath:firstIndexPath atScrollPosition:UITableViewScrollPositionTop animated:NO];
  305|      0|            }
  306|      0|			//if we're in a picker (scrollView), let's make sure we set the position back to how it was last set.
  307|      0|            if(scrollView != nil && scrollContentOffset.x != -1.0)
  308|      0|            {
  309|      0|                [scrollView setContentOffset:scrollContentOffset];
  310|      0|            }
  311|      0|            CFRunLoopRunInMode(UIApplicationCurrentRunMode, delay, false);
  312|    118|        } else if ([self isKindOfClass:[UICollectionView class]]) {
  313|      0|            UICollectionView *collectionView = (UICollectionView *)self;
  314|      0|            
  315|      0|            NSArray *indexPathsForVisibleItems = [collectionView indexPathsForVisibleItems];
  316|      0|            
  317|      0|            for (NSUInteger section = 0, numberOfSections = [collectionView numberOfSections]; section < numberOfSections; section++) {
  318|      0|                for (NSUInteger item = 0, numberOfItems = [collectionView numberOfItemsInSection:section]; item < numberOfItems; item++) {
  319|      0|                    if (!self.window) {
  320|      0|                        break;
  321|      0|                    }
  322|      0|
  323|      0|                    // Skip visible items because they are already handled
  324|      0|                    NSIndexPath *indexPath = [NSIndexPath indexPathForItem:item inSection:section];
  325|      0|                    if ([indexPathsForVisibleItems containsObject:indexPath]) {
  326|      0|                        continue;
  327|      0|                    }
  328|      0|                    
  329|      0|                    @autoreleasepool {
  330|      0|                        // Get the cell directly from the dataSource because UICollectionView will only vend visible cells
  331|      0|                        UICollectionViewCell *cell = [collectionView.dataSource collectionView:collectionView cellForItemAtIndexPath:indexPath];
  332|      0|                        
  333|      0|                        UIAccessibilityElement *element = [cell accessibilityElementMatchingBlock:matchBlock notHidden:NO];
  334|      0|                        
  335|      0|                        // Remove the cell from the collection view so that it doesn't stick around
  336|      0|                        [cell removeFromSuperview];
  337|      0|                        
  338|      0|                        // Skip this cell if it isn't the one we're looking for
  339|      0|                        // Sometimes we get cells with no size here which can cause an endless loop, so we ignore those
  340|      0|                        if (!element || CGSizeEqualToSize(cell.frame.size, CGSizeZero)) {
  341|      0|                            continue;
  342|      0|                        }
  343|      0|                    }
  344|      0|                    
  345|      0|                    // Scroll to the cell and wait for the animation to complete
  346|      0|                    CGRect frame = [collectionView.collectionViewLayout layoutAttributesForItemAtIndexPath:indexPath].frame;
  347|      0|                    [collectionView scrollRectToVisible:frame animated:YES];
  348|      0|                    // Note: using KIFRunLoopRunInModeRelativeToAnimationSpeed here may cause tests to stall
  349|      0|                    CFRunLoopRunInMode(UIApplicationCurrentRunMode, 0.5, false);
  350|      0|                    
  351|      0|                    // Now try finding the element again
  352|      0|                    return [self accessibilityElementMatchingBlock:matchBlock];
  353|      0|                }
  354|      0|            }
  355|      0|        }
  356|    118|    }
  357|    135|    
  358|    135|    return matchingButOccludedElement;
  359|    135|}
  360|       |
  361|       |- (UIView *)subviewWithClassNamePrefix:(NSString *)prefix;
  362|      0|{
  363|      0|    NSArray *subviews = [self subviewsWithClassNamePrefix:prefix];
  364|      0|    if ([subviews count] == 0) {
  365|      0|        return nil;
  366|      0|    }
  367|      0|    
  368|      0|    return subviews[0];
  369|      0|}
  370|       |
  371|       |- (NSArray *)subviewsWithClassNamePrefix:(NSString *)prefix;
  372|      0|{
  373|      0|    NSMutableArray *result = [NSMutableArray array];
  374|      0|    
  375|      0|    // Breadth-first population of matching subviews
  376|      0|    // First traverse the next level of subviews, adding matches.
  377|      0|    for (UIView *view in self.subviews) {
  378|      0|        if ([NSStringFromClass([view class]) hasPrefix:prefix]) {
  379|      0|            [result addObject:view];
  380|      0|        }
  381|      0|    }
  382|      0|    
  383|      0|    // Now traverse the subviews of the subviews, adding matches.
  384|      0|    for (UIView *view in self.subviews) {
  385|      0|        NSArray *matchingSubviews = [view subviewsWithClassNamePrefix:prefix];
  386|      0|        [result addObjectsFromArray:matchingSubviews];
  387|      0|    }
  388|      0|
  389|      0|    return result;
  390|      0|}
  391|       |
  392|       |- (UIView *)subviewWithClassNameOrSuperClassNamePrefix:(NSString *)prefix;
  393|      0|{
  394|      0|    NSArray *subviews = [self subviewsWithClassNameOrSuperClassNamePrefix:prefix];
  395|      0|    if ([subviews count] == 0) {
  396|      0|        return nil;
  397|      0|    }
  398|      0|    
  399|      0|    return subviews[0];
  400|      0|}
  401|       |
  402|       |- (NSArray *)subviewsWithClassNameOrSuperClassNamePrefix:(NSString *)prefix;
  403|      0|{
  404|      0|    NSMutableArray * result = [NSMutableArray array];
  405|      0|    
  406|      0|    // Breadth-first population of matching subviews
  407|      0|    // First traverse the next level of subviews, adding matches
  408|      0|    for (UIView *view in self.subviews) {
  409|      0|        Class klass = [view class];
  410|      0|        while (klass) {
  411|      0|            if ([NSStringFromClass(klass) hasPrefix:prefix]) {
  412|      0|                [result addObject:view];
  413|      0|                break;
  414|      0|            }
  415|      0|            
  416|      0|            klass = [klass superclass];
  417|      0|        }
  418|      0|    }
  419|      0|    
  420|      0|    // Now traverse the subviews of the subviews, adding matches
  421|      0|    for (UIView *view in self.subviews) {
  422|      0|        NSArray * matchingSubviews = [view subviewsWithClassNameOrSuperClassNamePrefix:prefix];
  423|      0|        [result addObjectsFromArray:matchingSubviews];
  424|      0|    }
  425|      0|
  426|      0|    return result;
  427|      0|}
  428|       |
  429|       |
  430|       |- (BOOL)isDescendantOfFirstResponder;
  431|      0|{
  432|      0|    if ([self isFirstResponder]) {
  433|      0|        return YES;
  434|      0|    }
  435|      0|    return [self.superview isDescendantOfFirstResponder];
  436|      0|}
  437|       |
  438|       |- (void)flash;
  439|      0|{
  440|      0|	UIColor *originalBackgroundColor = self.backgroundColor;
  441|      0|    for (NSUInteger i = 0; i < 5; i++) {
  442|      0|        self.backgroundColor = [UIColor yellowColor];
  443|      0|        CFRunLoopRunInMode(kCFRunLoopDefaultMode, .05, false);
  444|      0|        self.backgroundColor = [UIColor blueColor];
  445|      0|        CFRunLoopRunInMode(kCFRunLoopDefaultMode, .05, false);
  446|      0|    }
  447|      0|    self.backgroundColor = originalBackgroundColor;
  448|      0|}
  449|       |
  450|       |- (void)tap;
  451|      0|{
  452|      0|    CGPoint centerPoint = CGPointMake(self.frame.size.width * 0.5f, self.frame.size.height * 0.5f);
  453|      0|    
  454|      0|    [self tapAtPoint:centerPoint];
  455|      0|}
  456|       |
  457|       |- (void)tapAtPoint:(CGPoint)point;
  458|      0|{
  459|      0|    // Web views don't handle touches in a normal fashion, but they do have a method we can call to tap them
  460|      0|    // This may not be necessary anymore. We didn't properly support controls that used gesture recognizers
  461|      0|    // when this was added, but we now do. It needs to be tested before we can get rid of it.
  462|      0|    id /*UIWebBrowserView*/ webBrowserView = nil;
  463|      0|    
  464|      0|    if ([NSStringFromClass([self class]) isEqual:@"UIWebBrowserView"]) {
  465|      0|        webBrowserView = self;
  466|      0|    } else if ([self isKindOfClass:[UIWebView class]]) {
  467|      0|        id webViewInternal = [self valueForKey:@"_internal"];
  468|      0|        webBrowserView = [webViewInternal valueForKey:@"browserView"];
  469|      0|    }
  470|      0|    
  471|      0|    if (webBrowserView) {
  472|      0|        [webBrowserView tapInteractionWithLocation:point];
  473|      0|        return;
  474|      0|    }
  475|      0|    
  476|      0|    // Handle touches in the normal way for other views
  477|      0|    UITouch *touch = [[UITouch alloc] initAtPoint:point inView:self];
  478|      0|    [touch setPhaseAndUpdateTimestamp:UITouchPhaseBegan];
  479|      0|    
  480|      0|    UIEvent *event = [self eventWithTouch:touch];
  481|      0|
  482|      0|    [[UIApplication sharedApplication] sendEvent:event];
  483|      0|    
  484|      0|    [touch setPhaseAndUpdateTimestamp:UITouchPhaseEnded];
  485|      0|    [[UIApplication sharedApplication] sendEvent:event];
  486|      0|
  487|      0|    // Dispatching the event doesn't actually update the first responder, so fake it
  488|      0|    if ([touch.view isDescendantOfView:self] && [self canBecomeFirstResponder]) {
  489|      0|        [self becomeFirstResponder];
  490|      0|    }
  491|      0|
  492|      0|}
  493|       |
  494|      0|- (void)twoFingerTapAtPoint:(CGPoint)point {
  495|      0|    CGPoint finger1 = CGPointMake(point.x - kTwoFingerConstantWidth, point.y - kTwoFingerConstantWidth);
  496|      0|    CGPoint finger2 = CGPointMake(point.x + kTwoFingerConstantWidth, point.y + kTwoFingerConstantWidth);
  497|      0|    UITouch *touch1 = [[UITouch alloc] initAtPoint:finger1 inView:self];
  498|      0|    UITouch *touch2 = [[UITouch alloc] initAtPoint:finger2 inView:self];
  499|      0|    [touch1 setPhaseAndUpdateTimestamp:UITouchPhaseBegan];
  500|      0|    [touch2 setPhaseAndUpdateTimestamp:UITouchPhaseBegan];
  501|      0|
  502|      0|    UIEvent *event = [self eventWithTouches:@[touch1, touch2]];
  503|      0|    [[UIApplication sharedApplication] sendEvent:event];
  504|      0|
  505|      0|    [touch1 setPhaseAndUpdateTimestamp:UITouchPhaseEnded];
  506|      0|    [touch2 setPhaseAndUpdateTimestamp:UITouchPhaseEnded];
  507|      0|
  508|      0|    [[UIApplication sharedApplication] sendEvent:event];
  509|      0|}
  510|       |
  511|      0|#define DRAG_TOUCH_DELAY 0.01
  512|       |
  513|       |- (void)longPressAtPoint:(CGPoint)point duration:(NSTimeInterval)duration
  514|      0|{
  515|      0|    UITouch *touch = [[UITouch alloc] initAtPoint:point inView:self];
  516|      0|    [touch setPhaseAndUpdateTimestamp:UITouchPhaseBegan];
  517|      0|    
  518|      0|    UIEvent *eventDown = [self eventWithTouch:touch];
  519|      0|    [[UIApplication sharedApplication] sendEvent:eventDown];
  520|      0|    
  521|      0|    CFRunLoopRunInMode(kCFRunLoopDefaultMode, DRAG_TOUCH_DELAY, false);
  522|      0|    
  523|      0|    for (NSTimeInterval timeSpent = DRAG_TOUCH_DELAY; timeSpent < duration; timeSpent += DRAG_TOUCH_DELAY)
  524|      0|    {
  525|      0|        [touch setPhaseAndUpdateTimestamp:UITouchPhaseStationary];
  526|      0|        
  527|      0|        UIEvent *eventStillDown = [self eventWithTouch:touch];
  528|      0|        [[UIApplication sharedApplication] sendEvent:eventStillDown];
  529|      0|        
  530|      0|        CFRunLoopRunInMode(kCFRunLoopDefaultMode, DRAG_TOUCH_DELAY, false);
  531|      0|    }
  532|      0|    
  533|      0|    [touch setPhaseAndUpdateTimestamp:UITouchPhaseEnded];
  534|      0|    UIEvent *eventUp = [self eventWithTouch:touch];
  535|      0|    [[UIApplication sharedApplication] sendEvent:eventUp];
  536|      0|    
  537|      0|    // Dispatching the event doesn't actually update the first responder, so fake it
  538|      0|    if ([touch.view isDescendantOfView:self] && [self canBecomeFirstResponder]) {
  539|      0|        [self becomeFirstResponder];
  540|      0|    }
  541|      0|    
  542|      0|}
  543|       |
  544|       |- (void)dragFromPoint:(CGPoint)startPoint toPoint:(CGPoint)endPoint;
  545|      0|{
  546|      0|    [self dragFromPoint:startPoint toPoint:endPoint steps:3];
  547|      0|}
  548|       |
  549|       |
  550|       |- (void)dragFromPoint:(CGPoint)startPoint toPoint:(CGPoint)endPoint steps:(NSUInteger)stepCount;
  551|      0|{
  552|      0|    KIFDisplacement displacement = CGPointMake(endPoint.x - startPoint.x, endPoint.y - startPoint.y);
  553|      0|    [self dragFromPoint:startPoint displacement:displacement steps:stepCount];
  554|      0|}
  555|       |
  556|       |- (void)dragFromPoint:(CGPoint)startPoint displacement:(KIFDisplacement)displacement steps:(NSUInteger)stepCount;
  557|      0|{
  558|      0|    CGPoint endPoint = CGPointMake(startPoint.x + displacement.x, startPoint.y + displacement.y);
  559|      0|    NSArray *path = [self pointsFromStartPoint:startPoint toPoint:endPoint steps:stepCount];
  560|      0|    [self dragPointsAlongPaths:@[path]];
  561|      0|}
  562|       |
  563|       |- (void)dragAlongPathWithPoints:(CGPoint *)points count:(NSInteger)count;
  564|      0|{
  565|      0|    // convert point array into NSArray with NSValue
  566|      0|    NSMutableArray *array = [NSMutableArray array];
  567|      0|    for (int i = 0; i < count; i++)
  568|      0|    {
  569|      0|        [array addObject:[NSValue valueWithCGPoint:points[i]]];
  570|      0|    }
  571|      0|    [self dragPointsAlongPaths:@[[array copy]]];
  572|      0|}
  573|       |
  574|      0|- (void)dragPointsAlongPaths:(NSArray *)arrayOfPaths {
  575|      0|    // must have at least one path, and each path must have the same number of points
  576|      0|    if (arrayOfPaths.count == 0)
  577|      0|    {
  578|      0|        return;
  579|      0|    }
  580|      0|
  581|      0|    // all paths must have similar number of points
  582|      0|    NSUInteger pointsInPath = [arrayOfPaths[0] count];
  583|      0|    for (NSArray *path in arrayOfPaths)
  584|      0|    {
  585|      0|        if (path.count != pointsInPath)
  586|      0|        {
  587|      0|            return;
  588|      0|        }
  589|      0|    }
  590|      0|
  591|      0|    NSMutableArray *touches = [NSMutableArray array];
  592|      0|    
  593|      0|    // Convert paths to be in window coordinates before we start, because the view may
  594|      0|    // move relative to the window.
  595|      0|    NSMutableArray *newPaths = [[NSMutableArray alloc] init];
  596|      0|    
  597|      0|    for (NSArray * path in arrayOfPaths) {
  598|      0|        NSMutableArray *newPath = [[NSMutableArray alloc] init];
  599|      0|        for (NSValue *pointValue in path) {
  600|      0|            CGPoint point = [pointValue CGPointValue];
  601|      0|            [newPath addObject:[NSValue valueWithCGPoint:[self.window convertPoint:point fromView:self]]];
  602|      0|        }
  603|      0|        [newPaths addObject:newPath];
  604|      0|    }
  605|      0|    
  606|      0|    arrayOfPaths = newPaths;
  607|      0|
  608|      0|    for (NSUInteger pointIndex = 0; pointIndex < pointsInPath; pointIndex++) {
  609|      0|        // create initial touch event and send touch down event
  610|      0|        if (pointIndex == 0)
  611|      0|        {
  612|      0|            for (NSArray *path in arrayOfPaths)
  613|      0|            {
  614|      0|                CGPoint point = [path[pointIndex] CGPointValue];
  615|      0|                // The starting point needs to be relative to the view receiving the UITouch event.
  616|      0|                point = [self convertPoint:point fromView:self.window];
  617|      0|                UITouch *touch = [[UITouch alloc] initAtPoint:point inView:self];
  618|      0|                [touch setPhaseAndUpdateTimestamp:UITouchPhaseBegan];
  619|      0|                [touches addObject:touch];
  620|      0|            }
  621|      0|            UIEvent *eventDown = [self eventWithTouches:[NSArray arrayWithArray:touches]];
  622|      0|            [[UIApplication sharedApplication] sendEvent:eventDown];
  623|      0|            
  624|      0|            CFRunLoopRunInMode(UIApplicationCurrentRunMode, DRAG_TOUCH_DELAY, false);
  625|      0|        }
  626|      0|        else
  627|      0|        {
  628|      0|            UITouch *touch;
  629|      0|            for (NSUInteger pathIndex = 0; pathIndex < arrayOfPaths.count; pathIndex++)
  630|      0|            {
  631|      0|                NSArray *path = arrayOfPaths[pathIndex];
  632|      0|                CGPoint point = [path[pointIndex] CGPointValue];
  633|      0|                touch = touches[pathIndex];
  634|      0|                [touch setLocationInWindow:point];
  635|      0|                [touch setPhaseAndUpdateTimestamp:UITouchPhaseMoved];
  636|      0|            }
  637|      0|            UIEvent *event = [self eventWithTouches:[NSArray arrayWithArray:touches]];
  638|      0|            [[UIApplication sharedApplication] sendEvent:event];
  639|      0|
  640|      0|            CFRunLoopRunInMode(UIApplicationCurrentRunMode, DRAG_TOUCH_DELAY, false);
  641|      0|
  642|      0|            // The last point needs to also send a phase ended touch.
  643|      0|            if (pointIndex == pointsInPath - 1) {
  644|      0|                for (UITouch * touch in touches) {
  645|      0|                    [touch setPhaseAndUpdateTimestamp:UITouchPhaseEnded];
  646|      0|                    UIEvent *eventUp = [self eventWithTouch:touch];
  647|      0|                    [[UIApplication sharedApplication] sendEvent:eventUp];
  648|      0|                    
  649|      0|                }
  650|      0|
  651|      0|            }
  652|      0|        }
  653|      0|    }
  654|      0|
  655|      0|    // Dispatching the event doesn't actually update the first responder, so fake it
  656|      0|    if ([touches[0] view] == self && [self canBecomeFirstResponder]) {
  657|      0|        [self becomeFirstResponder];
  658|      0|    }
  659|      0|
  660|      0|    while (UIApplicationCurrentRunMode != kCFRunLoopDefaultMode) {
  661|      0|        CFRunLoopRunInMode(UIApplicationCurrentRunMode, 0.1, false);
  662|      0|    }
  663|      0|}
  664|       |
  665|      0|- (void)twoFingerPanFromPoint:(CGPoint)startPoint toPoint:(CGPoint)toPoint steps:(NSUInteger)stepCount {
  666|      0|    //estimate the first finger to be diagonally up and left from the center
  667|      0|    CGPoint finger1Start = CGPointMake(startPoint.x - kTwoFingerConstantWidth,
  668|      0|                                       startPoint.y - kTwoFingerConstantWidth);
  669|      0|    CGPoint finger1End = CGPointMake(toPoint.x - kTwoFingerConstantWidth,
  670|      0|                                     toPoint.y - kTwoFingerConstantWidth);
  671|      0|    //estimate the second finger to be diagonally down and right from the center
  672|      0|    CGPoint finger2Start = CGPointMake(startPoint.x + kTwoFingerConstantWidth,
  673|      0|                                       startPoint.y + kTwoFingerConstantWidth);
  674|      0|    CGPoint finger2End = CGPointMake(toPoint.x + kTwoFingerConstantWidth,
  675|      0|                                     toPoint.y + kTwoFingerConstantWidth);
  676|      0|    NSArray *finger1Path = [self pointsFromStartPoint:finger1Start toPoint:finger1End steps:stepCount];
  677|      0|    NSArray *finger2Path = [self pointsFromStartPoint:finger2Start toPoint:finger2End steps:stepCount];
  678|      0|    NSArray *paths = @[finger1Path, finger2Path];
  679|      0|
  680|      0|    [self dragPointsAlongPaths:paths];
  681|      0|}
  682|       |
  683|      0|- (void)pinchAtPoint:(CGPoint)centerPoint distance:(CGFloat)distance steps:(NSUInteger)stepCount {
  684|      0|    //estimate the first finger to be on the left
  685|      0|    CGPoint finger1Start = CGPointMake(centerPoint.x - kTwoFingerConstantWidth - distance, centerPoint.y);
  686|      0|    CGPoint finger1End = CGPointMake(centerPoint.x - kTwoFingerConstantWidth, centerPoint.y);
  687|      0|    //estimate the second finger to be on the right
  688|      0|    CGPoint finger2Start = CGPointMake(centerPoint.x + kTwoFingerConstantWidth + distance, centerPoint.y);
  689|      0|    CGPoint finger2End = CGPointMake(centerPoint.x + kTwoFingerConstantWidth, centerPoint.y);
  690|      0|    NSArray *finger1Path = [self pointsFromStartPoint:finger1Start toPoint:finger1End steps:stepCount];
  691|      0|    NSArray *finger2Path = [self pointsFromStartPoint:finger2Start toPoint:finger2End steps:stepCount];
  692|      0|    NSArray *paths = @[finger1Path, finger2Path];
  693|      0|
  694|      0|    [self dragPointsAlongPaths:paths];
  695|      0|}
  696|       |
  697|      0|- (void)zoomAtPoint:(CGPoint)centerPoint distance:(CGFloat)distance steps:(NSUInteger)stepCount {
  698|      0|    //estimate the first finger to be on the left
  699|      0|    CGPoint finger1Start = CGPointMake(centerPoint.x - kTwoFingerConstantWidth, centerPoint.y);
  700|      0|    CGPoint finger1End = CGPointMake(centerPoint.x - kTwoFingerConstantWidth - distance, centerPoint.y);
  701|      0|    //estimate the second finger to be on the right
  702|      0|    CGPoint finger2Start = CGPointMake(centerPoint.x + kTwoFingerConstantWidth, centerPoint.y);
  703|      0|    CGPoint finger2End = CGPointMake(centerPoint.x + kTwoFingerConstantWidth + distance, centerPoint.y);
  704|      0|    NSArray *finger1Path = [self pointsFromStartPoint:finger1Start toPoint:finger1End steps:stepCount];
  705|      0|    NSArray *finger2Path = [self pointsFromStartPoint:finger2Start toPoint:finger2End steps:stepCount];
  706|      0|    NSArray *paths = @[finger1Path, finger2Path];
  707|      0|
  708|      0|    [self dragPointsAlongPaths:paths];
  709|      0|}
  710|       |
  711|      0|- (void)twoFingerRotateAtPoint:(CGPoint)centerPoint angle:(CGFloat)angleInDegrees {
  712|      0|    NSInteger stepCount = ABS(angleInDegrees)/2; // very rough approximation. 90deg = ~45 steps, 360 deg = ~180 steps
  713|      0|    CGFloat radius = kTwoFingerConstantWidth*2;
  714|      0|    double angleInRadians = KIFDegreesToRadians(angleInDegrees);
  715|      0|
  716|      0|    NSMutableArray *finger1Path = [NSMutableArray array];
  717|      0|    NSMutableArray *finger2Path = [NSMutableArray array];
  718|      0|    for (NSUInteger i = 0; i < stepCount; i++) {
  719|      0|        double currentAngle = 0;
  720|      0|        if (i == stepCount - 1) {
  721|      0|            currentAngle = angleInRadians; // do not interpolate for the last step for maximum accuracy
  722|      0|        }
  723|      0|        else {
  724|      0|            double interpolation = i/(double)stepCount;
  725|      0|            currentAngle = interpolation * angleInRadians;
  726|      0|        }
  727|      0|        // interpolate betwen 0 and the target rotation
  728|      0|        CGPoint offset1 = CGPointMake(radius * cos(currentAngle), radius * sin(currentAngle));
  729|      0|        CGPoint offset2 = CGPointMake(-offset1.x, -offset1.y); // second finger is just opposite of the first
  730|      0|
  731|      0|        CGPoint finger1 = CGPointMake(centerPoint.x + offset1.x, centerPoint.y + offset1.y);
  732|      0|        CGPoint finger2 = CGPointMake(centerPoint.x + offset2.x, centerPoint.y + offset2.y);
  733|      0|
  734|      0|        [finger1Path addObject:[NSValue valueWithCGPoint:finger1]];
  735|      0|        [finger2Path addObject:[NSValue valueWithCGPoint:finger2]];
  736|      0|    }
  737|      0|    [self dragPointsAlongPaths:@[[finger1Path copy], [finger2Path copy]]];
  738|      0|}
  739|       |
  740|      0|- (NSArray *)pointsFromStartPoint:(CGPoint)startPoint toPoint:(CGPoint)toPoint steps:(NSUInteger)stepCount {
  741|      0|
  742|      0|    CGPoint displacement = CGPointMake(toPoint.x - startPoint.x, toPoint.y - startPoint.y);
  743|      0|    NSMutableArray *points = [NSMutableArray array];
  744|      0|
  745|      0|    for (NSUInteger i = 0; i < stepCount; i++) {
  746|      0|        CGFloat progress = ((CGFloat)i)/(stepCount - 1);
  747|      0|        CGPoint point = CGPointMake(startPoint.x + (progress * displacement.x),
  748|      0|                                    startPoint.y + (progress * displacement.y));
  749|      0|        [points addObject:[NSValue valueWithCGPoint:point]];
  750|      0|    }
  751|      0|    return [NSArray arrayWithArray:points];
  752|      0|}
  753|       |
  754|       |- (BOOL)isProbablyTappable
  755|      0|{
  756|      0|    // There are some issues with the tappability check in UIWebViews, so if the view is a UIWebView we will just skip the check.
  757|      0|    return [NSStringFromClass([self class]) isEqualToString:@"UIWebBrowserView"] || self.isTappable;
  758|      0|}
  759|       |
  760|       |// Is this view currently on screen?
  761|       |- (BOOL)isTappable;
  762|      3|{
  763|      3|    return ([self hasTapGestureRecognizer] ||
  764|      3|            [self isTappableInRect:self.bounds]);
  765|      3|}
  766|       |
  767|       |- (BOOL)hasTapGestureRecognizer
  768|      3|{
  769|      3|    __block BOOL hasTapGestureRecognizer = NO;
  770|      3|    
  771|      3|    [self.gestureRecognizers enumerateObjectsUsingBlock:^(id obj,
  772|      3|                                                          NSUInteger idx,
  773|      3|                                                          BOOL *stop) {
  774|      0|        if ([obj isKindOfClass:[UITapGestureRecognizer class]]) {
  775|      0|            hasTapGestureRecognizer = YES;
  776|      0|            
  777|      0|            if (stop != NULL) {
  778|      0|                *stop = YES;
  779|      0|            }
  780|      0|        }
  781|      0|    }];
  782|      3|    
  783|      3|    return hasTapGestureRecognizer;
  784|      3|}
  785|       |
  786|       |- (BOOL)isTappableInRect:(CGRect)rect;
  787|     31|{
  788|     31|    CGPoint tappablePoint = [self tappablePointInRect:rect];
  789|     31|    
  790|     31|    return !isnan(tappablePoint.x);
  791|     31|}
  792|       |
  793|       |- (BOOL)isTappableWithHitTestResultView:(UIView *)hitView;
  794|     67|{
  795|     67|    // Special case for UIControls, which may have subviews which don't respond to -hitTest:,
  796|     67|    // but which are tappable. In this case the hit view will be the containing
  797|     67|    // UIControl, and it will forward the tap to the appropriate subview.
  798|     67|    // This applies with UISegmentedControl which contains UISegment views (a private UIView
  799|     67|    // representing a single segment).
  800|     67|    if ([hitView isKindOfClass:[UIControl class]] && [self isDescendantOfView:hitView]) {
  801|     22|        return YES;
  802|     22|    }
  803|     45|    
  804|     45|    // Button views in the nav bar (a private class derived from UINavigationItemView), do not return
  805|     45|    // themselves in a -hitTest:. Instead they return the nav bar.
  806|     45|    if ([hitView isKindOfClass:[UINavigationBar class]] && [self isNavigationItemView] && [self isDescendantOfView:hitView]) {
  807|      0|        return YES;
  808|      0|    }
  809|     45|    
  810|     45|    return [hitView isDescendantOfView:self];
  811|     45|}
  812|       |
  813|       |- (CGPoint)tappablePointInRect:(CGRect)rect;
  814|     31|{
  815|     31|    // Start at the top and recurse down
  816|     31|    CGRect frame = [self.window convertRect:rect fromView:self];
  817|     31|    
  818|     31|    UIView *hitView = nil;
  819|     31|    CGPoint tapPoint = CGPointZero;
  820|     31|    
  821|     31|    // Mid point
  822|     31|    tapPoint = CGPointCenteredInRect(frame);
  823|     31|    hitView = [self.window hitTest:tapPoint withEvent:nil];
  824|     31|    if ([self isTappableWithHitTestResultView:hitView]) {
  825|     22|        return [self.window convertPoint:tapPoint toView:self];
  826|     22|    }
  827|      9|    
  828|      9|    // Top left
  829|      9|    tapPoint = CGPointMake(frame.origin.x + 1.0f, frame.origin.y + 1.0f);
  830|      9|    hitView = [self.window hitTest:tapPoint withEvent:nil];
  831|      9|    if ([self isTappableWithHitTestResultView:hitView]) {
  832|      0|        return [self.window convertPoint:tapPoint toView:self];
  833|      0|    }
  834|      9|    
  835|      9|    // Top right
  836|      9|    tapPoint = CGPointMake(frame.origin.x + frame.size.width - 1.0f, frame.origin.y + 1.0f);
  837|      9|    hitView = [self.window hitTest:tapPoint withEvent:nil];
  838|      9|    if ([self isTappableWithHitTestResultView:hitView]) {
  839|      0|        return [self.window convertPoint:tapPoint toView:self];
  840|      0|    }
  841|      9|    
  842|      9|    // Bottom left
  843|      9|    tapPoint = CGPointMake(frame.origin.x + 1.0f, frame.origin.y + frame.size.height - 1.0f);
  844|      9|    hitView = [self.window hitTest:tapPoint withEvent:nil];
  845|      9|    if ([self isTappableWithHitTestResultView:hitView]) {
  846|      0|        return [self.window convertPoint:tapPoint toView:self];
  847|      0|    }
  848|      9|    
  849|      9|    // Bottom right
  850|      9|    tapPoint = CGPointMake(frame.origin.x + frame.size.width - 1.0f, frame.origin.y + frame.size.height - 1.0f);
  851|      9|    hitView = [self.window hitTest:tapPoint withEvent:nil];
  852|      9|    if ([self isTappableWithHitTestResultView:hitView]) {
  853|      0|        return [self.window convertPoint:tapPoint toView:self];
  854|      0|    }
  855|      9|    
  856|      9|    return CGPointMake(NAN, NAN);
  857|      9|}
  858|       |
  859|       |- (UIEvent *)eventWithTouches:(NSArray *)touches
  860|      0|{
  861|      0|    // _touchesEvent is a private selector, interface is exposed in UIApplication(KIFAdditionsPrivate)
  862|      0|    UIEvent *event = [[UIApplication sharedApplication] _touchesEvent];
  863|      0|    
  864|      0|    [event _clearTouches];
  865|      0|    [event kif_setEventWithTouches:touches];
  866|      0|
  867|      0|    for (UITouch *aTouch in touches) {
  868|      0|        [event _addTouch:aTouch forDelayedDelivery:NO];
  869|      0|    }
  870|      0|
  871|      0|    return event;
  872|      0|}
  873|       |
  874|       |- (UIEvent *)eventWithTouch:(UITouch *)touch;
  875|      0|{
  876|      0|    NSArray *touches = touch ? @[touch] : nil;
  877|      0|    return [self eventWithTouches:touches];
  878|      0|}
  879|       |
  880|       |- (BOOL)isUserInteractionActuallyEnabled;
  881|      0|{
  882|      0|    BOOL isUserInteractionEnabled = self.userInteractionEnabled;
  883|      0|    
  884|      0|    // Navigation item views don't have user interaction enabled, but their parent nav bar does and will forward the event
  885|      0|    if (!isUserInteractionEnabled && [self isNavigationItemView]) {
  886|      0|        // If this view is inside a nav bar, and the nav bar is enabled, then consider it enabled
  887|      0|        UIView *navBar = [self superview];
  888|      0|        while (navBar && ![navBar isKindOfClass:[UINavigationBar class]]) {
  889|      0|            navBar = [navBar superview];
  890|      0|        }
  891|      0|        if (navBar && navBar.userInteractionEnabled) {
  892|      0|            isUserInteractionEnabled = YES;
  893|      0|        }
  894|      0|    }
  895|      0|    
  896|      0|    // UIActionsheet Buttons have UIButtonLabels with userInteractionEnabled=NO inside,
  897|      0|    // grab the superview UINavigationButton instead.
  898|      0|    if (!isUserInteractionEnabled && [self isKindOfClass:NSClassFromString(@"UIButtonLabel")]) {
  899|      0|        UIView *button = [self superview];
  900|      0|        while (button && ![button isKindOfClass:NSClassFromString(@"UINavigationButton")]) {
  901|      0|            button = [button superview];
  902|      0|        }
  903|      0|        if (button && button.userInteractionEnabled) {
  904|      0|            isUserInteractionEnabled = YES;
  905|      0|        }
  906|      0|    }
  907|      0|    
  908|      0|    // Somtimes views are inside a UIControl and don't have user interaction enabled.
  909|      0|    // Walk up the hierarchary evaluating the parent UIControl subclass and use that instead.
  910|      0|    if (!isUserInteractionEnabled && [self.superview isKindOfClass:[UIControl class]]) {
  911|      0|        // If this view is inside a UIControl, and it is enabled, then consider the view enabled
  912|      0|        UIControl *control = (UIControl *)[self superview];
  913|      0|        while (control && [control isKindOfClass:[UIControl class]]) {
  914|      0|            if (control.isUserInteractionEnabled) {
  915|      0|                isUserInteractionEnabled = YES;
  916|      0|                break;
  917|      0|            }
  918|      0|            control = (UIControl *)[control superview];
  919|      0|        }
  920|      0|    }
  921|      0|    
  922|      0|    return isUserInteractionEnabled;
  923|      0|}
  924|       |
  925|       |- (BOOL)isNavigationItemView;
  926|      0|{
  927|      0|    return [self isKindOfClass:NSClassFromString(@"UINavigationItemView")] || [self isKindOfClass:NSClassFromString(@"_UINavigationBarBackIndicatorView")];
  928|      0|}
  929|       |
  930|       |- (UIWindow *)windowOrIdentityWindow
  931|      0|{
  932|      0|    if (CGAffineTransformIsIdentity(self.window.transform)) {
  933|      0|        return self.window;
  934|      0|    }
  935|      0|    
  936|      0|    for (UIWindow *window in [[UIApplication sharedApplication] windowsWithKeyWindow]) {
  937|      0|        if (CGAffineTransformIsIdentity(window.transform)) {
  938|      0|            return window;
  939|      0|        }
  940|      0|    }
  941|      0|    
  942|      0|    return nil;
  943|      0|}
  944|       |
  945|       |- (BOOL)isVisibleInViewHierarchy
  946|      0|{
  947|      0|    __block BOOL result = YES;
  948|      0|    [self performBlockOnAscendentViews:^(UIView *view, BOOL *stop) {
  949|      0|        if (view.isHidden) {
  950|      0|            result = NO;
  951|      0|            if (stop != NULL) {
  952|      0|                *stop = YES;
  953|      0|            }
  954|      0|        }
  955|      0|    }];
  956|      0|    return result;
  957|      0|}
  958|       |
  959|       |- (BOOL)isVisibleInWindowFrame;
  960|      0|{
  961|      0|    __block CGRect visibleFrame = [self.superview convertRect:self.frame toView:nil];
  962|      0|    [self performBlockOnAscendentViews:^(UIView *view, BOOL *stop) {
  963|      0|        if (view.clipsToBounds) {
  964|      0|            CGRect clippingFrame = [view.superview convertRect:view.frame toView:nil];
  965|      0|            visibleFrame = CGRectIntersection(visibleFrame, clippingFrame);
  966|      0|        }
  967|      0|        if (CGSizeEqualToSize(visibleFrame.size, CGSizeZero)) {
  968|      0|            // Our frame has been fully clipped
  969|      0|            *stop = YES;
  970|      0|        }
  971|      0|        if (view.superview == view.window) {
  972|      0|            // Walked all ancestors (skip the top level window that has no superview)
  973|      0|            *stop = YES;
  974|      0|        }
  975|      0|    }];
  976|      0|    return !CGSizeEqualToSize(visibleFrame.size, CGSizeZero);
  977|      0|}
  978|       |
  979|       |- (void)performBlockOnDescendentViews:(void (^)(UIView *view, BOOL *stop))block
  980|      0|{
  981|      0|    BOOL stop = NO;
  982|      0|    [self performBlockOnDescendentViews:block stop:&stop];
  983|      0|}
  984|       |
  985|       |- (void)performBlockOnDescendentViews:(void (^)(UIView *view, BOOL *stop))block stop:(BOOL *)stop
  986|      0|{
  987|      0|    block(self, stop);
  988|      0|    if (*stop) {
  989|      0|        return;
  990|      0|    }
  991|      0|    
  992|      0|    for (UIView *view in self.subviews) {
  993|      0|        [view performBlockOnDescendentViews:block stop:stop];
  994|      0|        if (*stop) {
  995|      0|            return;
  996|      0|        }
  997|      0|    }
  998|      0|}
  999|       |
 1000|       |- (void)performBlockOnAscendentViews:(void (^)(UIView *view, BOOL *stop))block
 1001|      0|{
 1002|      0|    BOOL stop = NO;
 1003|      0|    UIView *checkedView = self;
 1004|      0|    while(checkedView && stop == NO) {
 1005|      0|        block(checkedView, &stop);
 1006|      0|        checkedView = checkedView.superview;
 1007|      0|    }
 1008|      0|}
 1009|       |
 1010|       |
 1011|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Additions/XCTestCase-KIFAdditions.m:
    1|       |//
    2|       |//  XCTestCase-KIFAdditions.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Tony DiPasquale on 12/9/13.
    6|       |//
    7|       |//
    8|       |
    9|       |#import "XCTestCase-KIFAdditions.h"
   10|       |#import "LoadableCategory.h"
   11|       |#import "UIApplication-KIFAdditions.h"
   12|       |#import "UIView-Debugging.h"
   13|       |#import <objc/runtime.h>
   14|       |
   15|       |MAKE_CATEGORIES_LOADABLE(TestCase_KIFAdditions)
   16|       |
   17|       |static inline void Swizzle(Class c, SEL orig, SEL new)
   18|      1|{
   19|      1|    Method origMethod = class_getInstanceMethod(c, orig);
   20|      1|    Method newMethod = class_getInstanceMethod(c, new);
   21|      1|    if(class_addMethod(c, orig, method_getImplementation(newMethod), method_getTypeEncoding(newMethod)))
   22|      0|        class_replaceMethod(c, new, method_getImplementation(origMethod), method_getTypeEncoding(origMethod));
   23|      1|    else
   24|      1|        method_exchangeImplementations(origMethod, newMethod);
   25|      1|}
   26|       |
   27|       |@interface XCTestCase ()
   28|       |- (void)_recordUnexpectedFailureWithDescription:(id)arg1 exception:(id)arg2;
   29|       |@end
   30|       |
   31|       |@implementation XCTestCase (KIFAdditions)
   32|       |
   33|       |- (void)failWithException:(NSException *)exception stopTest:(BOOL)stop
   34|      0|{
   35|      0|    self.continueAfterFailure = YES;
   36|      0|
   37|      0|    [self recordFailureWithDescription:exception.description inFile:exception.userInfo[@"FilenameKey"] atLine:[exception.userInfo[@"LineNumberKey"] unsignedIntegerValue] expected:NO];
   38|      0|
   39|      0|    if (stop) {
   40|      0|        [self writeScreenshotForException:exception];
   41|      0|        [self printViewHierarchyIfOptedIn];
   42|      0|        static dispatch_once_t onceToken;
   43|      0|        dispatch_once(&onceToken, ^{
   44|      0|            Swizzle([XCTestCase class], @selector(_recordUnexpectedFailureWithDescription:exception:), @selector(KIF_recordUnexpectedFailureWithDescription:exception:));
   45|      0|        });
   46|      0|        [exception raise];
   47|      0|    }
   48|      0|}
   49|       |
   50|       |- (void)failWithExceptions:(NSArray *)exceptions stopTest:(BOOL)stop
   51|      0|{
   52|      0|    NSException *lastException = exceptions.lastObject;
   53|      0|    for (NSException *exception in exceptions) {
   54|      0|        [self failWithException:exception stopTest:(exception == lastException ? stop : NO)];
   55|      0|    }
   56|      0|}
   57|       |
   58|       |- (void)KIF_recordUnexpectedFailureWithDescription:(id)arg1 exception:(NSException *)arg2
   59|      0|{
   60|      0|    if (![[arg2 name] isEqualToString:@"KIFFailureException"]) {
   61|      0|        [self KIF_recordUnexpectedFailureWithDescription:arg1 exception:arg2];
   62|      0|    }
   63|      0|}
   64|       |
   65|       |- (void)writeScreenshotForException:(NSException *)exception;
   66|      0|{
   67|      0|    [[UIApplication sharedApplication] writeScreenshotForLine:[exception.userInfo[@"LineNumberKey"] unsignedIntegerValue] inFile:exception.userInfo[@"FilenameKey"] description:nil error:NULL];
   68|      0|    
   69|      0|#ifdef __IPHONE_11_0
   70|      0|    if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 11.0) {
   71|      0|        //semaphore will make sure the screenshot will be captured. otherwise it will crash on getting screenshot!
   72|      0|        dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
   73|      0|        
   74|      0|        [XCTContext runActivityNamed:(@"screenshot") block:^(id<XCTActivity>  _Nonnull activity) {
   75|      0|            XCUIScreenshot *screenShot = [[XCUIScreen mainScreen] screenshot];
   76|      0|            XCTAttachment *attachment = [XCTAttachment attachmentWithScreenshot:screenShot];
   77|      0|            [activity addAttachment:(attachment)];
   78|      0|            dispatch_semaphore_signal(semaphore);
   79|      0|        }];
   80|      0|        
   81|      0|        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
   82|      0|    }
   83|      0|#endif
   84|      0|    
   85|      0|}
   86|       |
   87|       |- (void)printViewHierarchyIfOptedIn;
   88|      0|{
   89|      0|    static BOOL shouldPrint;
   90|      0|    
   91|      0|    static dispatch_once_t onceToken;
   92|      0|    dispatch_once(&onceToken, ^{
   93|      0|        NSString *shouldPrintValue = [NSProcessInfo.processInfo.environment objectForKey:@"KIF_PRINTVIEWTREEONFAILURE"];
   94|      0|        shouldPrint = [[shouldPrintValue uppercaseString] isEqualToString:@"YES"];
   95|      0|    });
   96|      0|
   97|      0|    if (shouldPrint) {
   98|      0|        [UIView printViewHierarchy];
   99|      0|    }
  100|      0|}
  101|       |
  102|       |@end
  103|       |
  104|       |#ifdef __IPHONE_8_0
  105|       |
  106|       |@interface XCTestSuite ()
  107|       |- (void)_recordUnexpectedFailureForTestRun:(id)arg1 description:(id)arg2 exception:(id)arg3;
  108|       |@end
  109|       |
  110|       |@implementation XCTestSuite (KIFAdditions)
  111|       |
  112|       |+ (void)load
  113|      1|{
  114|      1|    Swizzle([XCTestSuite class], @selector(_recordUnexpectedFailureForTestRun:description:exception:), @selector(KIF_recordUnexpectedFailureForTestRun:description:exception:));
  115|      1|}
  116|       |
  117|       |- (void)KIF_recordUnexpectedFailureForTestRun:(XCTestSuiteRun *)arg1 description:(id)arg2 exception:(NSException *)arg3
  118|      0|{
  119|      0|    if (![[arg3 name] isEqualToString:@"KIFFailureException"]) {
  120|      0|        [self KIF_recordUnexpectedFailureForTestRun:arg1 description:arg2 exception:arg3];
  121|      0|    } else {
  122|      0|        [arg1 recordFailureWithDescription:[NSString stringWithFormat:@"Test suite stopped on fatal error: %@", arg3.description] inFile:arg3.userInfo[@"FilenameKey"] atLine:[arg3.userInfo[@"LineNumberKey"] unsignedIntegerValue] expected:NO];
  123|      0|    }
  124|      0|}
  125|       |
  126|       |@end
  127|       |
  128|       |#endif

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Classes/IOHIDEvent+KIF.m:
    1|       |//
    2|       |//  IOHIDEvent+KIF.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Thomas Bonnin on 7/6/15.
    6|       |//
    7|       |//
    8|       |
    9|       |#import <UIKit/UIKit.h>
   10|       |#import "IOHIDEvent+KIF.h"
   11|       |#import <mach/mach_time.h>
   12|       |
   13|       |#define IOHIDEventFieldBase(type) (type << 16)
   14|       |#ifdef __LP64__
   15|       |typedef double IOHIDFloat;
   16|       |#else
   17|       |typedef float IOHIDFloat;
   18|       |#endif
   19|       |typedef UInt32 IOOptionBits;
   20|       |typedef uint32_t IOHIDDigitizerTransducerType;
   21|       |typedef uint32_t IOHIDEventField;
   22|       |typedef uint32_t IOHIDEventType;
   23|       |
   24|       |void IOHIDEventAppendEvent(IOHIDEventRef event, IOHIDEventRef childEvent);
   25|       |void IOHIDEventSetIntegerValue(IOHIDEventRef event, IOHIDEventField field, int value);
   26|       |void IOHIDEventSetSenderID(IOHIDEventRef event, uint64_t sender);
   27|       |
   28|       |enum {
   29|       |    kIOHIDDigitizerTransducerTypeStylus = 0,
   30|       |    kIOHIDDigitizerTransducerTypePuck,
   31|       |    kIOHIDDigitizerTransducerTypeFinger,
   32|       |    kIOHIDDigitizerTransducerTypeHand
   33|       |};
   34|       |
   35|       |enum {
   36|       |    kIOHIDEventTypeNULL,                    // 0
   37|       |    kIOHIDEventTypeVendorDefined,
   38|       |    kIOHIDEventTypeButton,
   39|       |    kIOHIDEventTypeKeyboard,
   40|       |    kIOHIDEventTypeTranslation,
   41|       |    kIOHIDEventTypeRotation,                // 5
   42|       |    kIOHIDEventTypeScroll,
   43|       |    kIOHIDEventTypeScale,
   44|       |    kIOHIDEventTypeZoom,
   45|       |    kIOHIDEventTypeVelocity,
   46|       |    kIOHIDEventTypeOrientation,             // 10
   47|       |    kIOHIDEventTypeDigitizer,
   48|       |    kIOHIDEventTypeAmbientLightSensor,
   49|       |    kIOHIDEventTypeAccelerometer,
   50|       |    kIOHIDEventTypeProximity,
   51|       |    kIOHIDEventTypeTemperature,             // 15
   52|       |    kIOHIDEventTypeNavigationSwipe,
   53|       |    kIOHIDEventTypePointer,
   54|       |    kIOHIDEventTypeProgress,
   55|       |    kIOHIDEventTypeMultiAxisPointer,
   56|       |    kIOHIDEventTypeGyro,                    // 20
   57|       |    kIOHIDEventTypeCompass,
   58|       |    kIOHIDEventTypeZoomToggle,
   59|       |    kIOHIDEventTypeDockSwipe,               // just like kIOHIDEventTypeNavigationSwipe, but intended for consumption by Dock
   60|       |    kIOHIDEventTypeSymbolicHotKey,
   61|       |    kIOHIDEventTypePower,                   // 25
   62|       |    kIOHIDEventTypeLED,
   63|       |    kIOHIDEventTypeFluidTouchGesture,       // This will eventually superseed Navagation and Dock swipes
   64|       |    kIOHIDEventTypeBoundaryScroll,
   65|       |    kIOHIDEventTypeBiometric,
   66|       |    kIOHIDEventTypeUnicode,                 // 30
   67|       |    kIOHIDEventTypeAtmosphericPressure,
   68|       |    kIOHIDEventTypeUndefined,
   69|       |    kIOHIDEventTypeCount, // This should always be last
   70|       |    
   71|       |    
   72|       |    // DEPRECATED:
   73|       |    kIOHIDEventTypeSwipe = kIOHIDEventTypeNavigationSwipe,
   74|       |    kIOHIDEventTypeMouse = kIOHIDEventTypePointer
   75|       |};
   76|       |
   77|       |enum {
   78|       |    kIOHIDDigitizerEventRange                               = 0x00000001,
   79|       |    kIOHIDDigitizerEventTouch                               = 0x00000002,
   80|       |    kIOHIDDigitizerEventPosition                            = 0x00000004,
   81|       |    kIOHIDDigitizerEventStop                                = 0x00000008,
   82|       |    kIOHIDDigitizerEventPeak                                = 0x00000010,
   83|       |    kIOHIDDigitizerEventIdentity                            = 0x00000020,
   84|       |    kIOHIDDigitizerEventAttribute                           = 0x00000040,
   85|       |    kIOHIDDigitizerEventCancel                              = 0x00000080,
   86|       |    kIOHIDDigitizerEventStart                               = 0x00000100,
   87|       |    kIOHIDDigitizerEventResting                             = 0x00000200,
   88|       |    kIOHIDDigitizerEventSwipeUp                             = 0x01000000,
   89|       |    kIOHIDDigitizerEventSwipeDown                           = 0x02000000,
   90|       |    kIOHIDDigitizerEventSwipeLeft                           = 0x04000000,
   91|       |    kIOHIDDigitizerEventSwipeRight                          = 0x08000000,
   92|       |    kIOHIDDigitizerEventSwipeMask                           = 0xFF000000,
   93|       |};
   94|       |enum {
   95|       |    kIOHIDEventFieldDigitizerX = IOHIDEventFieldBase(kIOHIDEventTypeDigitizer),
   96|       |    kIOHIDEventFieldDigitizerY,
   97|       |    kIOHIDEventFieldDigitizerZ,
   98|       |    kIOHIDEventFieldDigitizerButtonMask,
   99|       |    kIOHIDEventFieldDigitizerType,
  100|       |    kIOHIDEventFieldDigitizerIndex,
  101|       |    kIOHIDEventFieldDigitizerIdentity,
  102|       |    kIOHIDEventFieldDigitizerEventMask,
  103|       |    kIOHIDEventFieldDigitizerRange,
  104|       |    kIOHIDEventFieldDigitizerTouch,
  105|       |    kIOHIDEventFieldDigitizerPressure,
  106|       |    kIOHIDEventFieldDigitizerAuxiliaryPressure, //BarrelPressure
  107|       |    kIOHIDEventFieldDigitizerTwist,
  108|       |    kIOHIDEventFieldDigitizerTiltX,
  109|       |    kIOHIDEventFieldDigitizerTiltY,
  110|       |    kIOHIDEventFieldDigitizerAltitude,
  111|       |    kIOHIDEventFieldDigitizerAzimuth,
  112|       |    kIOHIDEventFieldDigitizerQuality,
  113|       |    kIOHIDEventFieldDigitizerDensity,
  114|       |    kIOHIDEventFieldDigitizerIrregularity,
  115|       |    kIOHIDEventFieldDigitizerMajorRadius,
  116|       |    kIOHIDEventFieldDigitizerMinorRadius,
  117|       |    kIOHIDEventFieldDigitizerCollection,
  118|       |    kIOHIDEventFieldDigitizerCollectionChord,
  119|       |    kIOHIDEventFieldDigitizerChildEventMask,
  120|       |    kIOHIDEventFieldDigitizerIsDisplayIntegrated,
  121|       |    kIOHIDEventFieldDigitizerQualityRadiiAccuracy,
  122|       |};
  123|       |IOHIDEventRef IOHIDEventCreateDigitizerEvent(CFAllocatorRef allocator, AbsoluteTime timeStamp, IOHIDDigitizerTransducerType type,
  124|       |                                             uint32_t index, uint32_t identity, uint32_t eventMask, uint32_t buttonMask,
  125|       |                                             IOHIDFloat x, IOHIDFloat y, IOHIDFloat z, IOHIDFloat tipPressure, IOHIDFloat barrelPressure,
  126|       |                                             Boolean range, Boolean touch, IOOptionBits options);
  127|       |IOHIDEventRef IOHIDEventCreateDigitizerFingerEventWithQuality(CFAllocatorRef allocator, AbsoluteTime timeStamp,
  128|       |                                                              uint32_t index, uint32_t identity, uint32_t eventMask,
  129|       |                                                              IOHIDFloat x, IOHIDFloat y, IOHIDFloat z, IOHIDFloat tipPressure, IOHIDFloat twist,
  130|       |                                                              IOHIDFloat minorRadius, IOHIDFloat majorRadius, IOHIDFloat quality, IOHIDFloat density, IOHIDFloat irregularity,
  131|       |                                                              Boolean range, Boolean touch, IOOptionBits options);
  132|       |
  133|      0|IOHIDEventRef kif_IOHIDEventWithTouches(NSArray *touches) {
  134|      0|    uint64_t abTime = mach_absolute_time();
  135|      0|    AbsoluteTime timeStamp;
  136|      0|    timeStamp.hi = (UInt32)(abTime >> 32);
  137|      0|    timeStamp.lo = (UInt32)(abTime);
  138|      0|    
  139|      0|    IOHIDEventRef handEvent = IOHIDEventCreateDigitizerEvent(kCFAllocatorDefault, // allocator
  140|      0|                                                             timeStamp, // timestamp
  141|      0|                                                             kIOHIDDigitizerTransducerTypeHand, // type
  142|      0|                                                             0, // index
  143|      0|                                                             0, // identity
  144|      0|                                                             kIOHIDDigitizerEventTouch, // eventMask
  145|      0|                                                             0, // buttonMask
  146|      0|                                                             0, // x
  147|      0|                                                             0, // y
  148|      0|                                                             0, // z
  149|      0|                                                             0, // tipPressure
  150|      0|                                                             0, // barrelPressure
  151|      0|                                                             0, // range
  152|      0|                                                             true, // touch
  153|      0|                                                             0); // options
  154|      0|    IOHIDEventSetIntegerValue(handEvent, kIOHIDEventFieldDigitizerIsDisplayIntegrated, true);
  155|      0|    
  156|      0|    for (UITouch *touch in touches)
  157|      0|    {
  158|      0|        uint32_t eventMask = (touch.phase == UITouchPhaseMoved) ? kIOHIDDigitizerEventPosition : (kIOHIDDigitizerEventRange | kIOHIDDigitizerEventTouch);
  159|      0|        uint32_t isTouching = (touch.phase == UITouchPhaseEnded) ? 0 : 1;
  160|      0|        
  161|      0|        CGPoint touchLocation = [touch locationInView:touch.window];
  162|      0|        
  163|      0|        IOHIDEventRef fingerEvent = IOHIDEventCreateDigitizerFingerEventWithQuality(kCFAllocatorDefault, // allocator
  164|      0|                                                                                    timeStamp, // timestamp
  165|      0|                                                                                    (UInt32)[touches indexOfObject:touch] + 1, //index
  166|      0|                                                                                    2, // identity
  167|      0|                                                                                    eventMask, // eventMask
  168|      0|                                                                                    (IOHIDFloat)touchLocation.x, // x
  169|      0|                                                                                    (IOHIDFloat)touchLocation.y, // y
  170|      0|                                                                                    0.0, // z
  171|      0|                                                                                    0, // tipPressure
  172|      0|                                                                                    0, // twist
  173|      0|                                                                                    5.0, // minor radius
  174|      0|                                                                                    5.0, // major radius
  175|      0|                                                                                    1.0, // quality
  176|      0|                                                                                    1.0, // density
  177|      0|                                                                                    1.0, // irregularity
  178|      0|                                                                                    (IOHIDFloat)isTouching, // range
  179|      0|                                                                                    (IOHIDFloat)isTouching, // touch
  180|      0|                                                                                    0); // options
  181|      0|        IOHIDEventSetIntegerValue(fingerEvent, kIOHIDEventFieldDigitizerIsDisplayIntegrated, 1);
  182|      0|        
  183|      0|        IOHIDEventAppendEvent(handEvent, fingerEvent);
  184|      0|        CFRelease(fingerEvent);
  185|      0|    }
  186|      0|    
  187|      0|    return handEvent;
  188|      0|}

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Classes/KIFAccessibilityEnabler.m:
    1|       |//
    2|       |//  KIFAccessibilityEnabler.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Timothy Clem on 10/11/15.
    6|       |//
    7|       |//
    8|       |
    9|       |#import "KIFAccessibilityEnabler.h"
   10|       |#import <XCTest/XCTest.h>
   11|       |#import <dlfcn.h>
   12|       |
   13|       |
   14|       |@protocol KIFSelectorsToMakeCompilerHappy <NSObject>
   15|       |
   16|       |// AccessibilitySettingsController (AccessibilitySettings.bundle)
   17|       |- (void)setAXInspectorEnabled:(NSNumber*)enabled specifier:(id)specifier;
   18|       |- (NSNumber *)AXInspectorEnabled:(id)specifier;
   19|       |
   20|       |@end
   21|       |
   22|       |
   23|       |static void * loadDylibForSimulator(NSString *path)
   24|      3|{
   25|      3|    NSDictionary *environment = [[NSProcessInfo processInfo] environment];
   26|      3|    NSString *simulatorRoot = [environment objectForKey:@"IPHONE_SIMULATOR_ROOT"];
   27|      3|    if (simulatorRoot) {
   28|      3|        path = [simulatorRoot stringByAppendingPathComponent:path];
   29|      3|    }
   30|      3|    return dlopen([path fileSystemRepresentation], RTLD_LOCAL);
   31|      3|}
   32|       |
   33|       |static BOOL __KIFAccessibilityEnabled = NO;
   34|       |
   35|       |BOOL KIFAccessibilityEnabled(void)
   36|      3|{
   37|      3|    return __KIFAccessibilityEnabled;
   38|      3|}
   39|       |
   40|       |void KIFEnableAccessibility(void)
   41|      1|{
   42|      1|    static dispatch_once_t onceToken;
   43|      1|    dispatch_once(&onceToken, ^{
   44|      1|        // CPCopySharedResourcesPreferencesDomainForDomain from AppSupport
   45|      1|        void *appSupport = loadDylibForSimulator(@"/System/Library/PrivateFrameworks/AppSupport.framework/AppSupport");
   46|      1|        if (appSupport) {
   47|      1|            CFStringRef (*copySharedResourcesPreferencesDomainForDomain)(CFStringRef domain) = dlsym(appSupport, "CPCopySharedResourcesPreferencesDomainForDomain");
   48|      1|            if (copySharedResourcesPreferencesDomainForDomain) {
   49|      1|                CFStringRef accessibilityDomain = copySharedResourcesPreferencesDomainForDomain(CFSTR("com.apple.Accessibility"));
   50|      1|                if (accessibilityDomain) {
   51|      1|                    CFPreferencesSetValue(CFSTR("ApplicationAccessibilityEnabled"), kCFBooleanTrue, accessibilityDomain, kCFPreferencesAnyUser, kCFPreferencesAnyHost);
   52|      1|                    CFRelease(accessibilityDomain);
   53|      1|                }
   54|      1|            }
   55|      1|        }
   56|      1|        
   57|      1|        // Load AccessibilitySettings bundle
   58|      1|        NSString *settingsBundleLocation = @"/System/Library/PreferenceBundles/AccessibilitySettings.bundle/AccessibilitySettings";
   59|      1|        void *settingsBundle = loadDylibForSimulator(settingsBundleLocation);
   60|      1|        if (settingsBundle) {
   61|      1|            Class axClass = NSClassFromString(@"AccessibilitySettingsController");
   62|      1|            if (axClass) {
   63|      1|                id axInstance = [[axClass alloc] init];
   64|      1|                if ([axInstance respondsToSelector:@selector(AXInspectorEnabled:)]) {
   65|      0|                    NSNumber *initialValue = [axInstance AXInspectorEnabled:nil];
   66|      0|                    
   67|      0|                    // reset on exit
   68|      0|                    atexit_b(^{
   69|      0|                        [axInstance setAXInspectorEnabled:initialValue specifier:nil];
   70|      0|                    });
   71|      0|                    [axInstance setAXInspectorEnabled:@YES specifier:nil];
   72|      0|                    __KIFAccessibilityEnabled = YES;
   73|      0|                    return;
   74|      0|                }
   75|      1|            }
   76|      1|        }
   77|      1|        
   78|      1|        // If we get to this point, the legacy method has not worked
   79|      1|        void *handle = loadDylibForSimulator(@"/usr/lib/libAccessibility.dylib");
   80|      1|        if (!handle) {
   81|      0|            [NSException raise:NSGenericException format:@"Could not enable accessibility"];
   82|      0|        }
   83|      1|        
   84|      1|        int (*_AXSAutomationEnabled)(void) = dlsym(handle, "_AXSAutomationEnabled");
   85|      1|        void (*_AXSSetAutomationEnabled)(int) = dlsym(handle, "_AXSSetAutomationEnabled");
   86|      1|        
   87|      1|        int initialValue = _AXSAutomationEnabled();
   88|      1|        _AXSSetAutomationEnabled(YES);
   89|      1|        __KIFAccessibilityEnabled = YES;
   90|      1|        atexit_b(^{
   91|      1|            _AXSSetAutomationEnabled(initialValue);
   92|      1|        });
   93|      1|    });
   94|      1|}

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Classes/KIFSystemTestActor.h:
    1|       |//
    2|       |//  KIFTester+Generic.h
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Brian Nickel on 12/14/12.
    6|       |//  Licensed to Square, Inc. under one or more contributor license agreements.
    7|       |//  See the LICENSE file distributed with this work for the terms under
    8|       |//  which Square, Inc. licenses this file to you.
    9|       |
   10|       |#import "KIFTestActor.h"
   11|       |#import <UIKit/UIKit.h>
   12|       |
   13|       |
   14|       |#define systemTester KIFActorWithClass(KIFSystemTestActor)
   15|       |
   16|       |// The symbol `system` collides with the cstdlib for compiling C++. Leaving it available for compatibility reasons.
   17|       |// This will be removed with the next major KIF release, please start using `systemTester` instead.
   18|       |#ifndef __cplusplus
   19|       |
   20|       |#if DEPRECATE_KIF_SYSTEM
   21|       |// Add `-DDEPRECATE_KIF_SYSTEM=1` to OTHER_CFLAGS if you'd like to prevent usage of the `system` macro.
   22|       |@class KIFSystemTestActor;
   23|       |KIFSystemTestActor *_KIF_system() __attribute__((deprecated("Use of `system` has been deprecated; Use `systemTester` instead.")));
   24|       |#define system _KIF_system()
   25|       |#else
   26|      0|#define system KIFActorWithClass(KIFSystemTestActor)
   27|       |#endif
   28|       |
   29|       |#endif
   30|       |
   31|       |@interface KIFSystemTestActor : KIFTestActor
   32|       |
   33|       |/*!
   34|       | @abstract Waits for a specific NSNotification.
   35|       | @discussion Useful when a test requires an asynchronous task to complete, especially when that task does not trigger a visible change in the view hierarchy.
   36|       | @param name The name of the NSNotification.
   37|       | @param object The object to which the step should listen. Nil value will listen to all objects.
   38|       | @return The detected NSNotification.
   39|       | */
   40|       |- (NSNotification *)waitForNotificationName:(NSString*)name object:(id)object;
   41|       |
   42|       |/*!
   43|       | @abstract Waits for a specific NSNotification, emitted during or after execution of a block.
   44|       | @discussion Useful when step execution causes a notification to be emitted, but executes too quickly for waitForNotificationName: to observe it.
   45|       | An observer will be registered for the notification before the block is executed.
   46|       | @param name The name of the NSNotification.
   47|       | @param object The object to which the step should listen. Nil value will listen to all objects.
   48|       | @param block The block of code to be executed.
   49|       | @return The detected NSNotification.
   50|       | */
   51|       |- (NSNotification *)waitForNotificationName:(NSString *)name object:(id)object whileExecutingBlock:(void(^)(void))block;
   52|       |
   53|       |/*!
   54|       | @abstract Simulates a memory warning.
   55|       | */
   56|       |- (void)simulateMemoryWarning;
   57|       |
   58|       |/*!
   59|       | @abstract Simulates a device rotation to a specific orentation from its last set orientation.
   60|       | @discussion The first time this method is called, it will be from the device's natural orientation to the orientation described.
   61|       | @param orientation The desired orientation.
   62|       | */
   63|       |- (void)simulateDeviceRotationToOrientation:(UIDeviceOrientation)orientation;
   64|       |
   65|       |/*!
   66|       | @abstract Waits for the application to request a specific URL while executing a block.
   67|       | @param URLString The absolute string representation of the URL to detect.
   68|       | @param block The block of code to be executed.
   69|       | @param returnValue The value to return from @c +[UIApplication openURL:].
   70|       | */
   71|       |- (void)waitForApplicationToOpenURL:(NSString *)URLString whileExecutingBlock:(void(^)(void))block returning:(BOOL)returnValue;
   72|       |
   73|       |/*!
   74|       | @abstract Waits for the application to request any URL while executing a block.
   75|       | @param block The block of code to be executed.
   76|       | @param returnValue The value to return from @c +[UIApplication openURL:].
   77|       | */
   78|       |- (void)waitForApplicationToOpenAnyURLWhileExecutingBlock:(void(^)(void))block returning:(BOOL)returnValue;
   79|       |
   80|       |/*!
   81|       | @abstract Waits for the application to request any URL with the given URL Scheme while executing a block.
   82|       | @param URLScheme The scheme component of the URL to detect.
   83|       | @param block The block of code to be executed.
   84|       | @param returnValue The value to return from @c +[UIApplication openURL:].
   85|       | */
   86|       |- (void)waitForApplicationToOpenURLWithScheme:(NSString *)URLScheme whileExecutingBlock:(void (^)(void))block returning:(BOOL)returnValue;
   87|       |
   88|       |/*!
   89|       | @abstract Captured a screenshot of the current screen and writes it to disk with an optional description.
   90|       | @discussion This step will fail if the @c KIF_SCREENSHOTS environment variable is not set or if the screenshot cannot be written to disk.
   91|       | @param description A description to use when writing the file to disk.
   92|       | */
   93|       |- (void)captureScreenshotWithDescription:(NSString *)description;
   94|       |
   95|       |/*!
   96|       | @abstract Backgrounds app using UIAutomation command, simulating pressing the Home button
   97|       | @param duration Amount of time for a background event before the app becomes active again
   98|       | */
   99|       |- (void)deactivateAppForDuration:(NSTimeInterval)duration;
  100|       |
  101|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Classes/KIFSystemTestActor.m:
    1|       |//
    2|       |//  KIFTester+Generic.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Brian Nickel on 12/14/12.
    6|       |//  Licensed to Square, Inc. under one or more contributor license agreements.
    7|       |//  See the LICENSE file distributed with this work for the terms under
    8|       |//  which Square, Inc. licenses this file to you.
    9|       |
   10|       |#import "KIFSystemTestActor.h"
   11|       |#import <UIKit/UIKit.h>
   12|       |#import "UIApplication-KIFAdditions.h"
   13|       |#import "NSError-KIFAdditions.h"
   14|       |#import "UIAutomationHelper.h"
   15|       |
   16|       |
   17|       |@implementation KIFSystemTestActor
   18|       |
   19|       |- (NSNotification *)waitForNotificationName:(NSString*)name object:(id)object
   20|      0|{
   21|      0|    return [self waitForNotificationName:name object:object whileExecutingBlock:nil];
   22|      0|}
   23|       |
   24|       |- (NSNotification *)waitForNotificationName:(NSString *)name object:(id)object whileExecutingBlock:(void(^)(void))block
   25|      0|{
   26|      0|    return [self waitForNotificationName:name object:object whileExecutingBlock:block complete:nil];
   27|      0|}
   28|       |
   29|       |- (NSNotification *)waitForNotificationName:(NSString *)name object:(id)object whileExecutingBlock:(void(^)(void))block complete:(void(^)(void))complete
   30|      0|{
   31|      0|    __block NSNotification *detectedNotification = nil;
   32|      0|    id observer = [[NSNotificationCenter defaultCenter] addObserverForName:name object:object queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification *note) {
   33|      0|        detectedNotification = note;
   34|      0|    }];
   35|      0|    
   36|      0|    if (block) {
   37|      0|        block();
   38|      0|    }
   39|      0|    
   40|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
   41|      0|        KIFTestWaitCondition(detectedNotification, error, @"Waiting for notification \"%@\"", name);
   42|      0|        return KIFTestStepResultSuccess;
   43|      0|    } complete:^(KIFTestStepResult result, NSError *error) {
   44|      0|        [[NSNotificationCenter defaultCenter] removeObserver:observer];
   45|      0|        
   46|      0|        if (complete) {
   47|      0|            complete();
   48|      0|        }
   49|      0|    }];
   50|      0|    
   51|      0|    return detectedNotification;
   52|      0|}
   53|       |
   54|       |- (void)simulateMemoryWarning
   55|      0|{
   56|      0|    [[NSNotificationCenter defaultCenter] postNotificationName:UIApplicationDidReceiveMemoryWarningNotification object:[UIApplication sharedApplication]];
   57|      0|}
   58|       |
   59|       |- (void)simulateDeviceRotationToOrientation:(UIDeviceOrientation)orientation
   60|      0|{
   61|      0|    [[UIDevice currentDevice] setValue:[NSNumber numberWithInt:orientation] forKey:@"orientation"];
   62|      0|}
   63|       |
   64|       |
   65|       |- (void)waitForApplicationToOpenAnyURLWhileExecutingBlock:(void (^)(void))block returning:(BOOL)returnValue
   66|      0|{
   67|      0|    [self waitForApplicationToOpenURL:nil whileExecutingBlock:block returning:returnValue];
   68|      0|}
   69|       |
   70|      0|- (void)waitForApplicationToOpenURLWithScheme:(NSString *)URLScheme whileExecutingBlock:(void (^)(void))block returning:(BOOL)returnValue {
   71|      0|    [self waitForApplicationToOpenURLMatchingBlock:^(NSURL *actualURL){
   72|      0|        if (URLScheme && ![URLScheme isEqualToString:actualURL.scheme]) {
   73|      0|            [self failWithError:[NSError KIFErrorWithFormat:@"Expected %@ to start with %@", actualURL.absoluteString, URLScheme] stopTest:YES];
   74|      0|        }
   75|      0|    } whileExecutingBlock:block returning:returnValue];
   76|      0|}
   77|       |
   78|      0|- (void)waitForApplicationToOpenURL:(NSString *)URLString whileExecutingBlock:(void (^)(void))block returning:(BOOL)returnValue {
   79|      0|    [self waitForApplicationToOpenURLMatchingBlock:^(NSURL *actualURL){
   80|      0|
   81|      0|        if (URLString && ![[actualURL absoluteString] isEqualToString:URLString]) {
   82|      0|            [self failWithError:[NSError KIFErrorWithFormat:@"Expected %@, got %@", URLString, actualURL.absoluteString] stopTest:YES];
   83|      0|        }
   84|      0|    } whileExecutingBlock:block returning:returnValue];
   85|      0|}
   86|       |
   87|       |- (void)waitForApplicationToOpenURLMatchingBlock:(void (^)(NSURL *actualURL))URLMatcherBlock whileExecutingBlock:(void (^)(void))block returning:(BOOL)returnValue
   88|      0|{
   89|      0|    [UIApplication startMockingOpenURLWithReturnValue:returnValue];
   90|      0|
   91|      0|    id canOpenURLObserver = [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidMockCanOpenURLNotification object:[UIApplication sharedApplication] queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification *notification) {
   92|      0|        if (URLMatcherBlock) {
   93|      0|            NSURL *actualURL = [notification.userInfo objectForKey:UIApplicationOpenedURLKey];
   94|      0|            URLMatcherBlock(actualURL);
   95|      0|        }
   96|      0|    }];
   97|      0|
   98|      0|    NSNotification *notification = [self waitForNotificationName:UIApplicationDidMockOpenURLNotification object:[UIApplication sharedApplication] whileExecutingBlock:block complete:^{
   99|      0|        [UIApplication stopMockingOpenURL];
  100|      0|        [[NSNotificationCenter defaultCenter] removeObserver:canOpenURLObserver];
  101|      0|    }];
  102|      0|
  103|      0|    if (URLMatcherBlock) {
  104|      0|        NSURL *actualURL = [notification.userInfo objectForKey:UIApplicationOpenedURLKey];
  105|      0|        URLMatcherBlock(actualURL);
  106|      0|    }
  107|      0|}
  108|       |
  109|       |- (void)captureScreenshotWithDescription:(NSString *)description
  110|      0|{
  111|      0|    NSError *error;
  112|      0|    if (![[UIApplication sharedApplication] writeScreenshotForLine:(NSUInteger)self.line inFile:self.file description:description error:&error]) {
  113|      0|        [self failWithError:error stopTest:NO];
  114|      0|    }
  115|      0|}
  116|       |
  117|      0|- (void)deactivateAppForDuration:(NSTimeInterval)duration {
  118|      0|    [UIAutomationHelper deactivateAppForDuration:@(duration)];
  119|      0|}
  120|       |
  121|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Classes/KIFTestActor.h:
    1|       |//
    2|       |//  KIFTestActor.h
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Brian Nickel on 12/13/12.
    6|       |//  Licensed to Square, Inc. under one or more contributor license agreements.
    7|       |//  See the LICENSE file distributed with this work for the terms under
    8|       |//  which Square, Inc. licenses this file to you.
    9|       |
   10|       |#import <Foundation/Foundation.h>
   11|       |
   12|       |#ifdef DEPRECATED_MSG_ATTRIBUTE
   13|       |#define KIF_DEPRECATED(m) DEPRECATED_MSG_ATTRIBUTE(m)
   14|       |#else
   15|       |#define KIF_DEPRECATED(m)
   16|       |#endif
   17|       |
   18|      0|#define KIFActorWithClass(clazz) [clazz actorInFile:[NSString stringWithUTF8String:__FILE__] atLine:__LINE__ delegate:self]
   19|       |
   20|       |/*!
   21|       | @define KIFTestCondition
   22|       | @abstract Tests a condition and returns a failure result if the condition isn't true.
   23|       | @discussion This is a useful macro for quickly evaluating conditions in a test step. If the condition is false then the current test step will be aborted with a failure result.
   24|       | @param condition The condition to test.
   25|       | @param error The NSError object to put the error string into. May be nil, but should usually be the error parameter from the test step execution block.
   26|       | @param ... A string describing what the failure was that occurred. This may be a format string with additional arguments.
   27|       | */
   28|      0|#define KIFTestCondition(condition, error, ...) ({ \
   29|      0|if (!(condition)) { \
   30|      0|if (error) { \
   31|      0|*error = [NSError errorWithDomain:@"KIFTest" code:KIFTestStepResultFailure userInfo:[NSDictionary dictionaryWithObjectsAndKeys:[NSString stringWithFormat:__VA_ARGS__], NSLocalizedDescriptionKey, nil]]; \
   32|      0|} \
   33|      0|return KIFTestStepResultFailure; \
   34|      0|} \
   35|      0|})
   36|       |
   37|       |/*!
   38|       | @define KIFTestWaitCondition
   39|       | @abstract Tests a condition and returns a wait result if the condition isn't true.
   40|       | @discussion This is a useful macro for quickly evaluating conditions in a test step. If the condition is false then the current test step will be aborted with a wait result, indicating that it should be called again in the near future.
   41|       | @param condition The condition to test.
   42|       | @param error The NSError object to put the error string into. May be nil, but should usually be the error parameter from the test step execution block.
   43|       | @param ... A string describing why the step needs to wait. This is important since this reason will be considered the cause of a timeout error if the step requires waiting for too long. This may be a format string with additional arguments.
   44|       | */
   45|      0|#define KIFTestWaitCondition(condition, error, ...) ({ \
   46|      0|if (!(condition)) { \
   47|      0|if (error) { \
   48|      0|*error = [NSError errorWithDomain:@"KIFTest" code:KIFTestStepResultWait userInfo:[NSDictionary dictionaryWithObjectsAndKeys:[NSString stringWithFormat:__VA_ARGS__], NSLocalizedDescriptionKey, nil]]; \
   49|      0|} \
   50|      0|return KIFTestStepResultWait; \
   51|      0|} \
   52|      0|})
   53|       |
   54|       |/*!
   55|       | @enum KIFTestStepResult
   56|       | @abstract Result codes from a test step.
   57|       | @constant KIFTestStepResultFailure The step failed and the test controller should move to the next scenario.
   58|       | @constant KIFTestStepResultSuccess The step succeeded and the test controller should move to the next step in the current scenario.
   59|       | @constant KIFTestStepResultWait The test isn't ready yet and should be tried again after a short delay.
   60|       | */
   61|       |typedef NS_ENUM(NSUInteger, KIFTestStepResult) {
   62|       |    KIFTestStepResultFailure = 0,
   63|       |    KIFTestStepResultSuccess,
   64|       |    KIFTestStepResultWait,
   65|       |};
   66|       |
   67|       |/*!
   68|       | @typedef KIFTestExecutionBlock
   69|       | @param error An error to fill out in the case of a failure or wait condition. Filling out this error is mandatory in these cases to ensure that testing output is useful.
   70|       | @result A test result code. Returning KIFTestStepResultWait will cause the block to be tried again on the next iteration.
   71|       | */
   72|       |typedef KIFTestStepResult (^KIFTestExecutionBlock)(NSError **error);
   73|       |
   74|       |/*!
   75|       | @typedef KIFTestCompletionBlock
   76|       | @param result The result of the test, either KIFTestStepResultSuccess or KIFTestStepResultFailure.
   77|       | @param error An error provided by the test or nil if result is equal to KIFTestStepResultSuccess.
   78|       | */
   79|       |typedef void (^KIFTestCompletionBlock)(KIFTestStepResult result, NSError *error);
   80|       |
   81|       |@protocol KIFTestActorDelegate;
   82|       |
   83|       |@interface KIFTestActor : NSObject
   84|       |
   85|       |+ (instancetype)new NS_UNAVAILABLE;
   86|       |- (instancetype)init NS_UNAVAILABLE;
   87|       |+ (instancetype)actorInFile:(NSString *)file atLine:(NSInteger)line delegate:(id<KIFTestActorDelegate>)delegate;
   88|       |
   89|       |@property (strong, nonatomic, readonly) NSString *file;
   90|       |@property (nonatomic, readonly) NSInteger line;
   91|       |@property (weak, nonatomic, readonly) id<KIFTestActorDelegate> delegate;
   92|       |@property (nonatomic) NSTimeInterval executionBlockTimeout;
   93|       |@property (nonatomic) NSTimeInterval animationWaitingTimeout;
   94|       |@property (nonatomic) NSTimeInterval animationStabilizationTimeout;
   95|       |@property (nonatomic) NSTimeInterval mainThreadDispatchStabilizationTimeout;
   96|       |
   97|       |- (instancetype)usingTimeout:(NSTimeInterval)executionBlockTimeout;
   98|       |- (instancetype)usingAnimationWaitingTimeout:(NSTimeInterval)animationWaitingTimeout;
   99|       |- (instancetype)usingAnimationStabilizationTimeout:(NSTimeInterval)animationStabilizationTimeout;
  100|       |
  101|       |- (void)runBlock:(KIFTestExecutionBlock)executionBlock complete:(KIFTestCompletionBlock)completionBlock timeout:(NSTimeInterval)timeout;
  102|       |- (void)runBlock:(KIFTestExecutionBlock)executionBlock complete:(KIFTestCompletionBlock)completionBlock;
  103|       |- (void)runBlock:(KIFTestExecutionBlock)executionBlock timeout:(NSTimeInterval)timeout;
  104|       |- (void)runBlock:(KIFTestExecutionBlock)executionBlock;
  105|       |
  106|       |/*!
  107|       | @discussion Attempts to run the test block similar to -runBlock:complete:timeout: but does not halt the test on completion, instead returning NO on failure and providing an error description to the optional error parameter.
  108|       | */
  109|       |- (BOOL)tryRunningBlock:(KIFTestExecutionBlock)executionBlock complete:(KIFTestCompletionBlock)completionBlock timeout:(NSTimeInterval)timeout error:(out NSError **)error;
  110|       |
  111|       |/*!
  112|       | @method defaultAnimationWaitingTimeout
  113|       | @abstract The default amount of time to wait for an animation to complete.
  114|       | @discussion To change the default value of the timeout property, call +setDefaultAnimationWaitingTimeout: with a different value.
  115|       | */
  116|       |+ (NSTimeInterval)defaultAnimationWaitingTimeout;
  117|       |
  118|       |/*!
  119|       | @method setDefaultAnimationWaitingTimeout:
  120|       | @abstract Sets the default amount of time to wait for an animation to complete.
  121|       | */
  122|       |+ (void)setDefaultAnimationWaitingTimeout:(NSTimeInterval)newDefaultAnimationWaitingTimeout;
  123|       |
  124|       |/*!
  125|       | @method defaultAnimationStabilizationTimeout
  126|       | @abstract The default amount of time to wait before starting to check for animations
  127|       | @discussion To change the default value of the timeout property, call +setDefaultAnimationStabilizationTimeout: with a different value.
  128|       | */
  129|       |+ (NSTimeInterval)defaultAnimationStabilizationTimeout;
  130|       |
  131|       |/*!
  132|       | @method setDefaultAnimationStabilizationTimeout:
  133|       | @abstract Sets the amount of time to wait before starting to check for animations
  134|       | */
  135|       |+ (void)setDefaultAnimationStabilizationTimeout:(NSTimeInterval)newDefaultAnimationStabilizationTimeout;
  136|       |
  137|       |/*!
  138|       | @method defaultMainThreadDispatchStabilizationTimeout
  139|       | @abstract The default amount of time to wait for the main thread to process animations.
  140|       | @discussion To change the default value of the timeout property, call +setDefaultMainThreadDispatchStabilizationTimeout: with a different value.
  141|       | */
  142|       |+ (NSTimeInterval)defaultMainThreadDispatchStabilizationTimeout;
  143|       |
  144|       |/*!
  145|       | @method setDefaultMainThreadDispatchStabilizationTimeout:
  146|       | @abstract Sets the amount of time to wait for the main thread to process animations.
  147|       | */
  148|       |+ (void)setDefaultMainThreadDispatchStabilizationTimeout:(NSTimeInterval)newDefaultMainThreadDispatchStabilizationTimeout;
  149|       |
  150|       |/*!
  151|       | @method defaultTimeout
  152|       | @abstract The default amount of time to assign to execution blocks before assuming they failed.
  153|       | @discussion To change the default value of the timeout property, call +setDefaultTimeout: with a different value.
  154|       | */
  155|       |+ (NSTimeInterval)defaultTimeout;
  156|       |
  157|       |/*!
  158|       | @method setDefaultTimeout:
  159|       | @abstract Sets the default amount of time to assign to execution blocks before assuming they failed.
  160|       | */
  161|       |+ (void)setDefaultTimeout:(NSTimeInterval)newDefaultTimeout;
  162|       |
  163|       |/*!
  164|       | @method stepDelay
  165|       | @abstract The amount of time that execution blocks use before trying again to met desired conditions.
  166|       | @discussion To change the default value of the step delay property, call +setStepDelay: with a different value.
  167|       | */
  168|       |+ (NSTimeInterval)stepDelay;
  169|       |
  170|       |/*!
  171|       | @method setStepDelay:
  172|       | @abstract Sets the amount of time that execution blocks use before trying again to met desired conditions.
  173|       | */
  174|       |+ (void)setStepDelay:(NSTimeInterval)newStepDelay;
  175|       |
  176|       |/*!
  177|       | @abstract Fails the test.
  178|       | @discussion Mostly useful for test debugging or as a placeholder when building new tests.
  179|       | */
  180|       |- (void)fail;
  181|       |
  182|       |- (void)failWithError:(NSError *)error stopTest:(BOOL)stopTest;
  183|       |
  184|       |- (void)failWithMessage:(NSString *)message, ...;
  185|       |
  186|       |/*!
  187|       | @abstract Waits for a certain amount of time before returning.
  188|       | @discussion In general when waiting for the app to get into a known state, it's better to use -waitForTappableViewWithAccessibilityLabel:, however this step may be useful in some situations as well.
  189|       | @param timeInterval The number of seconds to wait before returning.
  190|       | */
  191|       |- (void)waitForTimeInterval:(NSTimeInterval)timeInterval;
  192|       |
  193|       |/*!
  194|       | @abstract Waits for a certain amount of time before returning.  The time delay is optionally scaled relative to the current animation speed.
  195|       | @discussion In general when waiting for the app to get into a known state, it's better to use -waitForTappableViewWithAccessibilityLabel:, however this step may be useful in some situations as well.
  196|       | @param timeInterval The number of seconds to wait before returning.
  197|       | @param scaleTime Whether to scale the timeInterval relative to the current animation speed
  198|       | */
  199|       |- (void)waitForTimeInterval:(NSTimeInterval)timeInterval relativeToAnimationSpeed:(BOOL)scaleTime;
  200|       |
  201|       |@end
  202|       |
  203|       |@protocol KIFTestActorDelegate <NSObject>
  204|       |
  205|       |- (void)failWithException:(NSException *)exception stopTest:(BOOL)stop;
  206|       |- (void)failWithExceptions:(NSArray *)exceptions stopTest:(BOOL)stop;
  207|       |
  208|       |@end
  209|       |
  210|       |@interface KIFTestActor (Delegate) <KIFTestActorDelegate>
  211|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Classes/KIFTestActor.m:
    1|       |//
    2|       |//  KIFTestActor.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Brian Nickel on 12/13/12.
    6|       |//  Licensed to Square, Inc. under one or more contributor license agreements.
    7|       |//  See the LICENSE file distributed with this work for the terms under
    8|       |//  which Square, Inc. licenses this file to you.
    9|       |
   10|       |#import <dlfcn.h>
   11|       |#import <objc/runtime.h>
   12|       |#import <XCTest/XCTest.h>
   13|       |
   14|       |#import "KIFTestActor_Private.h"
   15|       |
   16|       |#import "KIFAccessibilityEnabler.h"
   17|       |#import "KIFTextInputTraitsOverrides.h"
   18|       |#import "NSError-KIFAdditions.h"
   19|       |#import "NSException-KIFAdditions.h"
   20|       |#import "UIApplication-KIFAdditions.h"
   21|       |#import "UIView-KIFAdditions.h"
   22|       |
   23|       |@implementation KIFTestActor
   24|       |
   25|       |+ (void)load
   26|      1|{
   27|      1|    @autoreleasepool {
   28|      1|        if (NSClassFromString(@"UIApplication")) {
   29|      1|            [UIApplication swizzleRunLoop];
   30|      1|            NSLog(@"KIFTester loaded");
   31|      1|        } else {
   32|      0|            NSLog(@"KIFTester skipping runloop swizzling, no UIApplication class found.");
   33|      0|        }
   34|      1|    }
   35|      1|}
   36|       |
   37|       |- (instancetype)initWithFile:(NSString *)file line:(NSInteger)line delegate:(id<KIFTestActorDelegate>)delegate
   38|      3|{
   39|      3|    NSAssert(KIFAccessibilityEnabled(), @"The method `KIFEnableAccessibility()` hasn't been called yet. Either call it explicitly before any of your tests run, or subclass KIFTestCase to get this behavior automatically.");
   40|      3|
   41|      3|    self = [super init];
   42|      3|    if (self) {
   43|      3|        _file = file;
   44|      3|        _line = line;
   45|      3|        _delegate = delegate;
   46|      3|        _executionBlockTimeout = [[self class] defaultTimeout];
   47|      3|        _animationWaitingTimeout = [[self class] defaultAnimationWaitingTimeout];
   48|      3|        _animationStabilizationTimeout = [[self class] defaultAnimationStabilizationTimeout];
   49|      3|        _mainThreadDispatchStabilizationTimeout = [[self class] defaultMainThreadDispatchStabilizationTimeout];
   50|      3|    }
   51|      3|    return self;
   52|      3|}
   53|       |
   54|       |+ (instancetype)actorInFile:(NSString *)file atLine:(NSInteger)line delegate:(id<KIFTestActorDelegate>)delegate
   55|      3|{
   56|      3|    return [[self alloc] initWithFile:file line:line delegate:delegate];
   57|      3|}
   58|       |
   59|       |- (instancetype)usingTimeout:(NSTimeInterval)executionBlockTimeout
   60|      0|{
   61|      0|    self.executionBlockTimeout = executionBlockTimeout;
   62|      0|    return self;
   63|      0|}
   64|       |
   65|       |- (instancetype)usingAnimationWaitingTimeout:(NSTimeInterval)animationWaitingTimeout;
   66|      0|{
   67|      0|    self.animationWaitingTimeout = animationWaitingTimeout;
   68|      0|    return self;
   69|      0|}
   70|       |
   71|       |- (instancetype)usingAnimationStabilizationTimeout:(NSTimeInterval)animationStabilizationTimeout;
   72|      0|{
   73|      0|    self.animationStabilizationTimeout = animationStabilizationTimeout;
   74|      0|    return self;
   75|      0|}
   76|       |
   77|       |- (BOOL)tryRunningBlock:(KIFTestExecutionBlock)executionBlock complete:(KIFTestCompletionBlock)completionBlock timeout:(NSTimeInterval)timeout error:(out NSError **)error
   78|      3|{
   79|      3|    NSDate *startDate = [NSDate date];
   80|      3|    KIFTestStepResult result;
   81|      3|    NSError *internalError;
   82|      3|    
   83|      4|    while ((result = executionBlock(&internalError)) == KIFTestStepResultWait && -[startDate timeIntervalSinceNow] < timeout) {
   84|      1|        CFRunLoopRunInMode([[UIApplication sharedApplication] currentRunLoopMode] ?: kCFRunLoopDefaultMode, KIFTestStepDelay, false);
   85|      1|    }
   86|      3|
   87|      3|    if (result == KIFTestStepResultWait) {
   88|      0|        internalError = [NSError KIFErrorWithUnderlyingError:internalError format:@"The step timed out after %.2f seconds: %@", timeout, internalError.localizedDescription];
   89|      0|        result = KIFTestStepResultFailure;
   90|      0|    }
   91|      3|
   92|      3|    if (completionBlock) {
   93|      0|        completionBlock(result, internalError);
   94|      0|    }
   95|      3|
   96|      3|    if (error) {
   97|      3|        *error = internalError;
   98|      3|    }
   99|      3|    
  100|      3|    return result != KIFTestStepResultFailure;
  101|      3|}
  102|       |
  103|       |- (void)runBlock:(KIFTestExecutionBlock)executionBlock complete:(KIFTestCompletionBlock)completionBlock timeout:(NSTimeInterval)timeout
  104|      3|{
  105|      3|    NSError *error = nil;
  106|      3|    if (![self tryRunningBlock:executionBlock complete:completionBlock timeout:timeout error:&error]) {
  107|      0|        [self failWithError:error stopTest:YES];
  108|      0|    }
  109|      3|}
  110|       |
  111|       |- (void)runBlock:(KIFTestExecutionBlock)executionBlock complete:(KIFTestCompletionBlock)completionBlock
  112|      3|{
  113|      3|    [self runBlock:executionBlock complete:completionBlock timeout:self.executionBlockTimeout];
  114|      3|}
  115|       |
  116|       |- (void)runBlock:(KIFTestExecutionBlock)executionBlock timeout:(NSTimeInterval)timeout
  117|      0|{
  118|      0|    [self runBlock:executionBlock complete:nil timeout:timeout];
  119|      0|}
  120|       |
  121|       |- (void)runBlock:(KIFTestExecutionBlock)executionBlock
  122|      3|{
  123|      3|    [self runBlock:executionBlock complete:nil];
  124|      3|}
  125|       |
  126|       |
  127|       |#pragma mark Class Methods
  128|       |
  129|       |static NSTimeInterval KIFTestStepDefaultAnimationWaitingTimeout = 0.5;
  130|       |static NSTimeInterval KIFTestStepDefaultAnimationStabilizationTimeout = 0.5;
  131|       |static NSTimeInterval KIFTestStepDefaultMainThreadDispatchStabilizationTimeout = 0.5;
  132|       |static NSTimeInterval KIFTestStepDefaultTimeout = 10.0;
  133|       |static NSTimeInterval KIFTestStepDelay = 0.1;
  134|       |
  135|       |+ (NSTimeInterval)defaultAnimationWaitingTimeout
  136|      3|{
  137|      3|    return KIFTestStepDefaultAnimationWaitingTimeout;
  138|      3|}
  139|       |
  140|       |+ (void)setDefaultAnimationWaitingTimeout:(NSTimeInterval)newDefaultAnimationWaitingTimeout;
  141|      0|{
  142|      0|    KIFTestStepDefaultAnimationWaitingTimeout = newDefaultAnimationWaitingTimeout;
  143|      0|}
  144|       |
  145|       |+ (NSTimeInterval)defaultAnimationStabilizationTimeout
  146|      3|{
  147|      3|    return KIFTestStepDefaultAnimationStabilizationTimeout;
  148|      3|}
  149|       |
  150|       |+ (void)setDefaultAnimationStabilizationTimeout:(NSTimeInterval)newDefaultAnimationStabilizationTimeout;
  151|      0|{
  152|      0|    KIFTestStepDefaultAnimationStabilizationTimeout = newDefaultAnimationStabilizationTimeout;
  153|      0|}
  154|       |
  155|       |+ (NSTimeInterval)defaultMainThreadDispatchStabilizationTimeout
  156|      3|{
  157|      3|    return KIFTestStepDefaultMainThreadDispatchStabilizationTimeout;
  158|      3|}
  159|       |
  160|       |+ (void)setDefaultMainThreadDispatchStabilizationTimeout:(NSTimeInterval)newDefaultMainThreadDispatchStabilizationTimeout;
  161|      0|{
  162|      0|    KIFTestStepDefaultMainThreadDispatchStabilizationTimeout = newDefaultMainThreadDispatchStabilizationTimeout;
  163|      0|}
  164|       |
  165|       |
  166|       |+ (NSTimeInterval)defaultTimeout;
  167|      3|{
  168|      3|    return KIFTestStepDefaultTimeout;
  169|      3|}
  170|       |
  171|       |+ (void)setDefaultTimeout:(NSTimeInterval)newDefaultTimeout;
  172|      0|{
  173|      0|    KIFTestStepDefaultTimeout = newDefaultTimeout;
  174|      0|}
  175|       |
  176|       |+ (NSTimeInterval)stepDelay;
  177|      0|{
  178|      0|    return KIFTestStepDelay;
  179|      0|}
  180|       |
  181|       |+ (void)setStepDelay:(NSTimeInterval)newStepDelay;
  182|      0|{
  183|      0|    KIFTestStepDelay = newStepDelay;
  184|      0|}
  185|       |
  186|       |#pragma mark Generic tests
  187|       |
  188|       |- (void)fail
  189|      0|{
  190|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
  191|      0|        KIFTestCondition(NO, error, @"This test always fails");
  192|      0|    }];
  193|      0|}
  194|       |
  195|       |- (void)failWithMessage:(NSString *)message, ...;
  196|      0|{
  197|      0|    va_list args;
  198|      0|    va_start(args, message);
  199|      0|    NSString *formattedMessage = [[NSString alloc] initWithFormat:message arguments:args];
  200|      0|    NSError *error = [NSError errorWithDomain:@"KIFTest" code:KIFTestStepResultFailure userInfo:[NSDictionary dictionaryWithObjectsAndKeys:formattedMessage, NSLocalizedDescriptionKey, nil]];
  201|      0|    [self failWithError:error stopTest:YES];
  202|      0|    va_end(args);
  203|      0|}
  204|       |
  205|       |- (void)failWithError:(NSError *)error stopTest:(BOOL)stopTest
  206|      0|{
  207|      0|    [self.delegate failWithException:[NSException failureInFile:self.file atLine:(int)self.line withDescription:error.localizedDescription] stopTest:stopTest];
  208|      0|}
  209|       |
  210|       |- (void)waitForTimeInterval:(NSTimeInterval)timeInterval
  211|      0|{
  212|      0|    [self waitForTimeInterval:timeInterval relativeToAnimationSpeed:NO];
  213|      0|}
  214|       |
  215|       |- (void)waitForTimeInterval:(NSTimeInterval)timeInterval relativeToAnimationSpeed:(BOOL)scaleTime
  216|      0|{
  217|      0|    if (scaleTime) {
  218|      0|        timeInterval /= [UIApplication sharedApplication].animationSpeed;
  219|      0|    }
  220|      0|    
  221|      0|    NSTimeInterval startTime = [NSDate timeIntervalSinceReferenceDate];
  222|      0|    
  223|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
  224|      0|        KIFTestWaitCondition((([NSDate timeIntervalSinceReferenceDate] - startTime) >= timeInterval), error, @"Waiting for time interval to expire.");
  225|      0|        return KIFTestStepResultSuccess;
  226|      0|    } timeout:timeInterval + 1];
  227|      0|}
  228|       |
  229|       |@end
  230|       |
  231|       |@implementation KIFTestActor (Delegate)
  232|       |
  233|       |- (void)failWithException:(NSException *)exception stopTest:(BOOL)stop
  234|      0|{
  235|      0|    [self failWithExceptions:@[exception] stopTest:stop];
  236|      0|}
  237|       |
  238|       |- (void)failWithExceptions:(NSArray *)exceptions stopTest:(BOOL)stop
  239|      0|{
  240|      0|    NSException *firstException = [exceptions objectAtIndex:0];
  241|      0|    NSException *newException = [NSException failureInFile:self.file atLine:(int)self.line withDescription:@"Failure in child step: %@", firstException.description];
  242|      0|
  243|      0|    [self.delegate failWithExceptions:[exceptions arrayByAddingObject:newException] stopTest:stop];
  244|      0|}
  245|       |
  246|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Classes/KIFTestCase.m:
    1|       |//
    2|       |//  KIFTestCase.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Brian Nickel on 12/14/12.
    6|       |//  Licensed to Square, Inc. under one or more contributor license agreements.
    7|       |//  See the LICENSE file distributed with this work for the terms under
    8|       |//  which Square, Inc. licenses this file to you.
    9|       |
   10|       |#import "KIFTestCase.h"
   11|       |#import <UIKit/UIKit.h>
   12|       |#import "UIApplication-KIFAdditions.h"
   13|       |#import "KIFTestActor.h"
   14|       |#import "KIFAccessibilityEnabler.h"
   15|       |
   16|       |#define SIG(class, selector) [class instanceMethodSignatureForSelector:selector]
   17|       |
   18|       |@implementation KIFTestCase
   19|       |{
   20|       |    NSException *_stoppingException;
   21|       |}
   22|       |
   23|       |NSComparisonResult selectorSort(NSInvocation *invocOne, NSInvocation *invocTwo, void *reverse);
   24|       |
   25|       |+ (id)defaultTestSuite
   26|      3|{
   27|      3|    if (self == [KIFTestCase class]) {
   28|      1|        // Don't run KIFTestCase "tests"
   29|      1|        return nil;
   30|      1|    }
   31|      2|    
   32|      2|    return [super defaultTestSuite];
   33|      2|}
   34|       |
   35|       |- (id)initWithInvocation:(NSInvocation *)anInvocation;
   36|      3|{
   37|      3|    self = [super initWithInvocation:anInvocation];
   38|      3|    if (!self) {
   39|      0|        return nil;
   40|      0|    }
   41|      3|
   42|      3|    self.continueAfterFailure = NO;
   43|      3|    return self;
   44|      3|}
   45|       |
   46|      0|- (void)beforeEach { }
   47|      1|- (void)afterEach  { }
   48|      1|- (void)beforeAll  { }
   49|      1|- (void)afterAll   { }
   50|       |
   51|      0|NSComparisonResult selectorSort(NSInvocation *invocOne, NSInvocation *invocTwo, void *reverse) {
   52|      0|    
   53|      0|    NSString *selectorOne =  NSStringFromSelector([invocOne selector]);
   54|      0|    NSString *selectorTwo =  NSStringFromSelector([invocTwo selector]);
   55|      0|    return [selectorOne compare:selectorTwo options:NSCaseInsensitiveSearch];
   56|      0|}
   57|       |
   58|       |+ (NSArray *)testInvocations
   59|      2|{
   60|      2|    NSArray *disorderedInvoc = [super testInvocations];
   61|      2|    NSArray *newArray = [disorderedInvoc sortedArrayUsingFunction:selectorSort context:NULL];
   62|      2|    return newArray;
   63|      2|}
   64|       |
   65|       |+ (void)setUp
   66|      1|{
   67|      1|    KIFEnableAccessibility();
   68|      1|    [self performSetupTearDownWithSelector:@selector(beforeAll)];
   69|      1|}
   70|       |
   71|       |+ (void)tearDown
   72|      1|{
   73|      1|    [self performSetupTearDownWithSelector:@selector(afterAll)];
   74|      1|}
   75|       |
   76|       |+ (void)performSetupTearDownWithSelector:(SEL)selector
   77|      2|{
   78|      2|    KIFTestCase *testCase = [self testCaseWithSelector:selector];
   79|      2|    if ([testCase respondsToSelector:selector]) {
   80|      2|#pragma clang diagnostic push
   81|      2|#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
   82|      2|        [testCase performSelector:selector];
   83|      2|#pragma clang diagnostic pop
   84|      2|    }
   85|      2|
   86|      2|    if (testCase->_stoppingException) {
   87|      0|        [testCase->_stoppingException raise];
   88|      0|    }
   89|      2|}
   90|       |
   91|       |- (void)setUp;
   92|      0|{
   93|      0|    [super setUp];
   94|      0|    
   95|      0|    if ([self isNotBeforeOrAfter]) {
   96|      0|        [self beforeEach];
   97|      0|    }
   98|      0|}
   99|       |
  100|       |- (void)tearDown;
  101|      1|{
  102|      1|    if ([self isNotBeforeOrAfter]) {
  103|      1|        [self afterEach];
  104|      1|    }
  105|      1|    
  106|      1|    [super tearDown];
  107|      1|}
  108|       |
  109|       |- (BOOL)isNotBeforeOrAfter;
  110|      1|{
  111|      1|    SEL selector = self.invocation.selector;
  112|      1|    return selector != @selector(beforeAll) && selector != @selector(afterAll);
  113|      1|}
  114|       |
  115|       |- (void)failWithException:(NSException *)exception stopTest:(BOOL)stop
  116|      0|{
  117|      0|    if (stop) {
  118|      0|        _stoppingException = exception;
  119|      0|    }
  120|      0|    
  121|      0|    if (stop && self.stopTestsOnFirstBigFailure) {
  122|      0|        NSLog(@"Fatal failure encountered: %@", exception.description);
  123|      0|        NSLog(@"Stopping tests since stopTestsOnFirstBigFailure = YES");
  124|      0|        
  125|      0|        KIFTestActor *waiter = KIFActorWithClass(KIFTestActor);
  126|      0|        [waiter waitForTimeInterval:[[NSDate distantFuture] timeIntervalSinceNow]];
  127|      0|        
  128|      0|        return;
  129|      0|    } else {
  130|      0|        [super failWithException:exception stopTest:stop];
  131|      0|    }
  132|      0|}
  133|       |
  134|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Classes/KIFTestStepValidation.m:
    1|       |//
    2|       |//  KIFTestStepValidation.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Brian Nickel on 7/27/13.
    6|       |//
    7|       |//
    8|       |
    9|       |#import "KIFTestStepValidation.h"
   10|       |
   11|       |@implementation _MockKIFTestActorDelegate
   12|       |
   13|       |- (void)failWithException:(NSException *)exception stopTest:(BOOL)stop
   14|      0|{
   15|      0|    [self failWithExceptions:@[exception] stopTest:stop];
   16|      0|}
   17|       |
   18|       |- (void)failWithExceptions:(NSArray *)exceptions stopTest:(BOOL)stop
   19|      0|{
   20|      0|    self.failed = YES;
   21|      0|    self.exceptions = exceptions;
   22|      0|    self.stopped = stop;
   23|      0|    if (stop) {
   24|      0|        [[exceptions objectAtIndex:0] raise];
   25|      0|    }
   26|      0|}
   27|       |
   28|       |+ (instancetype)mockDelegate
   29|      0|{
   30|      0|    return [[self alloc] init];
   31|      0|}
   32|       |
   33|       |
   34|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Classes/KIFTextInputTraitsOverrides.m:
    1|       |//
    2|       |//  KIFTextInputTraitsOverrides.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Harley Cooper on 1/31/18.
    6|       |//
    7|       |
    8|       |#import <objc/runtime.h>
    9|       |#import "KIFTextInputTraitsOverrides.h"
   10|       |
   11|       |@interface KIFTextInputTraitsOverrides()
   12|       |
   13|       |/*!
   14|       | @abstract Swizzles the @c autocorrectionType property of @c UITextField and @c UITextView
   15|       | @discussion Sets the property to have default behavior when @c allowDefaultAutocorrectBehavior is set to @c YES, and always return @c UITextAutocorrectionTypeNo when it's set to no.
   16|       | */
   17|       |+ (void)KIFSwizzleTextInputFieldsAutocorrect;
   18|       |
   19|       |/*!
   20|       | @abstract Swizzles the @c smartDashesType property of @c UITextField and @c UITextView
   21|       | @discussion Sets the property to have default behavior when @c allowDefaultSmartDashesBehavior is set to @c YES, and always return @c UITextSmartDashesTypeNo when it's set to no.
   22|       | */
   23|       |+ (void)KIFSwizzleTextInputFieldsSmartDashes;
   24|       |
   25|       |/*!
   26|       | @abstract Swizzles the @c smartQuotesType property of @c UITextField and @c UITextView
   27|       | @discussion Sets the property to have default behavior when @c allowDefaultSmartQuotesBehavior is set to @c YES, and always return @c UITextSmartQuotesTypeNo when it's set to no.
   28|       | */
   29|       |+ (void)KIFSwizzleTextInputFieldsSmartQuotes;
   30|       |
   31|       |@end
   32|       |
   33|       |@implementation KIFTextInputTraitsOverrides
   34|       |
   35|       |typedef NSInteger (*send_type_uitextfield)(UITextField*, SEL);
   36|       |typedef NSInteger (*send_type_uitextview)(UITextView*, SEL);
   37|       |
   38|       |static BOOL KIFAutocorrectEnabled = NO;
   39|       |static BOOL KIFSmartDashesEnabled = NO;
   40|       |static BOOL KIFSmartQuotesEnabled = NO;
   41|       |
   42|       |+ (void)load
   43|      1|{
   44|      1|    [self KIFSwizzleTextInputFieldsAutocorrect];
   45|      1|    [self KIFSwizzleTextInputFieldsSmartDashes];
   46|      1|    [self KIFSwizzleTextInputFieldsSmartQuotes];
   47|      1|}
   48|       |
   49|       |+ (BOOL)allowDefaultAutocorrectBehavior
   50|      4|{
   51|      4|    return KIFAutocorrectEnabled;
   52|      4|}
   53|       |
   54|       |+ (void)setAllowDefaultAutocorrectBehavior:(BOOL)allowDefaultBehavior
   55|      0|{
   56|      0|    KIFAutocorrectEnabled = allowDefaultBehavior;
   57|      0|}
   58|       |
   59|       |+ (BOOL)allowDefaultSmartDashesBehavior
   60|      4|{
   61|      4|    return KIFSmartDashesEnabled;
   62|      4|}
   63|       |
   64|       |+ (void)setAllowDefaultSmartDashesBehavior:(BOOL)allowDefaultBehavior
   65|      0|{
   66|      0|    KIFSmartDashesEnabled = allowDefaultBehavior;
   67|      0|}
   68|       |
   69|       |+ (BOOL)allowDefaultSmartQuotesBehavior
   70|      4|{
   71|      4|    return KIFSmartQuotesEnabled;
   72|      4|}
   73|       |
   74|       |+ (void)setAllowDefaultSmartQuotesBehavior:(BOOL)allowDefaultBehavior
   75|      0|{
   76|      0|    KIFSmartQuotesEnabled = allowDefaultBehavior;
   77|      0|}
   78|       |
   79|       |+ (void)KIFSwizzleTextInputFieldsAutocorrect
   80|      1|{
   81|      1|    static dispatch_once_t onceToken;
   82|      1|    dispatch_once(&onceToken, ^{
   83|      1|        struct objc_method_description autocorrectionTypeMethodDescription = protocol_getMethodDescription(@protocol(UITextInputTraits), @selector(autocorrectionType), NO, YES);
   84|      1|        send_type_uitextfield autocorrectOriginalImp_textField = (send_type_uitextfield)[UITextField instanceMethodForSelector:@selector(autocorrectionType)];
   85|      1|        send_type_uitextview autocorrectOriginalImp_textView = (send_type_uitextview)[UITextView instanceMethodForSelector:@selector(autocorrectionType)];
   86|      1|
   87|      1|        IMP autocorrectImp_textView = imp_implementationWithBlock(^(UITextView *_self) {
   88|      0|            if(self.allowDefaultAutocorrectBehavior) {
   89|      0|                return autocorrectOriginalImp_textView(_self, @selector(autocorrectionType));
   90|      0|            } else {
   91|      0|                return UITextAutocorrectionTypeNo;
   92|      0|            }
   93|      0|        });
   94|      1|
   95|      4|        IMP autocorrectImp_textField = imp_implementationWithBlock(^(UITextField *_self) {
   96|      4|            if(self.allowDefaultAutocorrectBehavior) {
   97|      0|                return autocorrectOriginalImp_textField(_self, @selector(autocorrectionType));
   98|      4|            } else {
   99|      4|                return UITextAutocorrectionTypeNo;
  100|      4|            }
  101|      4|        });
  102|      1|
  103|      1|        class_replaceMethod([UITextField class], @selector(autocorrectionType), autocorrectImp_textField, autocorrectionTypeMethodDescription.types);
  104|      1|        class_replaceMethod([UITextView class], @selector(autocorrectionType), autocorrectImp_textView, autocorrectionTypeMethodDescription.types);
  105|      1|    });
  106|      1|}
  107|       |
  108|       |+ (void)KIFSwizzleTextInputFieldsSmartDashes
  109|      1|{
  110|      1|    // This #ifdef is necessary for versions of Xcode before Xcode 9.
  111|      1|#ifdef __IPHONE_11_0
  112|      1|    if (@available(iOS 11.0, *)) {
  113|      1|        static dispatch_once_t onceToken;
  114|      1|        dispatch_once(&onceToken, ^{
  115|      1|            struct objc_method_description smartDashesTypeMethodDescription = protocol_getMethodDescription(@protocol(UITextInputTraits), @selector(smartDashesType), NO, YES);
  116|      1|            send_type_uitextfield smartDashesOriginalImp_textField = (send_type_uitextfield)[UITextField instanceMethodForSelector:@selector(smartDashesType)];
  117|      1|            send_type_uitextview smartDashesOriginalImp_textView = (send_type_uitextview)[UITextView instanceMethodForSelector:@selector(smartDashesType)];
  118|      1|
  119|      4|            IMP smartDashesImp_textField = imp_implementationWithBlock(^(UITextField *_self) {
  120|      4|                if(self.allowDefaultSmartDashesBehavior) {
  121|      0|                    return smartDashesOriginalImp_textField(_self, @selector(smartQuotesType));
  122|      4|                } else {
  123|      4|                    return UITextSmartDashesTypeNo;
  124|      4|                }
  125|      4|            });
  126|      1|            IMP smartDashesImp_textView = imp_implementationWithBlock(^(UITextView *_self) {
  127|      0|                if(self.allowDefaultSmartDashesBehavior) {
  128|      0|                    return smartDashesOriginalImp_textView(_self, @selector(smartQuotesType));
  129|      0|                } else {
  130|      0|                    return UITextSmartDashesTypeNo;
  131|      0|                }
  132|      0|            });
  133|      1|
  134|      1|            class_replaceMethod([UITextField class], @selector(smartDashesType), smartDashesImp_textField, smartDashesTypeMethodDescription.types);
  135|      1|            class_replaceMethod([UITextView class], @selector(smartDashesType), smartDashesImp_textView, smartDashesTypeMethodDescription.types);
  136|      1|        });
  137|      1|    }
  138|      1|#endif
  139|      1|}
  140|       |
  141|       |+ (void)KIFSwizzleTextInputFieldsSmartQuotes
  142|      1|{
  143|      1|        // This #ifdef is necessary for versions of Xcode before Xcode 9.
  144|      1|#ifdef __IPHONE_11_0
  145|      1|        if (@available(iOS 11.0, *)) {
  146|      1|            static dispatch_once_t onceToken;
  147|      1|            dispatch_once(&onceToken, ^{
  148|      1|                struct objc_method_description smartQuotesTypeMethodDescription = protocol_getMethodDescription(@protocol(UITextInputTraits), @selector(smartQuotesType), NO, YES);
  149|      1|                send_type_uitextfield smartQuotesOriginalImp_textField = (send_type_uitextfield)[UITextField instanceMethodForSelector:@selector(smartDashesType)];
  150|      1|                send_type_uitextview smartQuotesOriginalImp_textView = (send_type_uitextview)[UITextView instanceMethodForSelector:@selector(smartDashesType)];
  151|      1|
  152|      4|                IMP smartQuotesImp_textField = imp_implementationWithBlock(^(UITextField *_self) {
  153|      4|                    if(self.allowDefaultSmartQuotesBehavior) {
  154|      0|                        return smartQuotesOriginalImp_textField(_self, @selector(smartQuotesType));
  155|      4|                    } else {
  156|      4|                        return UITextSmartQuotesTypeNo;
  157|      4|                    }
  158|      4|                });
  159|      1|                IMP smartQuotesImp_textView = imp_implementationWithBlock(^(UITextView *_self) {
  160|      0|                    if(self.allowDefaultSmartQuotesBehavior) {
  161|      0|                        return smartQuotesOriginalImp_textView(_self, @selector(smartQuotesType));
  162|      0|                    } else {
  163|      0|                        return UITextSmartQuotesTypeNo;
  164|      0|                    }
  165|      0|                });
  166|      1|
  167|      1|                class_replaceMethod([UITextField class], @selector(smartQuotesType), smartQuotesImp_textField, smartQuotesTypeMethodDescription.types);
  168|      1|                class_replaceMethod([UITextView class], @selector(smartQuotesType), smartQuotesImp_textView, smartQuotesTypeMethodDescription.types);
  169|      1|            });
  170|      1|        }
  171|      1|#endif
  172|      1|}
  173|       |
  174|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Classes/KIFTypist.m:
    1|       |//
    2|       |//  KIFTypist.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Pete Hodgson on 8/12/12.
    6|       |//  Licensed to Square, Inc. under one or more contributor license agreements.
    7|       |//  See the LICENSE file distributed with this work for the terms under
    8|       |//  which Square, Inc. licenses this file to you.
    9|       |
   10|       |#import "KIFTypist.h"
   11|       |#import "UIApplication-KIFAdditions.h"
   12|       |#import "UIView-KIFAdditions.h"
   13|       |#import "CGGeometry-KIFAdditions.h"
   14|       |#import "UIAccessibilityElement-KIFAdditions.h"
   15|       |
   16|       |@interface UIKeyboardImpl : NSObject
   17|       |+ (UIKeyboardImpl *)sharedInstance;
   18|       |- (void)addInputString:(NSString *)string;
   19|       |- (void)deleteFromInput;
   20|       |@property(getter=isInHardwareKeyboardMode) BOOL inHardwareKeyboardMode;
   21|       |@property(retain) UIResponder<UIKeyInput> * delegate;
   22|       |@end
   23|       |
   24|       |static NSTimeInterval keystrokeDelay = 0.01f;
   25|       |
   26|       |@interface KIFTypist()
   27|       |@property (nonatomic, assign) BOOL keyboardHidden;
   28|       |@end
   29|       |
   30|       |@implementation KIFTypist
   31|       |
   32|       |+ (KIFTypist *)sharedTypist
   33|      1|{
   34|      1|    static dispatch_once_t once;
   35|      1|    static KIFTypist *sharedObserver = nil;
   36|      1|    dispatch_once(&once, ^{
   37|      1|        sharedObserver = [[self alloc] init];
   38|      1|    });
   39|      1|    return sharedObserver;
   40|      1|}
   41|       |
   42|      1|+ (void)registerForNotifications {
   43|      1|    [[self sharedTypist] registerForNotifications];
   44|      1|}
   45|       |
   46|       |- (instancetype)init
   47|      1|{
   48|      1|    if ((self = [super init])) {
   49|      1|        self.keyboardHidden = YES;
   50|      1|    }
   51|      1|    return self;
   52|      1|}
   53|       |
   54|       |- (void)registerForNotifications
   55|      1|{
   56|      1|    // Instead of listening to keyboard will show/hide notifications, this is more robust. When keyboard is split
   57|      1|    // on a physical device, keyboard will show/hide notifications does not get fired, whereas this does.
   58|      1|    __weak KIFTypist *weakSelf = self;
   59|      1|    [[NSNotificationCenter defaultCenter] addObserverForName:UIKeyboardDidChangeFrameNotification
   60|      1|                                                      object:nil
   61|      1|                                                       queue:[NSOperationQueue mainQueue]
   62|      1|                                                  usingBlock:^(NSNotification *note) {
   63|      0|                                                      CGRect keyboardEndFrame =
   64|      0|                                                      [[note.userInfo objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue];
   65|      0|
   66|      0|                                                      CGRect screenRect = [[UIScreen mainScreen] bounds];
   67|      0|
   68|      0|                                                      if (CGRectIntersectsRect(keyboardEndFrame, screenRect))
   69|      0|                                                      {
   70|      0|                                                          weakSelf.keyboardHidden = NO;
   71|      0|                                                      }
   72|      0|                                                      else
   73|      0|                                                      {
   74|      0|                                                          weakSelf.keyboardHidden = YES;
   75|      0|                                                      }
   76|      0|                                                  }];
   77|      1|}
   78|       |
   79|       |+ (BOOL)keyboardHidden
   80|      0|{
   81|      0|    return [self sharedTypist].keyboardHidden;
   82|      0|}
   83|       |
   84|       |+ (BOOL)enterCharacter:(NSString *)characterString;
   85|      0|{
   86|      0|    if ([characterString isEqualToString:@"\b"]) {
   87|      0|        [[UIKeyboardImpl sharedInstance] deleteFromInput];
   88|      0|    } else {
   89|      0|        [[UIKeyboardImpl sharedInstance] addInputString:characterString];
   90|      0|    }
   91|      0|    
   92|      0|    CFRunLoopRunInMode(kCFRunLoopDefaultMode, keystrokeDelay, false);
   93|      0|    return YES;
   94|      0|}
   95|       |
   96|       |+ (NSTimeInterval)keystrokeDelay;
   97|      0|{
   98|      0|    return keystrokeDelay;
   99|      0|}
  100|       |
  101|       |+ (void)setKeystrokeDelay:(NSTimeInterval)delay
  102|      0|{
  103|      0|    keystrokeDelay = delay;
  104|      0|}
  105|       |
  106|       |+ (BOOL)hasHardwareKeyboard
  107|      0|{
  108|      0|    return [UIKeyboardImpl sharedInstance].inHardwareKeyboardMode;
  109|      0|}
  110|       |
  111|       |+ (BOOL)hasKeyInputResponder
  112|      0|{
  113|      0|    return [UIKeyboardImpl sharedInstance].delegate != nil;
  114|      0|}
  115|       |
  116|       |
  117|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Classes/KIFUIObject.m:
    1|       |//
    2|       |//  KIFUIObject.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Alex Odawa on 1/26/15.
    6|       |//
    7|       |//
    8|       |
    9|       |#import "KIFUIObject.h"
   10|       |
   11|       |
   12|       |@implementation KIFUIObject
   13|       |
   14|       |- (instancetype)initWithElement:(UIAccessibilityElement *)element view:(UIView *)view;
   15|      0|{
   16|      0|    self = [super init];
   17|      0|    if (self) {
   18|      0|        _element = element;
   19|      0|        _view = view;
   20|      0|    }
   21|      0|    return self;
   22|      0|}
   23|       |
   24|       |- (NSString *)description;
   25|      0|{
   26|      0|    return [NSString stringWithFormat:@"<%@;\n| element=%@;\n| |  view=%@>", [super description], self.element, self.view];
   27|      0|}
   28|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Classes/KIFUITestActor-ConditionalTests.m:
    1|       |//
    2|       |//  KIFUITestActor-ConditionalTests.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Brian Nickel on 7/24/14.
    6|       |//
    7|       |//
    8|       |
    9|       |#import "KIFUITestActor-ConditionalTests.h"
   10|       |#import "UIAccessibilityElement-KIFAdditions.h"
   11|       |#import "NSError-KIFAdditions.h"
   12|       |
   13|       |@implementation KIFUITestActor (ConditionalTests)
   14|       |
   15|       |- (BOOL)tryFindingViewWithAccessibilityLabel:(NSString *)label error:(out NSError **)error
   16|      0|{
   17|      0|    return [self tryFindingViewWithAccessibilityLabel:label value:nil traits:UIAccessibilityTraitNone tappable:NO error:error];
   18|      0|}
   19|       |
   20|       |- (BOOL)tryFindingViewWithAccessibilityLabel:(NSString *)label traits:(UIAccessibilityTraits)traits error:(out NSError **)error
   21|      0|{
   22|      0|    return [self tryFindingViewWithAccessibilityLabel:label value:nil traits:traits tappable:NO error:error];
   23|      0|}
   24|       |
   25|       |- (BOOL)tryFindingViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits error:(out NSError **)error
   26|      0|{
   27|      0|    return [self tryFindingViewWithAccessibilityLabel:label value:value traits:traits tappable:NO error:error];
   28|      0|}
   29|       |
   30|       |- (BOOL)tryFindingTappableViewWithAccessibilityLabel:(NSString *)label error:(out NSError **)error
   31|      0|{
   32|      0|    return [self tryFindingViewWithAccessibilityLabel:label value:nil traits:UIAccessibilityTraitNone tappable:YES error:error];
   33|      0|}
   34|       |
   35|       |- (BOOL)tryFindingTappableViewWithAccessibilityLabel:(NSString *)label traits:(UIAccessibilityTraits)traits error:(out NSError **)error
   36|      0|{
   37|      0|    return [self tryFindingViewWithAccessibilityLabel:label value:nil traits:traits tappable:YES error:error];
   38|      0|}
   39|       |
   40|       |- (BOOL)tryFindingTappableViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits error:(out NSError **)error
   41|      0|{
   42|      0|    return [self tryFindingViewWithAccessibilityLabel:label value:value traits:traits tappable:YES error:error];
   43|      0|}
   44|       |
   45|       |- (BOOL)tryFindingViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits tappable:(BOOL)mustBeTappable error:(out NSError **)error
   46|      0|{
   47|      0|    return [self tryFindingAccessibilityElement:NULL view:NULL withLabel:label value:value traits:traits tappable:mustBeTappable error:error];
   48|      0|}
   49|       |
   50|       |- (BOOL)tryFindingAccessibilityElement:(out UIAccessibilityElement * __autoreleasing *)element view:(out UIView * __autoreleasing *)view withLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits tappable:(BOOL)mustBeTappable error:(out NSError **)error
   51|      0|{
   52|      0|    return [self tryRunningBlock:^KIFTestStepResult(NSError *__autoreleasing *error) {
   53|      0|        return [UIAccessibilityElement accessibilityElement:element view:view withLabel:label value:value traits:traits tappable:mustBeTappable error:error] ? KIFTestStepResultSuccess : KIFTestStepResultWait;
   54|      0|    } complete:nil timeout:1.0 error:error];
   55|      0|}
   56|       |
   57|       |- (BOOL)tryFindingAccessibilityElement:(out UIAccessibilityElement **)element view:(out UIView **)view withIdentifier:(NSString *)identifier tappable:(BOOL)mustBeTappable error:(out NSError **)error
   58|      0|{
   59|      0|    if (![UIAccessibilityElement instancesRespondToSelector:@selector(accessibilityIdentifier)]) {
   60|      0|        [self failWithError:[NSError KIFErrorWithFormat:@"Running test on platform that does not support accessibilityIdentifier"] stopTest:YES];
   61|      0|    }
   62|      0|    
   63|      0|    return [self tryFindingAccessibilityElement:element view:view withElementMatchingPredicate:[NSPredicate predicateWithFormat:@"accessibilityIdentifier = %@", identifier] tappable:mustBeTappable error:error];
   64|      0|}
   65|       |
   66|       |- (BOOL)tryFindingAccessibilityElement:(out UIAccessibilityElement * __autoreleasing *)element view:(out UIView * __autoreleasing *)view withElementMatchingPredicate:(NSPredicate *)predicate tappable:(BOOL)mustBeTappable error:(out NSError **)error
   67|      0|{
   68|      0|    return [self tryRunningBlock:^KIFTestStepResult(NSError *__autoreleasing *error) {
   69|      0|        return [UIAccessibilityElement accessibilityElement:element view:view withElementMatchingPredicate:predicate tappable:mustBeTappable error:error] ? KIFTestStepResultSuccess : KIFTestStepResultWait;
   70|      0|    } complete:nil timeout:1.0 error:error];
   71|      0|}
   72|       |
   73|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Classes/KIFUITestActor.h:
    1|       |//
    2|       |//  KIFUITestActor.h
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Brian Nickel on 12/14/12.
    6|       |//  Licensed to Square, Inc. under one or more contributor license agreements.
    7|       |//  See the LICENSE file distributed with this work for the terms under
    8|       |//  which Square, Inc. licenses this file to you.
    9|       |
   10|       |#import "KIFTestActor.h"
   11|       |#import <UIKit/UIKit.h>
   12|       |#import "UIView-KIFAdditions.h"
   13|       |
   14|       |
   15|       |#if DEPRECATE_KIF_TESTER
   16|       |// Add `-DDEPRECATE_KIF_TESTER=1` to OTHER_CFLAGS if you'd like to prevent usage of `tester`.
   17|       |@class KIFUITestActor;
   18|       |KIFUITestActor *_KIF_tester() __attribute__((deprecated("Use of `tester` has been deprecated; Use `viewTester` instead.")));
   19|       |#define tester _KIF_tester()
   20|       |#else
   21|      0|#define tester KIFActorWithClass(KIFUITestActor)
   22|       |#endif
   23|       |
   24|       |
   25|       |/*!
   26|       | @enum KIFSwipeDirection
   27|       | @abstract Directions in which to swipe.
   28|       | @constant KIFSwipeDirectionRight Swipe to the right.
   29|       | @constant KIFSwipeDirectionLeft Swipe to the left.
   30|       | @constant KIFSwipeDirectionUp Swipe up.
   31|       | @constant KIFSwipeDirectionDown Swipe down.
   32|       | */
   33|       |typedef NS_ENUM(NSUInteger, KIFSwipeDirection) {
   34|       |    KIFSwipeDirectionRight,
   35|       |    KIFSwipeDirectionLeft,
   36|       |    KIFSwipeDirectionUp,
   37|       |    KIFSwipeDirectionDown
   38|       |};
   39|       |
   40|       |/*!
   41|       | @enum KIFPickerType
   42|       | @abstract Picker type to select values from.
   43|       | @constant KIFUIPickerView UIPickerView type
   44|       | @constant KIFUIDatePicker UIDatePicker type
   45|       | */
   46|       |typedef NS_ENUM(NSUInteger, KIFPickerType) {
   47|       |    KIFUIPickerView,
   48|       |    KIFUIDatePicker
   49|       |};
   50|       |
   51|       |/*!
   52|       | @enum KIFPickerSearchOrder
   53|       | @abstract Order in which to search picker values.
   54|       | @constant KIFPickerSearchForwardFromStart Search from first value forward.
   55|       | @constant KIFPickerSearchBackwardFromEnd Search from last value backwards.
   56|       | @constant KIFPickerSearchForwardFromCurrentValue Search from current value forward.
   57|       | @constant KIFPickerSearchBackwardFromCurrentValue Search from current value backwards.
   58|       | */
   59|       |typedef NS_ENUM(NSUInteger, KIFPickerSearchOrder) {
   60|       |    KIFPickerSearchForwardFromStart = 0,
   61|       |    KIFPickerSearchBackwardFromEnd = 1,
   62|       |    KIFPickerSearchForwardFromCurrentValue = 2,
   63|       |    KIFPickerSearchBackwardFromCurrentValue = 3
   64|       |};
   65|       |
   66|       |/*!
   67|       | @enum KIFStepperDirection
   68|       | @abstract Direction in which to increment or decrement the stepper.
   69|       | @constant KIFStepperDirectionIncrement Increment the stepper
   70|       | @constant KIFUIDatePicker Decrement the stepper
   71|       | */
   72|       |typedef NS_ENUM(NSUInteger, KIFStepperDirection) {
   73|       |	KIFStepperDirectionIncrement,
   74|       |	KIFStepperDirectionDecrement
   75|       |};
   76|       |
   77|       |/*!
   78|       | @enum KIFPullToRefreshTiming
   79|       | @discussion The approximate time in which the pull to refresh travels downward.
   80|       | @abstract Timing in which to perform the pull down before release.
   81|       | @constant KIFPullToRefreshInAboutAHalfSecond about half a second
   82|       | @constant KIFPullToRefreshInAboutOneSecond about one second
   83|       | @constant KIFPullToRefreshInAboutTwoSeconds about two seconds
   84|       | @constant KIFPullToRefreshInAboutThreeSeconds about three seconds.
   85|       | */
   86|       |typedef NS_ENUM(NSUInteger, KIFPullToRefreshTiming) {
   87|       |	KIFPullToRefreshInAboutAHalfSecond = 20, //faster
   88|       |	KIFPullToRefreshInAboutOneSecond = 100,
   89|       |	KIFPullToRefreshInAboutTwoSeconds = 150,
   90|       |	KIFPullToRefreshInAboutThreeSeconds = 200, //slower
   91|       |};
   92|       |
   93|       |@interface KIFUITestActor : KIFTestActor
   94|       |
   95|       |/*!
   96|       | @abstract Controls if typing methods will validate the entered text.
   97|       | @discussion This method will only impact the functioning of the `enterText:...` method variants.
   98|       | 
   99|       | @param validateEnteredText Whether or not to validate the entered text. Defaults to YES.
  100|       | @return The message reciever, these methods are intended to be chained together.
  101|       | */
  102|       |- (instancetype)validateEnteredText:(BOOL)validateEnteredText;
  103|       |
  104|       |/*!
  105|       | @abstract Waits until a view or accessibility element is present.
  106|       | @discussion The view or accessibility element with the given label is found in the view hierarchy. If the element isn't found, then the step will attempt to wait until it is. Note that the view does not necessarily have to be visible on the screen, and may be behind another view or offscreen. Views with their hidden property set to YES are ignored.
  107|       | 
  108|       | If the view you want to wait for is tappable, use the -waitForTappableViewWithAccessibilityLabel: methods instead as they provide a more strict test.
  109|       | @param label The accessibility label of the element to wait for.
  110|       | */
  111|       |- (UIView *)waitForViewWithAccessibilityLabel:(NSString *)label;
  112|       |
  113|       |/*!
  114|       | @abstract Waits until a view or accessibility element is present.
  115|       | @discussion The view or accessibility element with the given label is found in the view hierarchy. If the element isn't found, then the step will attempt to wait until it is. Note that the view does not necessarily have to be visible on the screen, and may be behind another view or offscreen. Views with their hidden property set to YES are ignored.
  116|       | 
  117|       | If the view you want to wait for is tappable, use the -waitForTappableViewWithAccessibilityLabel: methods instead as they provide a more strict test.
  118|       | @param label The accessibility label of the element to wait for.
  119|       | @param traits The accessibility traits of the element to wait for. Elements that do not include at least these traits are ignored.
  120|       | */
  121|       |- (UIView *)waitForViewWithAccessibilityLabel:(NSString *)label traits:(UIAccessibilityTraits)traits;
  122|       |
  123|       |/*!
  124|       | @abstract Waits until a view or accessibility element is present.
  125|       | @discussion The view or accessibility element with the given label is found in the view hierarchy. If the element isn't found, then the step will attempt to wait until it is. Note that the view does not necessarily have to be visible on the screen, and may be behind another view or offscreen. Views with their hidden property set to YES are ignored.
  126|       | 
  127|       | If the view you want to wait for is tappable, use the -waitForTappableViewWithAccessibilityLabel: methods instead as they provide a more strict test.
  128|       | @param label The accessibility label of the element to wait for.
  129|       | @param value The accessibility value of the element to tap.
  130|       | @param traits The accessibility traits of the element to wait for. Elements that do not include at least these traits are ignored.
  131|       | @result A configured test step.
  132|       | */
  133|       |- (UIView *)waitForViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits;
  134|       |
  135|       |/*!
  136|       | @abstract Waits until a view or accessibility element is no longer present.
  137|       | @discussion The view or accessibility element with the given label is found in the view hierarchy. If the element is found, then the step will attempt to wait until it isn't. Note that the view does not necessarily have to be visible on the screen, and may be behind another view or offscreen. Views with their hidden property set to YES are considered absent.
  138|       | @param label The accessibility label of the element to wait for.
  139|       | */
  140|       |- (void)waitForAbsenceOfViewWithAccessibilityLabel:(NSString *)label;
  141|       |
  142|       |/*!
  143|       | @abstract Waits until a view or accessibility element is no longer present.
  144|       | @discussion The view or accessibility element with the given label is found in the view hierarchy. If the element is found, then the step will attempt to wait until it isn't. Note that the view does not necessarily have to be visible on the screen, and may be behind another view or offscreen. Views with their hidden property set to YES are considered absent.
  145|       | @param label The accessibility label of the element to wait for.
  146|       | @param traits The accessibility traits of the element to wait for. Elements that do not include at least these traits are ignored.
  147|       | */
  148|       |- (void)waitForAbsenceOfViewWithAccessibilityLabel:(NSString *)label traits:(UIAccessibilityTraits)traits;
  149|       |
  150|       |/*!
  151|       | @abstract Waits until a view or accessibility element is no longer present.
  152|       | @discussion The view or accessibility element with the given label is found in the view hierarchy. If the element is found, then the step will attempt to wait until it isn't. Note that the view does not necessarily have to be visible on the screen, and may be behind another view or offscreen. Views with their hidden property set to YES are considered absent.
  153|       | @param label The accessibility label of the element to wait for.
  154|       | @param value The accessibility value of the element to tap.
  155|       | @param traits The accessibility traits of the element to wait for. Elements that do not include at least these traits are ignored.
  156|       | */
  157|       |- (void)waitForAbsenceOfViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits;
  158|       |
  159|       |/*!
  160|       | @abstract Waits until a view or accessibility element is present and available for tapping.
  161|       | @discussion The view or accessibility element with the given label is found in the view hierarchy. If the element isn't found or isn't currently tappable, then the step will attempt to wait until it is. Whether or not a view is tappable is based on -[UIView hitTest:].
  162|       | @param label The accessibility label of the element to wait for.
  163|       | */
  164|       |- (UIView *)waitForTappableViewWithAccessibilityLabel:(NSString *)label;
  165|       |
  166|       |/*!
  167|       | @abstract Waits until a view or accessibility element is present and available for tapping.
  168|       | @discussion The view or accessibility element with the given label is searched for in the view hierarchy. If the element isn't found or isn't currently tappable, then the step will attempt to wait until it is. Whether or not a view is tappable is based on -[UIView hitTest:].
  169|       | @param label The accessibility label of the element to wait for.
  170|       | @param traits The accessibility traits of the element to wait for. Elements that do not include at least these traits are ignored.
  171|       | */
  172|       |- (UIView *)waitForTappableViewWithAccessibilityLabel:(NSString *)label traits:(UIAccessibilityTraits)traits;
  173|       |
  174|       |/*!
  175|       | @abstract Waits until a view or accessibility element is present and available for tapping.
  176|       | @discussion The view or accessibility element with the given label is searched for in the view hierarchy. If the element isn't found or isn't currently tappable, then the step will attempt to wait until it is. Whether or not a view is tappable is based on -[UIView hitTest:].
  177|       | @param label The accessibility label of the element to wait for.
  178|       | @param value The accessibility value of the element to tap.
  179|       | @param traits The accessibility traits of the element to wait for. Elements that do not include at least these traits are ignored.
  180|       | */
  181|       |- (UIView *)waitForTappableViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits;
  182|       |
  183|       |
  184|       |/*!
  185|       | @abstract Waits for an accessibility element and its containing view based on a variety of criteria.
  186|       | @discussion This method provides a more verbose API for achieving what is available in the waitForView/waitForTappableView family of methods, exposing both the found element and its containing view.  The results can be used in other methods such as @c tapAccessibilityElement:inView:
  187|       | @param element To be populated with the matching accessibility element when found.  Can be NULL.
  188|       | @param view To be populated with the matching view when found.  Can be NULL.
  189|       | @param label The accessibility label of the element to wait for.
  190|       | @param value The accessibility value of the element to tap.
  191|       | @param traits The accessibility traits of the element to wait for. Elements that do not include at least these traits are ignored.
  192|       | @param mustBeTappable If YES, only an element that can be tapped on will be returned.
  193|       | */
  194|       |- (void)waitForAccessibilityElement:(UIAccessibilityElement **)element view:(out UIView **)view withLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits tappable:(BOOL)mustBeTappable;
  195|       |
  196|       |/*!
  197|       | @abstract Waits for an accessibility element and its containing view from specified root view based on a variety of criteria.
  198|       | @discussion This method provides a more verbose API for achieving what is available in the waitForView/waitForTappableView family of methods, exposing both the found element and its containing view.  The results can be used in other methods such as @c tapAccessibilityElement:inView:
  199|       | @param element To be populated with the matching accessibility element when found.  Can be NULL.
  200|       | @param view To be populated with the matching view when found.  Can be NULL.
  201|       | @param label The accessibility label of the element to wait for.
  202|       | @param value The accessibility value of the element to tap.
  203|       | @param traits The accessibility traits of the element to wait for. Elements that do not include at least these traits are ignored.
  204|       | @param fromView The root view to start looking for accessibility element.
  205|       | @param mustBeTappable If YES, only an element that can be tapped on will be returned.
  206|       | */
  207|       |- (void)waitForAccessibilityElement:(UIAccessibilityElement **)element view:(out UIView **)view withLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits fromRootView:(UIView *)fromView tappable:(BOOL)mustBeTappable;
  208|       |
  209|       |/*!
  210|       | @abstract Waits for an accessibility element and its containing view based the accessibility identifier.
  211|       | @discussion This method provides a more verbose API for achieving what is available in the waitForView/waitForTappableView family of methods, exposing both the found element and its containing view.  The results can be used in other methods such as @c tapAccessibilityElement:inView:
  212|       | @param element To be populated with the matching accessibility element when found.  Can be NULL.
  213|       | @param view To be populated with the matching view when found.  Can be NULL.
  214|       | @param identifier The accessibility identifier of the element to wait for.
  215|       | @param mustBeTappable If YES, only an element that can be tapped on will be returned.
  216|       | */
  217|       |- (void)waitForAccessibilityElement:(UIAccessibilityElement **)element view:(out UIView **)view withIdentifier:(NSString *)identifier tappable:(BOOL)mustBeTappable;
  218|       |
  219|       |/*!
  220|       | @abstract Waits for an accessibility element and its containing view from specified root view based the accessibility identifier.
  221|       | @discussion This method provides a more verbose API for achieving what is available in the waitForView/waitForTappableView family of methods, exposing both the found element and its containing view.  The results can be used in other methods such as @c tapAccessibilityElement:inView:
  222|       | @param element To be populated with the matching accessibility element when found.  Can be NULL.
  223|       | @param view To be populated with the matching view when found.  Can be NULL.
  224|       | @param identifier The accessibility identifier of the element to wait for.
  225|       | @param fromView The root view to start looking for accessibility element.
  226|       | @param mustBeTappable If YES, only an element that can be tapped on will be returned.
  227|       | */
  228|       |- (void)waitForAccessibilityElement:(UIAccessibilityElement **)element view:(out UIView **)view withIdentifier:(NSString *)identifier fromRootView:(UIView *)fromView tappable:(BOOL)mustBeTappable;
  229|       |
  230|       |/*!
  231|       | @abstract Waits for an accessibility element and its containing view based on a predicate.
  232|       | @discussion This method provides a more verbose API for achieving what is available in the waitForView/waitForTappableView family of methods, exposing both the found element and its containing view.  The results can be used in other methods such as @c tapAccessibilityElement:inView:
  233|       | 
  234|       | This method provides more flexability than @c waitForAccessibilityElement:view:withLabel:value:traits:tappable: but less precise error messages.  This message will tell you why the method failed but not whether or not the element met some of the criteria.
  235|       | @param element To be populated with the matching accessibility element when found.  Can be NULL.
  236|       | @param view To be populated with the matching view when found.  Can be NULL.
  237|       | @param predicate The predicate to match.
  238|       | @param mustBeTappable If YES, only an element that can be tapped on will be returned.
  239|       | */
  240|       |- (void)waitForAccessibilityElement:(UIAccessibilityElement **)element view:(out UIView **)view withElementMatchingPredicate:(NSPredicate *)predicate tappable:(BOOL)mustBeTappable;
  241|       |
  242|       |/*!
  243|       | @abstract Waits until an accessibility element is no longer present.
  244|       | @discussion The accessibility element matching the given predicate is found in the view hierarchy. If the element is found, then the step will attempt to wait until it isn't. Note that the associated view does not necessarily have to be visible on the screen, and may be behind another view or offscreen. Views with their hidden property set to YES are considered absent.
  245|       | @param predicate The predicate to match.
  246|       | */
  247|       |- (void)waitForAbsenceOfViewWithElementMatchingPredicate:(NSPredicate *)predicate;
  248|       |
  249|       |/*!
  250|       | @abstract Tries to guess if there are any unfinished animations and waits for a certain amount of time to let them finish.
  251|       | */
  252|       |- (void)waitForAnimationsToFinish;
  253|       |
  254|       |/*!
  255|       | @abstract Tries to guess if there are any unfinished animations and waits for a certain amount of time to let them finish.
  256|       | @param timeout The maximum duration the method waits to let the animations finish.
  257|       | */
  258|       |- (void)waitForAnimationsToFinishWithTimeout:(NSTimeInterval)timeout;
  259|       |
  260|       |/*!
  261|       | @abstract Tries to guess if there are any unfinished animations and waits for a certain amount of time to let them finish.
  262|       | @param timeout The maximum duration the method waits to let the animations finish.
  263|       | @param stabilizationTime The time we just sleep before attempting to detect animations
  264|       | */
  265|       |- (void)waitForAnimationsToFinishWithTimeout:(NSTimeInterval)timeout stabilizationTime:(NSTimeInterval)stabilizationTime;
  266|       |
  267|       |/*!
  268|       | @abstract Taps a particular view in the view hierarchy.
  269|       | @discussion The view or accessibility element with the given label is searched for in the view hierarchy. If the element isn't found or isn't currently tappable, then the step will attempt to wait until it is. Once the view is present and tappable, a tap event is simulated in the center of the view or element.
  270|       | @param label The accessibility label of the element to tap.
  271|       | */
  272|       |- (void)tapViewWithAccessibilityLabel:(NSString *)label;
  273|       |
  274|       |/*!
  275|       | @abstract Taps a particular view in the view hierarchy.
  276|       | @discussion The view or accessibility element with the given label is searched for in the view hierarchy. If the element isn't found or isn't currently tappable, then the step will attempt to wait until it is. Once the view is present and tappable, a tap event is simulated in the center of the view or element.
  277|       | @param label The accessibility label of the element to tap.
  278|       | @param traits The accessibility traits of the element to tap. Elements that do not include at least these traits are ignored.
  279|       | */
  280|       |- (void)tapViewWithAccessibilityLabel:(NSString *)label traits:(UIAccessibilityTraits)traits;
  281|       |
  282|       |/*!
  283|       | @abstract Taps a particular view in the view hierarchy.
  284|       | @discussion The view or accessibility element with the given label is searched for in the view hierarchy. If the element isn't found or isn't currently tappable, then the step will attempt to wait until it is. Once the view is present and tappable, a tap event is simulated in the center of the view or element.
  285|       | 
  286|       | This variation allows finding a particular instance of an accessibility element. For example, a table view might have multiple elements with the accessibility label of "Employee", but only one that also has the accessibility value of "Bob".
  287|       | @param label The accessibility label of the element to tap.
  288|       | @param value The accessibility value of the element to tap.
  289|       | @param traits The accessibility traits of the element to tap. Elements that do not include at least these traits are ignored.
  290|       | */
  291|       |- (void)tapViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits;
  292|       |
  293|       |/*!
  294|       | @abstract Taps a particular view in the view heirarchy.
  295|       | @discussion Unlike the -tapViewWithAccessibilityLabel: family of methods, this method allows you to tap an arbitrary element.  Combined with -waitForAccessibilityElement:view:withLabel:value:traits:tappable: or +[UIAccessibilityElement accessibilityElement:view:withLabel:value:traits:tappable:error:] this provides an opportunity for more complex logic.
  296|       | @param element The accessibility element to tap.
  297|       | @param view The view containing the accessibility element.
  298|       | */
  299|       |- (void)tapAccessibilityElement:(UIAccessibilityElement *)element inView:(UIView *)view;
  300|       |
  301|       |/*!
  302|       | @abstract Taps a stepper to either increment or decrement the stepper. Presumed that - (minus) to decrement is on the left.
  303|       | @discussion This will locate the left or right half of the stepper and perform a calculated click.
  304|       | @param accessibilityLabel The accessibility identifier of the view to interact with.
  305|       | @param stepperDirection The direction in which to change the value of the stepper (KIFStepperDirectionIncrement | KIFStepperDirectionDecrement)
  306|       | */
  307|       |-(void)tapStepperWithAccessibilityLabel:(NSString *)accessibilityLabel increment:(KIFStepperDirection)stepperDirection;
  308|       |
  309|       |/*!
  310|       | @abstract Taps the increment|decrement button of a UIStepper view in the view heirarchy.
  311|       | @discussion Unlike the -tapViewWithAccessibilityLabel: family of methods, this method allows you to tap an arbitrary element.  Combined with -waitForAccessibilityElement:view:withLabel:value:traits:tappable: or +[UIAccessibilityElement accessibilityElement:view:withLabel:value:traits:tappable:error:] this provides an opportunity for more complex logic.
  312|       | @param element The accessibility element to tap.
  313|       | @param view The view containing the accessibility element.
  314|       | */
  315|       |- (void)tapStepperWithAccessibilityElement:(UIAccessibilityElement *)element increment:(KIFStepperDirection)stepperDirection inView:(UIView *)view;
  316|       |
  317|       |/*!
  318|       | @abstract Taps the screen at a particular point.
  319|       | @discussion Taps the screen at a specific point. In general you should use the factory steps that tap a view based on its accessibility label, but there are situations where it's not possible to access a view using accessibility mechanisms. This step is more lenient than the steps that use the accessibility label, and does not wait for any particular view to appear, or validate that the tapped view is enabled or has interaction enabled. Because this step doesn't validate that a view is present before tapping it, it's good practice to precede this step where possible with a -waitForViewWithAccessibilityLabel: with the label for another view that should appear on the same screen.
  320|       |
  321|       | @param screenPoint The point in screen coordinates to tap. Screen points originate from the top left of the screen.
  322|       | */
  323|       |- (void)tapScreenAtPoint:(CGPoint)screenPoint;
  324|       |
  325|       |/*!
  326|       | @abstract Performs a long press on a particular view in the view hierarchy.
  327|       | @discussion The view or accessibility element with the given label is searched for in the view hierarchy. If the element isn't found or isn't currently tappable, then the step will attempt to wait until it is. Once the view is present and tappable, touch events are simulated in the center of the view or element.
  328|       | @param label The accessibility label of the element to tap.
  329|       | @param duration The length of time to long press the element.
  330|       | */
  331|       |- (void)longPressViewWithAccessibilityLabel:(NSString *)label duration:(NSTimeInterval)duration;
  332|       |
  333|       |/*!
  334|       | @abstract Performs a long press on a particular view in the view hierarchy.
  335|       | @discussion The view or accessibility element with the given label is searched for in the view hierarchy. If the element isn't found or isn't currently tappable, then the step will attempt to wait until it is. Once the view is present and tappable, touch events are simulated in the center of the view or element.
  336|       | 
  337|       | This variation allows finding a particular instance of an accessibility element. For example, a table view might have multiple elements with the accessibility label of "Employee", but only one that also has the accessibility value of "Bob".
  338|       | @param label The accessibility label of the element to tap.
  339|       | @param value The accessibility value of the element to tap.
  340|       | @param duration The length of time to long press the element.
  341|       | */
  342|       |- (void)longPressViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value duration:(NSTimeInterval)duration;
  343|       |
  344|       |- (void)longPressAccessibilityElement:(UIAccessibilityElement *)element inView:(UIView *)view duration:(NSTimeInterval)duration;
  345|       |
  346|       |/*!
  347|       | @abstract Performs a long press on a particular view in the view hierarchy.
  348|       | @discussion The view or accessibility element with the given label is searched for in the view hierarchy. If the element isn't found or isn't currently tappable, then the step will attempt to wait until it is. Once the view is present and tappable, touch events are simulated in the center of the view or element.
  349|       | 
  350|       | This variation allows finding a particular instance of an accessibility element. For example, a table view might have multiple elements with the accessibility label of "Employee", but only one that also has the accessibility value of "Bob".
  351|       | @param label The accessibility label of the element to tap.
  352|       | @param value The accessibility value of the element to tap.
  353|       | @param traits The accessibility traits of the element to tap. Elements that do not include at least these traits are ignored.
  354|       | @param duration The length of time to long press the element.
  355|       | */
  356|       |- (void)longPressViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits duration:(NSTimeInterval)duration;
  357|       |
  358|       |
  359|       |/*!
  360|       | @abstract Waits for the software keyboard to be visible.
  361|       | @discussion If input is also possible from a hardare keyboard @c waitForKeyInputReady may be more appropriate.
  362|       | */
  363|       |- (void)waitForSoftwareKeyboard;
  364|       |- (void)waitForKeyboard KIF_DEPRECATED("Use waitForSoftwareKeyboard or waitForKeyInputReady.");
  365|       |
  366|       |/*!
  367|       | @abstract If present, waits for the software keyboard to dismiss.
  368|       | */
  369|       |- (void)waitForAbsenceOfSoftwareKeyboard;
  370|       |- (void)waitForAbsenceOfKeyboard KIF_DEPRECATED("Use waitForAbscenseOfSoftwareKeyboard.");
  371|       |
  372|       |/*!
  373|       | @abstract Waits for the keyboard to be ready for input.  This tests whether or not a hardware or software keyboard is available and if the keyboard has a responder to send events to.
  374|       | */
  375|       |- (void)waitForKeyInputReady;
  376|       |
  377|       |/*!
  378|       | @abstract Enters text into a the current first responder.
  379|       | @discussion Text is entered into the view by simulating taps on the appropriate keyboard keys if the keyboard is already displayed. Useful to enter text in UIWebViews or components with no accessibility labels.
  380|       | @param text The text to enter.
  381|       | */
  382|       |- (void)enterTextIntoCurrentFirstResponder:(NSString *)text;
  383|       |- (void)enterTextIntoCurrentFirstResponder:(NSString *)text fallbackView:(UIView *)fallbackView;
  384|       |
  385|       |/*!
  386|       | @abstract Enters text into a particular view in the view hierarchy.
  387|       | @discussion If the element isn't currently tappable, then the step will attempt to wait until it is. Once the view is present and tappable, a tap event is simulated in the center of the view or element, then text is entered into the view by simulating taps on the appropriate keyboard keys.
  388|       | @param text The text to enter.
  389|       | @param expectedResult What the text value should be after entry, including any formatting done by the field. If this is nil, the "text" parameter will be used.
  390|       | @param element the element to type into.
  391|       | @param view the view to type into.
  392|       | */
  393|       |- (void)enterText:(NSString *)text intoElement:(UIAccessibilityElement *)element inView:(UIView *)view expectedResult:(NSString *)expectedResult;
  394|       |
  395|       |/*!
  396|       | @abstract Enters text into a particular view in the view hierarchy.
  397|       | @discussion The view or accessibility element with the given label is searched for in the view hierarchy. If the element isn't found or isn't currently tappable, then the step will attempt to wait until it is. Once the view is present and tappable, a tap event is simulated in the center of the view or element, then text is entered into the view by simulating taps on the appropriate keyboard keys.
  398|       | @param text The text to enter.
  399|       | @param label The accessibility label of the element to type into.
  400|       | */
  401|       |- (void)enterText:(NSString *)text intoViewWithAccessibilityLabel:(NSString *)label;
  402|       |
  403|       |/*!
  404|       | @abstract Enters text into a particular view in the view hierarchy.
  405|       | @discussion The view or accessibility element with the given label is searched for in the view hierarchy. If the element isn't found or isn't currently tappable, then the step will attempt to wait until it is. Once the view is present and tappable, a tap event is simulated in the center of the view or element, then text is entered into the view by simulating taps on the appropriate keyboard keys.
  406|       | @param text The text to enter.
  407|       | @param label The accessibility label of the element to type into.
  408|       | @param traits The accessibility traits of the element to type into. Elements that do not include at least these traits are ignored.
  409|       | @param expectedResult What the text value should be after entry, including any formatting done by the field. If this is nil, the "text" parameter will be used.
  410|       | */
  411|       |- (void)enterText:(NSString *)text intoViewWithAccessibilityLabel:(NSString *)label traits:(UIAccessibilityTraits)traits expectedResult:(NSString *)expectedResult;
  412|       |
  413|       |- (void)clearTextFromFirstResponder;
  414|       |- (void)clearTextFromViewWithAccessibilityLabel:(NSString *)label;
  415|       |- (void)clearTextFromViewWithAccessibilityLabel:(NSString *)label traits:(UIAccessibilityTraits)traits;
  416|       |- (void)clearTextFromElement:(UIAccessibilityElement *)element inView:(UIView *)view;
  417|       |
  418|       |- (void)clearTextFromAndThenEnterTextIntoCurrentFirstResponder:(NSString *)text;
  419|       |- (void)clearTextFromAndThenEnterText:(NSString *)text intoViewWithAccessibilityLabel:(NSString *)label;
  420|       |- (void)clearTextFromAndThenEnterText:(NSString *)text intoViewWithAccessibilityLabel:(NSString *)label traits:(UIAccessibilityTraits)traits expectedResult:(NSString *)expectedResult;
  421|       |
  422|       |/*!
  423|       | @abstract Sets text into a particular view in the view hierarchy. No animation nor typing simulation.
  424|       | @discussion The view or accessibility element with the given label is searched for in the view hierarchy. If the element isn't found or isn't currently tappable, then the step will attempt to wait until it is. Once the view is present and tappable, then text is set on the view. Does not result in first responder changes. Does not perform expected result validation.
  425|       | @param text The text to set.
  426|       | @param label The accessibility label of the element to set the text on.
  427|       | */
  428|       |- (void)setText:(NSString *)text intoViewWithAccessibilityLabel:(NSString *)label;
  429|       |
  430|       |/*!
  431|       | @abstract Gets text from a given label/text field/text view
  432|       | @param view The view to get the text from
  433|       | @returns Text from the given label/text field/text view
  434|       | */
  435|       |- (NSString *)textFromView:(UIView *)view;
  436|       |
  437|       |- (void)expectView:(UIView *)view toContainText:(NSString *)expectedResult;
  438|       |
  439|       |/*!
  440|       | @abstract Selects an item from a currently visible picker view.
  441|       | @discussion With a picker view already visible, this step will find an item with the given title, select that item, and tap the Done button.
  442|       | @param title The title of the row to select.
  443|       | */
  444|       |- (void)selectPickerViewRowWithTitle:(NSString *)title;
  445|       |
  446|       |/*!
  447|       | @abstract Selects an item from a currently visible picker view in specified component.
  448|       | @discussion With a picker view already visible, this step will find an item with the given title in given component, select that item, and tap the Done button.
  449|       | @param title The title of the row to select.
  450|       | @param component The component tester inteds to select the title in.
  451|       | */
  452|       |- (void)selectPickerViewRowWithTitle:(NSString *)title inComponent:(NSInteger)component;
  453|       |
  454|       |/*!
  455|       | @abstract Selects an item from a currently visible picker view in specified component and in the specified order to search the value it selects.
  456|       | @discussion With a picker view already visible, this step will find an item with the given title in given component, according to the search order specified, select that item, and tap the Done button. This is helpful when it is important to select values from specific location. Example: if minimum date is set, values from the start will be invalid for selection and result will be unexpected. KIFPickerSearchOrder helps solving this by specifing the search order.
  457|       | @param title The title of the row to select.
  458|       | @param component The component tester inteds to select the title in.
  459|       | @param searchOrder The order in which the values are being searched for selection in each compotent.
  460|       | */
  461|       |- (void)selectPickerViewRowWithTitle:(NSString *)title inComponent:(NSInteger)component withSearchOrder:(KIFPickerSearchOrder)searchOrder;
  462|       |
  463|       |/*!
  464|       | @abstract Selects a value from a currently visible date picker view.
  465|       | @discussion With a date picker view already visible, this step will select the different rotating wheel values in order of how the array parameter is passed in. After it is done it will hide the date picker. It works with all 4 UIDatePickerMode* modes. The input parameter of type NSArray has to match in what order the date picker is displaying the values/columns. So if the locale is changing the input parameter has to be adjusted. Example: Mode: UIDatePickerModeDate, Locale: en_US, Input param: NSArray *date = @[@"June", @"17", @"1965"];. Example: Mode: UIDatePickerModeDate, Locale: de_DE, Input param: NSArray *date = @[@"17.", @"Juni", @"1965".
  466|       | @param datePickerColumnValues Each element in the NSArray represents a rotating wheel in the date picker control. Elements from 0 - n are listed in the order of the rotating wheels, left to right.
  467|       | */
  468|       |- (void)selectDatePickerValue:(NSArray *)datePickerColumnValues;
  469|       |
  470|       |/*!
  471|       | @abstract Selects a value from a currently visible date picker view, according to the search order specified.
  472|       | @discussion With a date picker view already visible, this step will select the different rotating wheel values in order of how the array parameter is passed in. Each value will be searched according to the search order provided. After it is done it will hide the date picker. It works with all 4 UIDatePickerMode* modes. The input parameter of type NSArray has to match in what order the date picker is displaying the values/columns. So if the locale is changing the input parameter has to be adjusted. Example: Mode: UIDatePickerModeDate, Locale: en_US, Input param: NSArray *date = @[@"June", @"17", @"1965"];. Example: Mode: UIDatePickerModeDate, Locale: de_DE, Input param: NSArray *date = @[@"17.", @"Juni", @"1965".
  473|       | @param datePickerColumnValues Each element in the NSArray represents a rotating wheel in the date picker control. Elements from 0 - n are listed in the order of the rotating wheels, left to right.
  474|       | @param searchOrder The order in which the values are being searched for selection in each compotent.
  475|       | */
  476|       |- (void)selectDatePickerValue:(NSArray *)datePickerColumnValues withSearchOrder:(KIFPickerSearchOrder)searchOrder;
  477|       |
  478|       |/*!
  479|       | @abstract Toggles a UISwitch into a specified position.
  480|       | @discussion The UISwitch with the given label is searched for in the view hierarchy. If the element isn't found or isn't currently tappable, then the step will attempt to wait until it is. Once the view is present, the step will return if it's already in the desired position. If the switch is tappable but not in the desired position, a tap event is simulated in the center of the view or element, toggling the switch into the desired position.
  481|       | @param switchIsOn The desired position of the UISwitch.
  482|       | @param label The accessibility label of the element to switch.
  483|       | */
  484|       |- (void)setOn:(BOOL)switchIsOn forSwitchWithAccessibilityLabel:(NSString *)label;
  485|       |
  486|       |/*!
  487|       | @abstract Toggles a UISwitch into a specified position.
  488|       | @discussion If the Switch isn't currently tappable, then the step will attempt to wait until it is. Once the view is present, the step will return if it's already in the desired position. If the switch is tappable but not in the desired position, a tap event is simulated in the center of the view or element, toggling the switch into the desired position.
  489|       | @param switchIsOn The desired position of the UISwitch.
  490|       | @param switchView The switch to switch.
  491|       | @param element The accessibility element for the switch.
  492|       |
  493|       | */
  494|       |- (void)setSwitch:(UISwitch *)switchView element:(UIAccessibilityElement *)element On:(BOOL)switchIsOn;
  495|       |
  496|       |/*!
  497|       | @abstract Slides a UISlider to a specified value.
  498|       | @discussion The UISlider with the given label is searched for in the view hierarchy. If the element isn't found or isn't currently tappable, then the step will attempt to wait until it is. Once the view is present, the step will attempt to drag the slider to the new value.  The step will fail if it finds a view with the given accessibility label that is not a UISlider or if value is outside of the possible values.  Because this step simulates drag events, the value reached may not be the exact value requested and the app may ignore the touch events if the movement is less than the drag gesture recognizer's minimum distance.
  499|       | @param value The desired value of the UISlider.
  500|       | @param label The accessibility label of the element to drag.
  501|       | */
  502|       |- (void)setValue:(float)value forSliderWithAccessibilityLabel:(NSString *)label;
  503|       |- (void)setValue:(float)value forSlider:(UISlider *)slider;
  504|       |
  505|       |/*!
  506|       | @abstract Dismisses a popover on screen.
  507|       | @discussion With a popover up, tap at the top-left corner of the screen.
  508|       | */
  509|       |- (void)dismissPopover;
  510|       |
  511|       |/*!
  512|       | @abstract Select a certain photo from the built in photo picker.
  513|       | @discussion This set of steps expects that the photo picker has been initiated and that the sheet is up. From there it will tap the "Choose Photo" button and select the desired photo.
  514|       | @param albumName The name of the album to select the photo from. (1-indexed)
  515|       | @param row The row number in the album for the desired photo. (1-indexed)
  516|       | @param column The column number in the album for the desired photo.
  517|       | */
  518|       |- (void)choosePhotoInAlbum:(NSString *)albumName atRow:(NSInteger)row column:(NSInteger)column;
  519|       |
  520|       |/*!
  521|       | @abstract Taps the row at indexPath in a table view with the given label.
  522|       | @discussion This step will get the view with the specified accessibility label and tap the row at indexPath.
  523|       | 
  524|       | For cases where you may need to work from the end of a table view rather than the beginning, negative sections count back from the end of the table view (-1 is the last section) and negative rows count back from the end of the section (-1 is the last row for that section).
  525|       | 
  526|       | @param tableViewLabel Accessibility label of the table view.
  527|       | @param indexPath Index path of the row to tap.
  528|       | */
  529|       |- (void)tapRowInTableViewWithAccessibilityLabel:(NSString *)tableViewLabel atIndexPath:(NSIndexPath *)indexPath KIF_DEPRECATED("Use tapRowAtIndexPath:inTableViewWithAccessibilityIdentifier:");
  530|       |
  531|       |/*!
  532|       | @abstract Taps the row at indexPath in a table view with the given identifier.
  533|       | @discussion This step will get the view with the specified accessibility identifier and tap the row at indexPath.
  534|       | 
  535|       | For cases where you may need to work from the end of a table view rather than the beginning, negative sections count back from the end of the table view (-1 is the last section) and negative rows count back from the end of the section (-1 is the last row for that section).
  536|       | 
  537|       | @param indexPath Index path of the row to tap.
  538|       | @param identifier Accessibility identifier of the table view.
  539|       | */
  540|       |- (void)tapRowAtIndexPath:(NSIndexPath *)indexPath inTableViewWithAccessibilityIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(5_0);
  541|       |
  542|       |/*!
  543|       | @abstract Taps the row at indexPath in a given table view.
  544|       | @discussion This step will tap the row at indexPath.
  545|       | 
  546|       | For cases where you may need to work from the end of a table view rather than the beginning, negative sections count back from the end of the table view (-1 is the last section) and negative rows count back from the end of the section (-1 is the last row for that section).
  547|       | 
  548|       | @param indexPath Index path of the row to tap.
  549|       | @param tableView UITableView containing row to tap.
  550|       | */
  551|       |- (void)tapRowAtIndexPath:(NSIndexPath *)indexPath inTableView:(UITableView *)tableView;
  552|       |
  553|       |/*!
  554|       | @abstract Taps the item at indexPath in a collection view with the given identifier.
  555|       | @discussion This step will get the view with the specified accessibility identifier and tap the item at indexPath.
  556|       | 
  557|       | For cases where you may need to work from the end of a collection view rather than the beginning, negative sections count back from the end of the collection view (-1 is the last section) and negative items count back from the end of the section (-1 is the last item for that section).
  558|       | 
  559|       | @param indexPath Index path of the item to tap.
  560|       | @param identifier Accessibility identifier of the collection view.
  561|       | */
  562|       |- (void)tapItemAtIndexPath:(NSIndexPath *)indexPath inCollectionViewWithAccessibilityIdentifier:(NSString *)identifier;
  563|       |
  564|       |/*!
  565|       | @abstract Taps the item at indexPath in a given collection view.
  566|       | @discussion This step will get the view with the specified accessibility identifier and tap the item at indexPath.
  567|       | 
  568|       | For cases where you may need to work from the end of a collection view rather than the beginning, negative sections count back from the end of the collection view (-1 is the last section) and negative items count back from the end of the section (-1 is the last item for that section).
  569|       | 
  570|       | @param indexPath Index path of the item to tap.
  571|       | @param collectionView the UICollectionView containing the item.
  572|       | */
  573|       |- (void)tapItemAtIndexPath:(NSIndexPath *)indexPath inCollectionView:(UICollectionView *)collectionView;
  574|       |
  575|       |#if TARGET_IPHONE_SIMULATOR
  576|       |/*!
  577|       | @abstract If present, dismisses a system alert with the last button, usually 'Allow'. Returns YES if a dialog was dismissed, NO otherwise.
  578|       | @discussion Use this to dissmiss a location services authorization dialog or a photos access dialog by tapping the 'Allow' button. No action is taken if no alert is present.
  579|       | */
  580|       |- (BOOL)acknowledgeSystemAlert;
  581|       |
  582|       |/*!
  583|       | @abstract If present, dismisses a system alert with the button at the given index, if any exists, usually 'Allow'. Returns YES if a dialog was dismissed, NO otherwise.
  584|       | @discussion Use this to dissmiss a location services authorization dialog or a photos access dialog by tapping a button at the specified index. No action is taken if no alert is present.
  585|       |*/
  586|       |- (BOOL)acknowledgeSystemAlertWithIndex:(NSUInteger)index;
  587|       |
  588|       |#endif
  589|       |
  590|       |/*!
  591|       | @abstract Swipes a particular view in the view hierarchy in the given direction.
  592|       | @discussion The view will get the view with the specified accessibility label and swipe the screen in the given direction from the view's center.
  593|       | @param label The accessibility label of the view to swipe.
  594|       | @param direction The direction in which to swipe.
  595|       | */
  596|       |- (void)swipeViewWithAccessibilityLabel:(NSString *)label inDirection:(KIFSwipeDirection)direction;
  597|       |
  598|       |/*!
  599|       | @abstract Swipes a particular view in the view hierarchy in the given direction.
  600|       | @discussion The view will get the view with the specified accessibility label and swipe the screen in the given direction from the view's center.
  601|       | @param label The accessibility label of the view to swipe.
  602|       | @param value The accessibility value of the view to swipe.
  603|       | @param direction The direction in which to swipe.
  604|       | */
  605|       |- (void)swipeViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value inDirection:(KIFSwipeDirection)direction;
  606|       |
  607|       |/*!
  608|       | @abstract Swipes a particular view in the view hierarchy in the given direction.
  609|       | @discussion This step will get the view with the specified accessibility label and swipe the screen in the given direction from the view's center.
  610|       | @param label The accessibility label of the view to swipe.
  611|       | @param value The accessibility value of the view to swipe.
  612|       | @param traits The accessibility traits of the view to swipe. Elements that do not include at least these traits are ignored.
  613|       | @param direction The direction in which to swipe.
  614|       | */
  615|       |- (void)swipeViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits inDirection:(KIFSwipeDirection)direction;
  616|       |
  617|       |/*!
  618|       | @abstract Swipes a particular view in the view heirarchy.
  619|       | @discussion Unlike the -swipeViewWithAccessibilityLabel: family of methods, this method allows you to swipe an arbitrary element.  Combined with -waitForAccessibilityElement:view:withLabel:value:traits:tappable: or +[UIAccessibilityElement accessibilityElement:view:withLabel:value:traits:tappable:error:] this provides an opportunity for more complex logic.
  620|       | @param element The accessibility element of the view to swipe.
  621|       | @param viewToSwipe The view containing the accessibility element.
  622|       | */
  623|       |- (void)swipeAccessibilityElement:(UIAccessibilityElement *)element inView:(UIView *)viewToSwipe inDirection:(KIFSwipeDirection)direction;
  624|       |
  625|       |/*!
  626|       | @abstract Pulls down on the view that enables the pull to refresh.
  627|       | @discussion This will enact the pull to refresh by pulling down the distance of 1/2 the height of the view found by the accessibility label.
  628|       | @param label The accessibility label of the view to swipe.
  629|       | @param pullDownDuration The enum describing the approximate time for the pull down to travel the entire distance
  630|       | */
  631|       |- (void)pullToRefreshViewWithAccessibilityLabel:(NSString *)label pullDownDuration:(KIFPullToRefreshTiming) pullDownDuration;
  632|       |
  633|       |/*!
  634|       | @abstract Pulls down on the view that enables the pull to refresh.
  635|       | @discussion This will enact the pull to refresh by pulling down the distance of 1/2 the height of the view found by the accessibility label.
  636|       | @param label The accessibility label of the view to swipe.
  637|       | @param value The accessibility value of the view to swipe.
  638|       | */
  639|       |- (void)pullToRefreshViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value;
  640|       |
  641|       |/*!
  642|       | @abstract Pulls down on the view that enables the pull to refresh.
  643|       | @discussion This will enact the pull to refresh by pulling down the distance of 1/2 the height of the view found by the accessibility label.
  644|       | @param element The accessibility element to perform the pull down on.
  645|       | @param viewToSwipe The view containing the accessibility element.
  646|       | @param pullDownDuration The enum describing the approximate time for the pull down to travel the entire distance
  647|       | */
  648|       |- (void)pullToRefreshAccessibilityElement:(UIAccessibilityElement *)element inView:(UIView *)viewToSwipe pullDownDuration:(KIFPullToRefreshTiming) pullDownDuration;
  649|       |
  650|       |/*!
  651|       | @abstract Scrolls a particular view in the view hierarchy by an amount indicated as a fraction of its size.
  652|       | @discussion The view will get the view with the specified accessibility label and scroll it by the indicated fraction of its size, with the scroll centered on the center of the view.
  653|       | @param label The accessibility label of the view to scroll.
  654|       | @param horizontalFraction The horizontal displacement of the scroll action, as a fraction of the width of the view.
  655|       | @param verticalFraction The vertical displacement of the scroll action, as a fraction of the height of the view.
  656|       | */
  657|       |- (void)scrollViewWithAccessibilityLabel:(NSString *)label byFractionOfSizeHorizontal:(CGFloat)horizontalFraction vertical:(CGFloat)verticalFraction KIF_DEPRECATED("Use scrollViewWithAccessibilityIdentifier:byFractionOfSizeHorizontal:vertical:");
  658|       |
  659|       |/*!
  660|       | @abstract Scrolls a particular view in the view hierarchy by an amount indicated as a fraction of its size.
  661|       | @discussion The view will get the view with the specified accessibility identifier and scroll it by the indicated fraction of its size, with the scroll centered on the center of the view.
  662|       | @param identifier The accessibility identifier of the view to scroll.
  663|       | @param horizontalFraction The horizontal displacement of the scroll action, as a fraction of the width of the view.
  664|       | @param verticalFraction The vertical displacement of the scroll action, as a fraction of the height of the view.
  665|       | */
  666|       |- (void)scrollViewWithAccessibilityIdentifier:(NSString *)identifier byFractionOfSizeHorizontal:(CGFloat)horizontalFraction vertical:(CGFloat)verticalFraction NS_AVAILABLE_IOS(5_0);
  667|       |
  668|       |/*!
  669|       | @abstract Scrolls a particular view in the view hierarchy by an amount indicated as a fraction of its size.
  670|       | @discussion The view will scroll by the indicated fraction of its size, with the scroll centered on the center of the view.
  671|       | @param element The accessibility element of the view to scroll.
  672|       | @param viewToScroll the view to scroll.
  673|       | @param horizontalFraction The horizontal displacement of the scroll action, as a fraction of the width of the view.
  674|       | @param verticalFraction The vertical displacement of the scroll action, as a fraction of the height of the view.
  675|       | */
  676|       |- (void)scrollAccessibilityElement:(UIAccessibilityElement *)element inView:(UIView *)viewToScroll byFractionOfSizeHorizontal:(CGFloat)horizontalFraction vertical:(CGFloat)verticalFraction;
  677|       |
  678|       |/*!
  679|       | @abstract Waits until a view or accessibility element is the first responder.
  680|       | @discussion The first responder is found by searching the view hierarchy of the application's
  681|       | main window and its accessibility label is compared to the given value. If they match, the
  682|       | step returns success else it will attempt to wait until they do.
  683|       | @param label The accessibility label of the element to wait for.
  684|       | */
  685|       |- (void)waitForFirstResponderWithAccessibilityLabel:(NSString *)label;
  686|       |
  687|       |/*!
  688|       | @abstract Waits until a view or accessibility element is the first responder.
  689|       | @discussion The first responder is found by searching the view hierarchy of the application's
  690|       | main window and its accessibility label is compared to the given value. If they match, the
  691|       | step returns success else it will attempt to wait until they do.
  692|       | @param label The accessibility label of the element to wait for.
  693|       | @param traits The accessibility traits of the element to wait for. Elements that do not include at least these traits are ignored.
  694|       | */
  695|       |- (void)waitForFirstResponderWithAccessibilityLabel:(NSString *)label traits:(UIAccessibilityTraits)traits;
  696|       |
  697|       |- (void)tapStatusBar;
  698|       |
  699|       |/*!
  700|       | @abstract Scrolls a table view with the given identifier while waiting for the cell at the given indexPath to appear.
  701|       | @discussion This step will get the view with the specified accessibility identifier and then get the cell at the indexPath.
  702|       | 
  703|       | By default, scrolls to the middle of the cell. If you need to scroll to top/bottom, use the @c atPosition: variation.
  704|       | For cases where you may need to work from the end of a table view rather than the beginning, negative sections count back from the end of the table view (-1 is the last section) and negative rows count back from the end of the section (-1 is the last row for that section).
  705|       | 
  706|       | @param indexPath Index path of the cell.
  707|       | @param identifier Accessibility identifier of the table view.
  708|       | @result Table view cell at index path
  709|       | */
  710|       |- (UITableViewCell *)waitForCellAtIndexPath:(NSIndexPath *)indexPath inTableViewWithAccessibilityIdentifier:(NSString *)identifier;
  711|       |
  712|       |/*!
  713|       | @abstract Scrolls a table view with the given identifier while waiting for the cell at the given indexPath to appear.
  714|       | @discussion This step will get the view with the specified accessibility identifier and then get the cell at the indexPath.
  715|       | 
  716|       | For cases where you may need to work from the end of a table view rather than the beginning, negative sections count back from the end of the table view (-1 is the last section) and negative rows count back from the end of the section (-1 is the last row for that section).
  717|       | 
  718|       | @param indexPath Index path of the cell.
  719|       | @param identifier Accessibility identifier of the table view.
  720|       | @param position Table View scroll position to scroll to. Useful for tall cells when the content needed is in a specific location.
  721|       | @result Table view cell at index path
  722|       | */
  723|       |- (UITableViewCell *)waitForCellAtIndexPath:(NSIndexPath *)indexPath inTableViewWithAccessibilityIdentifier:(NSString *)identifier atPosition:(UITableViewScrollPosition)position;
  724|       |
  725|       |/*!
  726|       | @abstract Scrolls a table view while waiting for the cell at the given indexPath to appear.
  727|       | @discussion This step will get the cell at the indexPath.
  728|       | 
  729|       | By default, scrolls to the middle of the cell. If you need to scroll to top/bottom, use the @c atPosition: variation.
  730|       | For cases where you may need to work from the end of a table view rather than the beginning, negative sections count back from the end of the table view (-1 is the last section) and negative rows count back from the end of the section (-1 is the last row for that section).
  731|       | 
  732|       | @param indexPath Index path of the cell.
  733|       | @param tableView UITableView containing the cell.
  734|       | @result Table view cell at index path
  735|       | */
  736|       |- (UITableViewCell *)waitForCellAtIndexPath:(NSIndexPath *)indexPath inTableView:(UITableView *)tableView;
  737|       |
  738|       |/*!
  739|       | @abstract Scrolls a table view while waiting for the cell at the given indexPath to appear.
  740|       | @discussion This step will get the cell at the indexPath.
  741|       | 
  742|       | For cases where you may need to work from the end of a table view rather than the beginning, negative sections count back from the end of the table view (-1 is the last section) and negative rows count back from the end of the section (-1 is the last row for that section).
  743|       | 
  744|       | @param indexPath Index path of the cell.
  745|       | @param tableView UITableView containing the cell.
  746|       | @param position Table View scroll position to scroll to. Useful for tall cells when the content needed is in a specific location.
  747|       | @result Table view cell at index path
  748|       | */
  749|       |- (UITableViewCell *)waitForCellAtIndexPath:(NSIndexPath *)indexPath inTableView:(UITableView *)tableView atPosition:(UITableViewScrollPosition)position;
  750|       |
  751|       |/*!
  752|       | @abstract Scrolls a collection view while waiting for the cell at the given indexPath to appear.
  753|       | @discussion This step will get the cell at the indexPath.
  754|       | 
  755|       | For cases where you may need to work from the end of a table view rather than the beginning, negative sections count back from the end of the table view (-1 is the last section) and negative rows count back from the end of the section (-1 is the last row for that section).
  756|       | 
  757|       | @param indexPath Index path of the cell.
  758|       | @param collectionView UICollectionView containing the cell.
  759|       | @result Collection view cell at index path
  760|       | */
  761|       |- (UICollectionViewCell *)waitForCellAtIndexPath:(NSIndexPath *)indexPath inCollectionView:(UICollectionView *)collectionView;
  762|       |
  763|       |
  764|       |/*!
  765|       | @abstract Scrolls a given collection view while waiting for the item at the given indexPath to appear.
  766|       | @discussion This step will get the view with the specified accessibility identifier and then get the cell at indexPath.
  767|       | 
  768|       | For cases where you may need to work from the end of a collection view rather than the beginning, negative sections count back from the end of the collection view (-1 is the last section) and negative items count back from the end of the section (-1 is the last item for that section).
  769|       | 
  770|       | @param indexPath Index path of the item to tap.
  771|       | @param identifier Accessibility identifier of the collection view.
  772|       | @result Collection view cell at index path
  773|       | */
  774|       |- (UICollectionViewCell *)waitForCellAtIndexPath:(NSIndexPath *)indexPath inCollectionViewWithAccessibilityIdentifier:(NSString *)identifier;
  775|       |
  776|       |/*!
  777|       | @abstract Moves the row at sourceIndexPath to destinationIndexPath in a table view with the given identifier.
  778|       | @discussion This step will get the view with the specified accessibility identifier and move the row at sourceIndexPath to destinationIndexPath.
  779|       | 
  780|       | For cases where you may need to work from the end of a table view rather than the beginning, negative sections count back from the end of the table view (-1 is the last section) and negative rows count back from the end of the section (-1 is the last row for that section).
  781|       | 
  782|       | @param sourceIndexPath Index path of the row to move.
  783|       | @param destinationIndexPath Desired final index path of the row after moving.
  784|       | @param identifier Accessibility identifier of the table view.
  785|       | */
  786|       |- (void)moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath inTableViewWithAccessibilityIdentifier:(NSString *)identifier;
  787|       |
  788|       |/*!
  789|       | @abstract Moves the row at sourceIndexPath to destinationIndexPath in a given table view.
  790|       | @discussion This step will move the row at sourceIndexPath to destinationIndexPath.
  791|       | 
  792|       | For cases where you may need to work from the end of a table view rather than the beginning, negative sections count back from the end of the table view (-1 is the last section) and negative rows count back from the end of the section (-1 is the last row for that section).
  793|       | 
  794|       | @param sourceIndexPath Index path of the row to move.
  795|       | @param destinationIndexPath Desired final index path of the row after moving.
  796|       | @param tableView UITableView containing the cell.
  797|       | */
  798|       |- (void)moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath inTableView:(UITableView *)tableView;
  799|       |
  800|       |/*!
  801|       | @abstract Swipes the row at indexPath in the given direction.
  802|       | @param indexPath Index path of the row to swipe.
  803|       | @param tableView Table view to operate on.
  804|       | @param direction Direction of the swipe.
  805|       |*/
  806|       |- (void)swipeRowAtIndexPath:(NSIndexPath *)indexPath inTableView:(UITableView *)tableView inDirection:(KIFSwipeDirection)direction;
  807|       |
  808|       |/*!
  809|       | @abstract Waits for the given cell to transition to the delete state. Useful when swiping left on a cell for delete action.
  810|       | @param cell Cell to wait for delete state on.
  811|       | */
  812|       |- (void)waitForDeleteStateForCell:(UITableViewCell*)cell;
  813|       |
  814|       |/*!
  815|       | @abstract Waits for the given cell to transition to the delete state. Useful when swiping left on a cell for delete action.
  816|       | @param indexPath Index path of the row to wait for the delete state on.
  817|       | @param tableView Table view to operate on.
  818|       | */
  819|       |- (void)waitForDeleteStateForCellAtIndexPath:(NSIndexPath*)indexPath inTableView:(UITableView*)tableView;
  820|       |
  821|       |/*!
  822|       | @abstract Backgrounds app using UIAutomation command, simulating pressing the Home button
  823|       | @param duration Amount of time for a background event before the app becomes active again
  824|       | */
  825|       |- (void)deactivateAppForDuration:(NSTimeInterval)duration KIF_DEPRECATED("Use [system deactivateAppForDuration:] instead.");
  826|       |
  827|       |/*!
  828|       | @method testActorAnimationsEnabled
  829|       | @abstract Flag to disable/enable animations done by the UITestActor, by default this value is YES. This doesn't affect animations performed by the app being tested.
  830|       | @discussion To change the default value of this flag, call +setTestActorAnimationsEnabled: with a different value.
  831|       | */
  832|       |+ (BOOL)testActorAnimationsEnabled;
  833|       |
  834|       |/*!
  835|       | @method setTestActorAnimationsEnabled:
  836|       | @abstract Sets the flag value to enable or disable animations done by the UITestActor.
  837|       | */
  838|       |+ (void)setTestActorAnimationsEnabled:(BOOL)animationsEnabled;
  839|       |
  840|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Classes/KIFUITestActor.m:
    1|       |//
    2|       |//  KIFTester+UI.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Brian Nickel on 12/14/12.
    6|       |//  Licensed to Square, Inc. under one or more contributor license agreements.
    7|       |//  See the LICENSE file distributed with this work for the terms under
    8|       |//  which Square, Inc. licenses this file to you.
    9|       |
   10|       |#import "KIFUITestActor.h"
   11|       |
   12|       |#import "CALayer-KIFAdditions.h"
   13|       |#import "CGGeometry-KIFAdditions.h"
   14|       |#import "KIFSystemTestActor.h"
   15|       |#import "KIFTestActor_Private.h"
   16|       |#import "KIFTypist.h"
   17|       |#import "NSError-KIFAdditions.h"
   18|       |#import "UIAccessibilityElement-KIFAdditions.h"
   19|       |#import "UIApplication-KIFAdditions.h"
   20|       |#import "UIAutomationHelper.h"
   21|       |#import "UIScreen+KIFAdditions.h"
   22|       |#import "UITableView-KIFAdditions.h"
   23|       |#import "UIView-KIFAdditions.h"
   24|       |#import "UIWindow-KIFAdditions.h"
   25|       |
   26|      0|#define kKIFMinorSwipeDisplacement 5
   27|       |
   28|       |
   29|       |#if DEPRECATE_KIF_TESTER
   30|       |KIFUITestActor *_KIF_tester()
   31|       |{
   32|       |    NSCAssert(NO, @"Attempting to use deprecated `KIFUITestActor`!");
   33|       |    return nil;
   34|       |}
   35|       |#endif
   36|       |
   37|       |
   38|       |@interface KIFUITestActor ()
   39|       |
   40|       |@property (nonatomic, assign) BOOL validateEnteredText;
   41|       |
   42|       |@end
   43|       |
   44|       |static BOOL KIFUITestActorAnimationsEnabled = YES;
   45|       |
   46|       |@implementation KIFUITestActor
   47|       |
   48|       |+ (void)initialize
   49|      1|{
   50|      1|    if (self == [KIFUITestActor class]) {
   51|      1|        [KIFTypist registerForNotifications];
   52|      1|    }
   53|      1|}
   54|       |
   55|       |- (instancetype)initWithFile:(NSString *)file line:(NSInteger)line delegate:(id<KIFTestActorDelegate>)delegate;
   56|      3|{
   57|      3|    self = [super initWithFile:file line:line delegate:delegate];
   58|      3|    NSParameterAssert(self);
   59|      3|    _validateEnteredText = YES;
   60|      3|    return self;
   61|      3|}
   62|       |
   63|       |- (instancetype)validateEnteredText:(BOOL)validateEnteredText;
   64|      0|{
   65|      0|    self.validateEnteredText = validateEnteredText;
   66|      0|    return self;
   67|      0|}
   68|       |
   69|       |- (UIView *)waitForViewWithAccessibilityLabel:(NSString *)label
   70|      0|{
   71|      0|    return [self waitForViewWithAccessibilityLabel:label value:nil traits:UIAccessibilityTraitNone tappable:NO];
   72|      0|}
   73|       |
   74|       |- (UIView *)waitForViewWithAccessibilityLabel:(NSString *)label traits:(UIAccessibilityTraits)traits
   75|      3|{
   76|      3|    return [self waitForViewWithAccessibilityLabel:label value:nil traits:traits tappable:NO];
   77|      3|}
   78|       |
   79|       |- (UIView *)waitForViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits
   80|      0|{
   81|      0|    return [self waitForViewWithAccessibilityLabel:label value:value traits:traits tappable:NO];
   82|      0|}
   83|       |
   84|       |- (UIView *)waitForTappableViewWithAccessibilityLabel:(NSString *)label
   85|      0|{
   86|      0|    return [self waitForViewWithAccessibilityLabel:label value:nil traits:UIAccessibilityTraitNone tappable:YES];
   87|      0|}
   88|       |
   89|       |- (UIView *)waitForTappableViewWithAccessibilityLabel:(NSString *)label traits:(UIAccessibilityTraits)traits
   90|      0|{
   91|      0|    return [self waitForViewWithAccessibilityLabel:label value:nil traits:traits tappable:YES];
   92|      0|}
   93|       |
   94|       |- (UIView *)waitForTappableViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits
   95|      0|{
   96|      0|    return [self waitForViewWithAccessibilityLabel:label value:value traits:traits tappable:YES];
   97|      0|}
   98|       |
   99|       |- (UIView *)waitForViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits tappable:(BOOL)mustBeTappable
  100|      3|{
  101|      3|    UIView *view = nil;
  102|      3|    @autoreleasepool
  103|      3|    {
  104|      3|        [self waitForAccessibilityElement:NULL view:&view withLabel:label value:value traits:traits tappable:mustBeTappable];
  105|      3|    }
  106|      3|
  107|      3|    return view;
  108|      3|}
  109|       |
  110|       |- (void)waitForAccessibilityElement:(UIAccessibilityElement * __autoreleasing *)element view:(out UIView * __autoreleasing *)view withLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits tappable:(BOOL)mustBeTappable
  111|      3|{
  112|      4|    [self runBlock:^KIFTestStepResult(NSError **error) {
  113|      4|        return [UIAccessibilityElement accessibilityElement:element view:view withLabel:label value:value traits:traits tappable:mustBeTappable error:error] ? KIFTestStepResultSuccess : KIFTestStepResultWait;
  114|      4|    }];
  115|      3|}
  116|       |
  117|       |- (void)waitForAccessibilityElement:(UIAccessibilityElement * __autoreleasing *)element view:(out UIView * __autoreleasing *)view withLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits fromRootView:(UIView *)fromView tappable:(BOOL)mustBeTappable
  118|      0|{
  119|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
  120|      0|        return [UIAccessibilityElement accessibilityElement:element view:view withLabel:label value:value traits:traits fromRootView:fromView tappable:mustBeTappable error:error];
  121|      0|    }];
  122|      0|}
  123|       |
  124|       |- (void)waitForAccessibilityElement:(UIAccessibilityElement **)element view:(out UIView **)view withIdentifier:(NSString *)identifier tappable:(BOOL)mustBeTappable
  125|      0|{
  126|      0|    if (![UIAccessibilityElement instancesRespondToSelector:@selector(accessibilityIdentifier)]) {
  127|      0|        [self failWithError:[NSError KIFErrorWithFormat:@"Running test on platform that does not support accessibilityIdentifier"] stopTest:YES];
  128|      0|    }
  129|      0|
  130|      0|    [self waitForAccessibilityElement:element view:view withElementMatchingPredicate:[NSPredicate predicateWithFormat:@"accessibilityIdentifier = %@", identifier] tappable:mustBeTappable];
  131|      0|}
  132|       |
  133|       |- (void)waitForAccessibilityElement:(UIAccessibilityElement *__autoreleasing *)element view:(out UIView *__autoreleasing *)view withIdentifier:(NSString *)identifier fromRootView:(UIView *)fromView tappable:(BOOL)mustBeTappable
  134|      0|{
  135|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
  136|      0|        return [UIAccessibilityElement accessibilityElement:element view:view withElementMatchingPredicate:[NSPredicate predicateWithFormat:@"accessibilityIdentifier = %@", identifier] fromRootView:fromView tappable:mustBeTappable error:error] ? KIFTestStepResultSuccess : KIFTestStepResultWait;
  137|      0|    }];
  138|      0|}
  139|       |
  140|       |- (void)waitForAccessibilityElement:(UIAccessibilityElement * __autoreleasing *)element view:(out UIView * __autoreleasing *)view withElementMatchingPredicate:(NSPredicate *)predicate tappable:(BOOL)mustBeTappable
  141|      0|{
  142|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
  143|      0|        return [UIAccessibilityElement accessibilityElement:element view:view withElementMatchingPredicate:predicate tappable:mustBeTappable error:error] ? KIFTestStepResultSuccess : KIFTestStepResultWait;
  144|      0|    }];
  145|      0|}
  146|       |
  147|       |- (void)waitForAbsenceOfViewWithAccessibilityLabel:(NSString *)label
  148|      0|{
  149|      0|    [self waitForAbsenceOfViewWithAccessibilityLabel:label traits:UIAccessibilityTraitNone];
  150|      0|}
  151|       |
  152|       |- (void)waitForAbsenceOfViewWithAccessibilityLabel:(NSString *)label traits:(UIAccessibilityTraits)traits
  153|      0|{
  154|      0|    [self waitForAbsenceOfViewWithAccessibilityLabel:label value:nil traits:traits];
  155|      0|}
  156|       |
  157|       |- (void)waitForAbsenceOfViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits
  158|      0|{
  159|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
  160|      0|        // If the app is ignoring interaction events, then wait before doing our analysis
  161|      0|        KIFTestWaitCondition(![[UIApplication sharedApplication] isIgnoringInteractionEvents], error, @"Application is ignoring interaction events.");
  162|      0|        
  163|      0|        // If the element can't be found, then we're done
  164|      0|        UIAccessibilityElement *element = [[UIApplication sharedApplication] accessibilityElementWithLabel:label accessibilityValue:value traits:traits];
  165|      0|        if (!element) {
  166|      0|            return KIFTestStepResultSuccess;
  167|      0|        }
  168|      0|        
  169|      0|        UIView *view = [UIAccessibilityElement viewContainingAccessibilityElement:element];
  170|      0|        
  171|      0|        // If we found an element, but it's not associated with a view, then something's wrong. Wait it out and try again.
  172|      0|        KIFTestWaitCondition(view, error, @"Cannot find view containing accessibility element with the label \"%@\"", label);
  173|      0|
  174|      0|        // Hidden views count as absent
  175|      0|        KIFTestWaitCondition([view isHidden] || [view superview] == nil, error, @"Accessibility element %@ with label \"%@\" is visible and not hidden.", view, label);
  176|      0|        
  177|      0|        return KIFTestStepResultSuccess;
  178|      0|    }];
  179|      0|}
  180|       |
  181|      0|- (void)waitForAbsenceOfViewWithElementMatchingPredicate:(NSPredicate *)predicate {
  182|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
  183|      0|        // If the app is ignoring interaction events, then wait before doing our analysis
  184|      0|        KIFTestWaitCondition(![[UIApplication sharedApplication] isIgnoringInteractionEvents], error, @"Application is ignoring interaction events.");
  185|      0|
  186|      0|        // If the element can't be found, then we're done
  187|      0|        UIAccessibilityElement *element = nil;
  188|      0|        if (![UIAccessibilityElement accessibilityElement:&element view:NULL withElementMatchingPredicate:predicate tappable:NO error:NULL]) {
  189|      0|            return KIFTestStepResultSuccess;
  190|      0|        }
  191|      0|
  192|      0|        UIView *view = [UIAccessibilityElement viewContainingAccessibilityElement:element];
  193|      0|
  194|      0|        // If we found an element, but it's not associated with a view, then something's wrong. Wait it out and try again.
  195|      0|        KIFTestWaitCondition(view, error, @"Cannot find view containing accessibility element with the predicate \"%@\"", predicate);
  196|      0|
  197|      0|        // Hidden views count as absent
  198|      0|        KIFTestWaitCondition([view isHidden] || [view superview] == nil, error, @"Accessibility element with predicate \"%@\" is visible and not hidden.", predicate);
  199|      0|
  200|      0|        return KIFTestStepResultSuccess;
  201|      0|    }];
  202|      0|}
  203|       |
  204|      0|- (void)waitForAnimationsToFinish {
  205|      0|    [self waitForAnimationsToFinishWithTimeout:self.animationWaitingTimeout];
  206|      0|}
  207|       |
  208|      0|- (void)waitForAnimationsToFinishWithTimeout:(NSTimeInterval)timeout {
  209|      0|    [self waitForAnimationsToFinishWithTimeout:timeout stabilizationTime:self.animationStabilizationTimeout];
  210|      0|}
  211|       |
  212|      0|- (void)waitForAnimationsToFinishWithTimeout:(NSTimeInterval)timeout stabilizationTime:(NSTimeInterval)stabilizationTime {
  213|      0|    [self waitForAnimationsToFinishWithTimeout:timeout stabilizationTime:stabilizationTime mainThreadDispatchStabilizationTime:self.mainThreadDispatchStabilizationTimeout];
  214|      0|}
  215|       |
  216|      0|- (void)waitForAnimationsToFinishWithTimeout:(NSTimeInterval)timeout stabilizationTime:(NSTimeInterval)stabilizationTime mainThreadDispatchStabilizationTime:(NSTimeInterval)mainThreadDispatchStabilizationTime {
  217|      0|    NSTimeInterval maximumWaitingTimeInterval = timeout;
  218|      0|    if (maximumWaitingTimeInterval <= stabilizationTime) {
  219|      0|        if(maximumWaitingTimeInterval >= 0) {
  220|      0|            [self waitForTimeInterval:maximumWaitingTimeInterval relativeToAnimationSpeed:YES];
  221|      0|        }
  222|      0|    } else {
  223|      0|    
  224|      0|        // Wait for the view to stabilize and give them a chance to start animations before we wait for them.
  225|      0|        [self waitForTimeInterval:stabilizationTime relativeToAnimationSpeed:YES];
  226|      0|        maximumWaitingTimeInterval -= stabilizationTime;
  227|      0|
  228|      0|        NSTimeInterval startTime = [NSDate timeIntervalSinceReferenceDate];
  229|      0|        [self runBlock:^KIFTestStepResult(NSError **error) {
  230|      0|            __block BOOL runningAnimationFound = false;
  231|      0|            for (UIWindow *window in [UIApplication sharedApplication].windowsWithKeyWindow) {
  232|      0|                [window performBlockOnDescendentViews:^(UIView *view, BOOL *stop) {
  233|      0|                    BOOL isViewVisible = [view isVisibleInViewHierarchy];   // do not wait for animations of views that aren't visible
  234|      0|                    BOOL hasUnfinishedSystemAnimation = [NSStringFromClass(view.class) isEqualToString:@"_UIParallaxDimmingView"];  // indicates that the view-hierarchy is in an in-between-state of an animation
  235|      0|                    if (isViewVisible && ([view.layer hasAnimations] || hasUnfinishedSystemAnimation)) {
  236|      0|                        runningAnimationFound = YES;
  237|      0|                        if (stop != NULL) {
  238|      0|                            *stop = YES;
  239|      0|                        }
  240|      0|                        return;
  241|      0|                    }
  242|      0|                }];
  243|      0|            }
  244|      0|
  245|      0|            if (runningAnimationFound) {
  246|      0|                BOOL hasTimeRemainingToWait = ([NSDate timeIntervalSinceReferenceDate] - startTime) < maximumWaitingTimeInterval;
  247|      0|                if (hasTimeRemainingToWait) {
  248|      0|                    return KIFTestStepResultWait;
  249|      0|                } else {
  250|      0|                    // Animations appear to still exist, but we've hit our time limit
  251|      0|                    return KIFTestStepResultSuccess;
  252|      0|                }
  253|      0|            }
  254|      0|
  255|      0|            return KIFTestStepResultSuccess;
  256|      0|        } timeout:maximumWaitingTimeInterval + 1];
  257|      0|    }
  258|      0|
  259|      0|    /*
  260|      0|     *  On very rare occasions, a race condition can occur where a touch event enqueued on the main queue runloop will
  261|      0|     *  execute before the UI element it's intended to tap has appeared onscreen. KIF can then potentially send UI tap
  262|      0|     *  events to a view while it's still in the process of animating.
  263|      0|     *  By enqueuing a task on the main thread and spinning a runloop until its execution before the end of
  264|      0|     *  waitForAnimationsToFinishWithTimeout, we should be able to avoid this race condition.
  265|      0|     */
  266|      0|
  267|      0|    if(mainThreadDispatchStabilizationTime > 0) {
  268|      0|        __block BOOL waitForRunloopTaskToProcess = NO;
  269|      0|
  270|      0|        NSTimeInterval startOfMainDispatchQueueStabilization = [NSDate timeIntervalSinceReferenceDate];
  271|      0|        dispatch_async(dispatch_get_main_queue(), ^{
  272|      0|            waitForRunloopTaskToProcess = YES;
  273|      0|        });
  274|      0|
  275|      0|        [self runBlock:^KIFTestStepResult(NSError *__autoreleasing *error) {
  276|      0|            NSTimeInterval elapsedTime = [NSDate timeIntervalSinceReferenceDate] - startOfMainDispatchQueueStabilization;
  277|      0|            if(!waitForRunloopTaskToProcess) {
  278|      0|                if(elapsedTime < mainThreadDispatchStabilizationTime) {
  279|      0|                    return KIFTestStepResultWait;
  280|      0|                } else {
  281|      0|                    // The main thread is still blocked, but we've hit our time limit
  282|      0|                    NSLog(@"WARN: Main thread still blocked while waiting %fs after animations completed!", mainThreadDispatchStabilizationTime);
  283|      0|                    return KIFTestStepResultSuccess;
  284|      0|                }
  285|      0|            }
  286|      0|
  287|      0|            if(elapsedTime > mainThreadDispatchStabilizationTime) {
  288|      0|                NSLog(@"WARN: Main thread was blocked for more than %fs after animations completed!", stabilizationTime);
  289|      0|            }
  290|      0|
  291|      0|            return KIFTestStepResultSuccess;
  292|      0|        } timeout:mainThreadDispatchStabilizationTime + 1];
  293|      0|    }
  294|      0|}
  295|       |
  296|       |- (void)tapViewWithAccessibilityLabel:(NSString *)label
  297|      0|{
  298|      0|    [self tapViewWithAccessibilityLabel:label value:nil traits:UIAccessibilityTraitNone];
  299|      0|}
  300|       |
  301|       |- (void)tapViewWithAccessibilityLabel:(NSString *)label traits:(UIAccessibilityTraits)traits
  302|      0|{
  303|      0|    [self tapViewWithAccessibilityLabel:label value:nil traits:traits];
  304|      0|}
  305|       |
  306|       |- (void)tapViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits
  307|      0|{
  308|      0|    @autoreleasepool
  309|      0|    {
  310|      0|        UIView *view = nil;
  311|      0|        UIAccessibilityElement *element = nil;
  312|      0|        [self waitForAccessibilityElement:&element view:&view withLabel:label value:value traits:traits tappable:YES];
  313|      0|        [self tapAccessibilityElement:element inView:view];
  314|      0|    }
  315|      0|}
  316|       |
  317|       |- (void)tapAccessibilityElement:(UIAccessibilityElement *)element inView:(UIView *)view
  318|      0|{
  319|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
  320|      0|        
  321|      0|        KIFTestWaitCondition(view.isUserInteractionActuallyEnabled, error, @"View is not enabled for interaction: %@", view);
  322|      0|
  323|      0|        CGPoint tappablePointInElement = [self tappablePointInElement:element andView:view];
  324|      0|        
  325|      0|        // This is mostly redundant of the test in _accessibilityElementWithLabel:
  326|      0|        KIFTestWaitCondition(!isnan(tappablePointInElement.x), error, @"View is not tappable: %@", view);
  327|      0|        
  328|      0|        NSOperatingSystemVersion iOS9 = {9, 0, 0};
  329|      0|        BOOL isOperatingSystemAtLeastVersion9 = [NSProcessInfo instancesRespondToSelector:@selector(isOperatingSystemAtLeastVersion:)] && [[NSProcessInfo new] isOperatingSystemAtLeastVersion:iOS9];
  330|      0|        if (isOperatingSystemAtLeastVersion9 && [NSStringFromClass([view class]) isEqualToString:@"_UIAlertControllerActionView"]) {
  331|      0|            [view longPressAtPoint:tappablePointInElement duration:0.1];
  332|      0|        } else {
  333|      0|            [view tapAtPoint:tappablePointInElement];
  334|      0|        }
  335|      0|        
  336|      0|        return KIFTestStepResultSuccess;
  337|      0|    }];
  338|      0|
  339|      0|    // Controls might not synchronously become first-responders. Sometimes custom controls
  340|      0|    // may need to spin the runloop before reporting as the first responder.
  341|      0|    [self runBlock:^KIFTestStepResult(NSError *__autoreleasing *error) {
  342|      0|        KIFTestWaitCondition(![view canBecomeFirstResponder] || [view isDescendantOfFirstResponder], error, @"Failed to make the view into the first responder: %@", view);
  343|      0|        return KIFTestStepResultSuccess;
  344|      0|    } timeout:0.5];
  345|      0|
  346|      0|    [self waitForAnimationsToFinish];
  347|      0|}
  348|       |
  349|       |- (void)tapScreenAtPoint:(CGPoint)screenPoint
  350|      0|{
  351|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
  352|      0|        
  353|      0|        // Try all the windows until we get one back that actually has something in it at the given point
  354|      0|        UIView *view = nil;
  355|      0|        for (UIWindow *window in [[[UIApplication sharedApplication] windowsWithKeyWindow] reverseObjectEnumerator]) {
  356|      0|            CGPoint windowPoint = [window convertPoint:screenPoint fromView:nil];
  357|      0|            view = [window hitTest:windowPoint withEvent:nil];
  358|      0|            
  359|      0|            // If we hit the window itself, then skip it.
  360|      0|            if (view != window && view != nil) {
  361|      0|                break;
  362|      0|            }
  363|      0|        }
  364|      0|        
  365|      0|        KIFTestWaitCondition(view, error, @"No view was found at the point %@", NSStringFromCGPoint(screenPoint));
  366|      0|        
  367|      0|        // This is mostly redundant of the test in _accessibilityElementWithLabel:
  368|      0|        CGPoint viewPoint = [view convertPoint:screenPoint fromView:nil];
  369|      0|        [view tapAtPoint:viewPoint];
  370|      0|        
  371|      0|        return KIFTestStepResultSuccess;
  372|      0|    }];
  373|      0|}
  374|       |
  375|       |- (void)longPressViewWithAccessibilityLabel:(NSString *)label duration:(NSTimeInterval)duration;
  376|      0|{
  377|      0|    [self longPressViewWithAccessibilityLabel:label value:nil traits:UIAccessibilityTraitNone duration:duration];
  378|      0|}
  379|       |
  380|       |- (void)longPressViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value duration:(NSTimeInterval)duration;
  381|      0|{
  382|      0|    [self longPressViewWithAccessibilityLabel:label value:value traits:UIAccessibilityTraitNone duration:duration];
  383|      0|}
  384|       |
  385|       |- (void)longPressViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits duration:(NSTimeInterval)duration;
  386|      0|{
  387|      0|    @autoreleasepool
  388|      0|    {
  389|      0|        UIView *view = nil;
  390|      0|        UIAccessibilityElement *element = nil;
  391|      0|        [self waitForAccessibilityElement:&element view:&view withLabel:label value:value traits:traits tappable:YES];
  392|      0|        [self longPressAccessibilityElement:element inView:view duration:duration];
  393|      0|    }
  394|      0|}
  395|       |
  396|       |- (void)longPressAccessibilityElement:(UIAccessibilityElement *)element inView:(UIView *)view duration:(NSTimeInterval)duration;
  397|      0|{
  398|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
  399|      0|        
  400|      0|        KIFTestWaitCondition(view.isUserInteractionActuallyEnabled, error, @"View is not enabled for interaction: %@", view);
  401|      0|
  402|      0|        CGPoint tappablePointInElement = [self tappablePointInElement:element andView:view];
  403|      0|        
  404|      0|        // This is mostly redundant of the test in _accessibilityElementWithLabel:
  405|      0|        KIFTestWaitCondition(!isnan(tappablePointInElement.x), error, @"View is not tappable: %@", view);
  406|      0|        [view longPressAtPoint:tappablePointInElement duration:duration];
  407|      0|        
  408|      0|        KIFTestCondition(![view canBecomeFirstResponder] || [view isDescendantOfFirstResponder], error, @"Failed to make the view into the first responder: %@", view);
  409|      0|        
  410|      0|        return KIFTestStepResultSuccess;
  411|      0|    }];
  412|      0|
  413|      0|    // Wait for view to settle.
  414|      0|    [self waitForTimeInterval:0.5 relativeToAnimationSpeed:YES];
  415|      0|}
  416|       |
  417|       |- (void)waitForKeyboard
  418|      0|{
  419|      0|    [self waitForSoftwareKeyboard];
  420|      0|}
  421|       |
  422|       |- (void)waitForSoftwareKeyboard
  423|      0|{
  424|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
  425|      0|        KIFTestWaitCondition(![KIFTypist keyboardHidden], error, @"Keyboard is not visible");
  426|      0|        
  427|      0|        return KIFTestStepResultSuccess;
  428|      0|    }];
  429|      0|}
  430|       |
  431|       |- (void)waitForAbsenceOfKeyboard
  432|      0|{
  433|      0|    [self waitForAbsenceOfSoftwareKeyboard];
  434|      0|}
  435|       |
  436|       |- (void)waitForAbsenceOfSoftwareKeyboard
  437|      0|{
  438|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
  439|      0|        KIFTestWaitCondition([KIFTypist keyboardHidden], error, @"Keyboard is visible");
  440|      0|        
  441|      0|        return KIFTestStepResultSuccess;
  442|      0|    }];
  443|      0|}
  444|       |
  445|       |- (void)waitForKeyInputReady
  446|      0|{
  447|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
  448|      0|        KIFTestWaitCondition(![KIFTypist keyboardHidden] || [KIFTypist hasHardwareKeyboard], error, @"No software or hardware keyboard.");
  449|      0|        KIFTestWaitCondition([KIFTypist hasKeyInputResponder], error, @"No responder for key inputs.");
  450|      0|        
  451|      0|        return KIFTestStepResultSuccess;
  452|      0|    }];
  453|      0|}
  454|       |
  455|       |- (void)enterTextIntoCurrentFirstResponder:(NSString *)text
  456|      0|{
  457|      0|    [self waitForKeyInputReady];
  458|      0|    [self enterTextIntoCurrentFirstResponder:text fallbackView:nil];
  459|      0|}
  460|       |
  461|       |- (void)enterTextIntoCurrentFirstResponder:(NSString *)text fallbackView:(UIView *)fallbackView
  462|      0|{
  463|      0|    [text enumerateSubstringsInRange:NSMakeRange(0, text.length)
  464|      0|                             options:NSStringEnumerationByComposedCharacterSequences
  465|      0|                          usingBlock: ^(NSString *characterString,NSRange substringRange,NSRange enclosingRange,BOOL * stop)
  466|      0|    {
  467|      0|        if (![KIFTypist enterCharacter:characterString]) {
  468|      0|            // Attempt to cheat if we couldn't find the character
  469|      0|            UIView * fallback = fallbackView;
  470|      0|            if (!fallback) {
  471|      0|                UIResponder *firstResponder = [[[UIApplication sharedApplication] keyWindow] firstResponder];
  472|      0|
  473|      0|                if ([firstResponder isKindOfClass:[UIView class]]) {
  474|      0|                    fallback = (UIView *)firstResponder;
  475|      0|                }
  476|      0|            }
  477|      0|
  478|      0|            if ([fallback isKindOfClass:[UITextField class]] || [fallback isKindOfClass:[UITextView class]] || [fallback isKindOfClass:[UISearchBar class]]) {
  479|      0|                NSLog(@"KIF: Unable to find keyboard key for %@. Inserting manually.", characterString);
  480|      0|                [(UITextField *)fallback setText:[[(UITextField *)fallback text] stringByAppendingString:characterString]];
  481|      0|            } else {
  482|      0|                [self failWithError:[NSError KIFErrorWithFormat:@"Failed to find key for character \"%@\"", characterString] stopTest:YES];
  483|      0|            }
  484|      0|        }
  485|      0|    }];
  486|      0|
  487|      0|    NSTimeInterval remainingWaitTime = 0.01 - [KIFTypist keystrokeDelay];
  488|      0|    if (remainingWaitTime > 0) {
  489|      0|        CFRunLoopRunInMode(UIApplicationCurrentRunMode, remainingWaitTime, false);
  490|      0|    }
  491|      0|}
  492|       |
  493|       |- (void)enterText:(NSString *)text intoViewWithAccessibilityLabel:(NSString *)label
  494|      0|{
  495|      0|    return [self enterText:text intoViewWithAccessibilityLabel:label traits:UIAccessibilityTraitNone expectedResult:nil];
  496|      0|}
  497|       |
  498|       |- (void)enterText:(NSString *)text intoViewWithAccessibilityLabel:(NSString *)label traits:(UIAccessibilityTraits)traits expectedResult:(NSString *)expectedResult
  499|      0|{
  500|      0|    UIView *view = nil;
  501|      0|    UIAccessibilityElement *element = nil;
  502|      0|
  503|      0|    [self waitForAccessibilityElement:&element view:&view withLabel:label value:nil traits:traits tappable:YES];
  504|      0|
  505|      0|    [self enterText:text intoElement:element inView:view expectedResult:expectedResult];
  506|      0|}
  507|       |
  508|       |- (void)enterText:(NSString *)text intoElement:(UIAccessibilityElement *)element inView:(UIView *)view expectedResult:(NSString *)expectedResult;
  509|      0|{
  510|      0|    // In iOS7, tapping a field that is already first responder moves the cursor to the front of the field
  511|      0|    if (view.window.firstResponder != view) {
  512|      0|        [self tapAccessibilityElement:element inView:view];
  513|      0|        [self waitForTimeInterval:0.25 relativeToAnimationSpeed:YES];
  514|      0|    }
  515|      0|
  516|      0|    [self enterTextIntoCurrentFirstResponder:text fallbackView:view];
  517|      0|    if (self.validateEnteredText) {
  518|      0|        [self expectView:view toContainText:expectedResult ?: text];
  519|      0|    }
  520|      0|}
  521|       |
  522|       |- (void)expectView:(UIView *)view toContainText:(NSString *)expectedResult
  523|      0|{
  524|      0|    // We will perform some additional validation if the view is UITextField or UITextView.
  525|      0|    if (![view respondsToSelector:@selector(text)]) {
  526|      0|        return;
  527|      0|    }
  528|      0|
  529|      0|    UITextView *textView = (UITextView *)view;
  530|      0|
  531|      0|    // Some slower machines take longer for typing to catch up, so wait for a bit before failing
  532|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
  533|      0|        // We trim \n and \r because they trigger the return key, so they won't show up in the final product on single-line inputs.
  534|      0|        // Also trim \b (backspace) characters to allow for deletion.
  535|      0|        NSMutableCharacterSet *charExclusionSet = [NSMutableCharacterSet characterSetWithCharactersInString:@"\b"];
  536|      0|        [charExclusionSet formUnionWithCharacterSet:[NSCharacterSet newlineCharacterSet]];
  537|      0|        NSString *expected = [expectedResult stringByTrimmingCharactersInSet:charExclusionSet];
  538|      0|        NSString *actual = [textView.text stringByTrimmingCharactersInSet:charExclusionSet];
  539|      0|        
  540|      0|        KIFTestWaitCondition([actual isEqualToString:expected], error, @"Failed to get text \"%@\" in field; instead, it was \"%@\"", expected, actual);
  541|      0|        
  542|      0|        return KIFTestStepResultSuccess;
  543|      0|    } timeout:[KIFTestActor defaultTimeout]];
  544|      0|}
  545|       |
  546|       |- (void)clearTextFromFirstResponder
  547|      0|{
  548|      0|    @autoreleasepool {
  549|      0|        UIView *firstResponder = (id)[[[UIApplication sharedApplication] keyWindow] firstResponder];
  550|      0|        if ([firstResponder isKindOfClass:[UIView class]]) {
  551|      0|            [self clearTextFromElement:(UIAccessibilityElement *)firstResponder inView:firstResponder];
  552|      0|        }
  553|      0|    }
  554|      0|}
  555|       |
  556|       |- (void)clearTextFromViewWithAccessibilityLabel:(NSString *)label
  557|      0|{
  558|      0|    [self clearTextFromViewWithAccessibilityLabel:label traits:UIAccessibilityTraitNone];
  559|      0|}
  560|       |
  561|       |- (void)clearTextFromViewWithAccessibilityLabel:(NSString *)label traits:(UIAccessibilityTraits)traits
  562|      0|{
  563|      0|    UIView *view = nil;
  564|      0|    UIAccessibilityElement *element = nil;
  565|      0|
  566|      0|    [self waitForAccessibilityElement:&element view:&view withLabel:label value:nil traits:traits tappable:YES];
  567|      0|    [self clearTextFromElement:element inView:view];
  568|      0|}
  569|       |
  570|       |- (void)clearTextFromElement:(UIAccessibilityElement *)element inView:(UIView *)view
  571|      0|{
  572|      0|    [self tapAccessibilityElement:element inView:view];
  573|      0|
  574|      0|    // Per issue #294, the tap occurs in the center of the text view.  If the text is too long, this means not all text gets cleared.  To address this for most cases, we can check if the selected view conforms to UITextInput and select the whole text range.
  575|      0|    if ([view conformsToProtocol:@protocol(UITextInput)]) {
  576|      0|        id<UITextInput> textInput = (id<UITextInput>)view;
  577|      0|        [textInput setSelectedTextRange:[textInput textRangeFromPosition:textInput.beginningOfDocument toPosition:textInput.endOfDocument]];
  578|      0|        
  579|      0|        [self waitForTimeInterval:0.1 relativeToAnimationSpeed:YES];
  580|      0|        [self enterTextIntoCurrentFirstResponder:@"\b" fallbackView:view];
  581|      0|    } else {
  582|      0|        NSUInteger numberOfCharacters = [view respondsToSelector:@selector(text)] ? [(UITextField *)view text].length : element.accessibilityValue.length;
  583|      0|        NSMutableString *text = [NSMutableString string];
  584|      0|        for (NSInteger i = 0; i < numberOfCharacters; i ++) {
  585|      0|            [text appendString:@"\b"];
  586|      0|        }
  587|      0|        [self enterTextIntoCurrentFirstResponder:text fallbackView:view];
  588|      0|    }
  589|      0|    
  590|      0|    [self expectView:view toContainText:@""];
  591|      0|}
  592|       |
  593|       |- (void)clearTextFromAndThenEnterText:(NSString *)text intoViewWithAccessibilityLabel:(NSString *)label
  594|      0|{
  595|      0|    [self clearTextFromViewWithAccessibilityLabel:label];
  596|      0|    [self enterText:text intoViewWithAccessibilityLabel:label];
  597|      0|}
  598|       |
  599|       |- (void)clearTextFromAndThenEnterText:(NSString *)text intoViewWithAccessibilityLabel:(NSString *)label traits:(UIAccessibilityTraits)traits expectedResult:(NSString *)expectedResult
  600|      0|{
  601|      0|    [self clearTextFromViewWithAccessibilityLabel:label traits:traits];
  602|      0|    [self enterText:text intoViewWithAccessibilityLabel:label traits:traits expectedResult:expectedResult];
  603|      0|}
  604|       |
  605|       |- (void)clearTextFromAndThenEnterTextIntoCurrentFirstResponder:(NSString *)text
  606|      0|{
  607|      0|    [self clearTextFromFirstResponder];
  608|      0|    [self enterTextIntoCurrentFirstResponder:text];
  609|      0|}
  610|       |
  611|       |- (void)setText:(NSString *)text intoViewWithAccessibilityLabel:(NSString *)label
  612|      0|{
  613|      0|    UIView *view = nil;
  614|      0|    UIAccessibilityElement *element = nil;
  615|      0|
  616|      0|    [self waitForAccessibilityElement:&element view:&view withLabel:label value:nil traits:UIAccessibilityTraitNone tappable:YES];
  617|      0|    if ([view respondsToSelector:@selector(setText:)]) {
  618|      0|        [view performSelector:@selector(setText:) withObject:text];
  619|      0|    }
  620|      0|}
  621|       |
  622|      0|- (NSString *)textFromView:(UIView *)view {
  623|      0|    if ([view isKindOfClass:[UILabel class]]) {
  624|      0|        UILabel *label = (UILabel *)view;
  625|      0|        return label.text ? : @"";
  626|      0|    } else if ([view isKindOfClass:[UITextField class]]) {
  627|      0|        UITextField *textField = (UITextField *)view;
  628|      0|        return [textField.text isEqual: @""] ? textField.placeholder : textField.text;
  629|      0|    } else if ([view isKindOfClass:[UITextView class]]) {
  630|      0|        UITextView *textView = (UITextView *)view;
  631|      0|        return textView.text;
  632|      0|    }
  633|      0|    return @"";
  634|      0|}
  635|       |
  636|       |- (void)selectPickerViewRowWithTitle:(NSString *)title
  637|      0|{
  638|      0|    NSArray *dataToSelect = @[ title ];
  639|      0|    [self selectPickerValue:dataToSelect fromPicker:nil pickerType:KIFUIPickerView withSearchOrder:KIFPickerSearchForwardFromStart];
  640|      0|}
  641|       |
  642|       |- (void)selectPickerViewRowWithTitle:(NSString *)title inComponent:(NSInteger)component
  643|      0|{
  644|      0|    [self selectPickerViewRowWithTitle:title inComponent:component fromPicker:nil withSearchOrder:KIFPickerSearchForwardFromStart];
  645|      0|}
  646|       |
  647|       |- (void)selectPickerViewRowWithTitle:(NSString *)title inComponent:(NSInteger)component withSearchOrder:(KIFPickerSearchOrder)searchOrder
  648|      0|{
  649|      0|    [self selectPickerViewRowWithTitle:title inComponent:component fromPicker:nil withSearchOrder:searchOrder];
  650|      0|}
  651|       |
  652|       |- (void)selectDatePickerValue:(NSArray *)datePickerColumnValues
  653|      0|{
  654|      0|    [self selectPickerValue:datePickerColumnValues fromPicker:nil pickerType:KIFUIDatePicker withSearchOrder:KIFPickerSearchForwardFromStart];
  655|      0|}
  656|       |- (void)selectDatePickerValue:(NSArray *)datePickerColumnValues withSearchOrder:(KIFPickerSearchOrder)searchOrder
  657|      0|{
  658|      0|    [self selectPickerValue:datePickerColumnValues fromPicker:nil pickerType:KIFUIDatePicker withSearchOrder:searchOrder];
  659|      0|}
  660|       |
  661|       |- (void)selectDatePickerValue:(NSArray *)datePickerColumnValues fromPicker:(UIPickerView *)picker withSearchOrder:(KIFPickerSearchOrder)searchOrder
  662|      0|{
  663|      0|    [self selectPickerValue:datePickerColumnValues fromPicker:picker pickerType:KIFUIDatePicker withSearchOrder:searchOrder];
  664|      0|}
  665|       |
  666|       |- (void)selectPickerViewRowWithTitle:(NSString *)title inComponent:(NSInteger)component fromPicker:(UIPickerView *)picker
  667|      0|{
  668|      0|    [self selectPickerViewRowWithTitle:title inComponent:component fromPicker:picker withSearchOrder:KIFPickerSearchForwardFromStart];
  669|      0|}
  670|       |
  671|       |- (void)selectPickerViewRowWithTitle:(NSString *)title inComponent:(NSInteger)component fromPicker:(UIPickerView *)picker withSearchOrder:(KIFPickerSearchOrder)searchOrder
  672|      0|{
  673|      0|    NSMutableArray *dataToSelect = [[NSMutableArray alloc] init];
  674|      0|
  675|      0|    UIPickerView *pickerView = picker;
  676|      0|    KIFPickerType pickerType = 0;
  677|      0|
  678|      0|    if (pickerView == nil) {
  679|      0|        // Find all pickers in view. Either UIDatePickerView or UIPickerView
  680|      0|        NSArray *datePickerViews = [[[UIApplication sharedApplication] datePickerWindow] subviewsWithClassNameOrSuperClassNamePrefix:@"UIPickerView"];
  681|      0|        NSArray *pickerViews = [[[UIApplication sharedApplication] pickerViewWindow] subviewsWithClassNameOrSuperClassNamePrefix:@"UIPickerView"];
  682|      0|
  683|      0|        // Grab one picker and assume it is datePicker and then test our hypothesis later!
  684|      0|        pickerView = [datePickerViews lastObject];
  685|      0|        if ([pickerView respondsToSelector:@selector(setDate:animated:)]) {
  686|      0|            pickerType = KIFUIDatePicker;
  687|      0|        } else {
  688|      0|            pickerView = [pickerViews lastObject];
  689|      0|            pickerType = KIFUIPickerView;
  690|      0|        }
  691|      0|    } else {
  692|      0|        if ([pickerView respondsToSelector:@selector(setDate:animated:)]) {
  693|      0|            pickerType = KIFUIDatePicker;
  694|      0|        } else {
  695|      0|            pickerType = KIFUIPickerView;
  696|      0|        }
  697|      0|    }
  698|      0|
  699|      0|    // Add title at component index and add empty strings for other.
  700|      0|    // This support legacy function re-use.
  701|      0|    for (int i = 0; i < pickerView.numberOfComponents; i++) {
  702|      0|        if (component == i) {
  703|      0|            [dataToSelect addObject:title];
  704|      0|        } else {
  705|      0|            NSInteger currentIndex = [pickerView selectedRowInComponent:i];
  706|      0|            NSString *rowTitle = nil;
  707|      0|            if ([pickerView.delegate respondsToSelector:@selector(pickerView:titleForRow:forComponent:)]) {
  708|      0|                rowTitle = [pickerView.delegate pickerView:pickerView titleForRow:currentIndex forComponent:i];
  709|      0|            } else if ([pickerView.delegate respondsToSelector:@selector(pickerView:attributedTitleForRow:forComponent:)]) {
  710|      0|                rowTitle = [[pickerView.delegate pickerView:pickerView attributedTitleForRow:currentIndex forComponent:i] string];
  711|      0|            } else if ([pickerView.delegate respondsToSelector:@selector(pickerView:viewForRow:forComponent:reusingView:)]) {
  712|      0|                // This delegate inserts views directly, so try to figure out what the title is by looking for a label
  713|      0|                UIView *rowView = [pickerView.delegate pickerView:pickerView viewForRow:currentIndex forComponent:i reusingView:nil];
  714|      0|                if ([rowView isKindOfClass:[UILabel class]]) {
  715|      0|                    UILabel *label = (UILabel *) rowView;
  716|      0|                    rowTitle = label.text;
  717|      0|                } else {
  718|      0|                    NSArray *labels = [rowView subviewsWithClassNameOrSuperClassNamePrefix:@"UILabel"];
  719|      0|                    UILabel *label = (labels.count > 0 ? labels[0] : nil);
  720|      0|                    rowTitle = label.text;
  721|      0|                }
  722|      0|            }
  723|      0|            if (rowTitle) {
  724|      0|                [dataToSelect addObject: rowTitle];
  725|      0|            } else {
  726|      0|                @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@"Unknown picker type. Delegate responds neither to pickerView:titleForRow:forComponent: nor to pickerView:viewForRow:forComponent:reusingView:" userInfo:nil];
  727|      0|            }
  728|      0|        }
  729|      0|    }
  730|      0|    [self selectPickerValue:dataToSelect fromPicker:pickerView pickerType:pickerType withSearchOrder:searchOrder];
  731|      0|}
  732|       |
  733|       |- (void)selectPickerValue:(NSArray *)pickerColumnValues fromPicker:(UIPickerView *)picker pickerType:(KIFPickerType)pickerType withSearchOrder:(KIFPickerSearchOrder)searchOrder
  734|      0|{
  735|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
  736|      0|        NSInteger columnCount = [pickerColumnValues count];
  737|      0|        NSMutableArray* found_values = [NSMutableArray arrayWithCapacity:columnCount];
  738|      0|        for (NSInteger componentIndex = 0; componentIndex < columnCount; componentIndex++) {
  739|      0|            [found_values addObject:[NSNumber numberWithBool:NO]];
  740|      0|        }
  741|      0|        // Find the picker view
  742|      0|        UIPickerView *pickerView = picker;
  743|      0|        if (pickerView == nil) {
  744|      0|            switch (pickerType)
  745|      0|            {
  746|      0|                case KIFUIDatePicker:
  747|      0|                {
  748|      0|                    pickerView = [[[[UIApplication sharedApplication] datePickerWindow] subviewsWithClassNameOrSuperClassNamePrefix:@"UIPickerView"] lastObject];
  749|      0|                    KIFTestCondition(pickerView, error, @"No picker view is present");
  750|      0|                    break;
  751|      0|                }
  752|      0|                case KIFUIPickerView:
  753|      0|                {
  754|      0|                    pickerView = [[[[UIApplication sharedApplication] pickerViewWindow] subviewsWithClassNameOrSuperClassNamePrefix:@"UIPickerView"] lastObject];
  755|      0|                }
  756|      0|            }
  757|      0|        }
  758|      0|        
  759|      0|        NSInteger componentCount = [pickerView.dataSource numberOfComponentsInPickerView:pickerView];
  760|      0|        KIFTestCondition(componentCount == columnCount, error, @"The Picker does not have the expected column count.");
  761|      0|        
  762|      0|        for (NSInteger componentIndex = 0; componentIndex < componentCount; componentIndex++) {
  763|      0|
  764|      0|            // Set search order
  765|      0|            NSInteger firstIndex;
  766|      0|            NSInteger rowCount = [pickerView.dataSource pickerView:pickerView numberOfRowsInComponent:componentIndex];
  767|      0|            NSInteger indexProgress = (searchOrder == KIFPickerSearchBackwardFromCurrentValue ||
  768|      0|                                       searchOrder == KIFPickerSearchBackwardFromEnd) ? -1 : 1;
  769|      0|            switch (searchOrder) {
  770|      0|                case KIFPickerSearchForwardFromCurrentValue:
  771|      0|                case KIFPickerSearchBackwardFromCurrentValue:
  772|      0|                    firstIndex = [pickerView selectedRowInComponent:componentIndex];
  773|      0|                    break;
  774|      0|                case KIFPickerSearchBackwardFromEnd:
  775|      0|                    firstIndex = rowCount - 1;
  776|      0|                    break;
  777|      0|                default:
  778|      0|                    firstIndex = 0;
  779|      0|                    break;
  780|      0|            }
  781|      0|            
  782|      0|            //Fix issue with AM:PM
  783|      0|            if (rowCount == 2) { indexProgress = 1; firstIndex = 0; }
  784|      0|
  785|      0|            for (NSInteger rowIndex = firstIndex; rowIndex < rowCount && rowIndex >= 0; rowIndex += indexProgress) {
  786|      0|                NSString *rowTitle = nil;
  787|      0|                if ([pickerView.delegate respondsToSelector:@selector(pickerView:titleForRow:forComponent:)]) {
  788|      0|                    rowTitle = [pickerView.delegate pickerView:pickerView titleForRow:rowIndex forComponent:componentIndex];
  789|      0|                } else if ([pickerView.delegate respondsToSelector:@selector(pickerView:attributedTitleForRow:forComponent:)]) {
  790|      0|                    rowTitle = [[pickerView.delegate pickerView:pickerView attributedTitleForRow:rowIndex forComponent:componentIndex] string];
  791|      0|                } else if ([pickerView.delegate respondsToSelector:@selector(pickerView:viewForRow:forComponent:reusingView:)]) {
  792|      0|                    
  793|      0|                    UIView *rowView = [pickerView.delegate pickerView:pickerView viewForRow:rowIndex forComponent:componentIndex reusingView:nil];
  794|      0|                    UILabel *label;
  795|      0|                    if ([rowView isKindOfClass:[UILabel class]] ) {
  796|      0|                        label = (id)rowView;
  797|      0|                    } else {
  798|      0|                        // This delegate inserts views directly, so try to figure out what the title is by looking for a label
  799|      0|                        NSArray *labels = [rowView subviewsWithClassNameOrSuperClassNamePrefix:@"UILabel"];
  800|      0|                        label = (labels.count > 0 ? labels[0] : nil);
  801|      0|                    }
  802|      0|                    rowTitle = label.text;
  803|      0|                }
  804|      0|                
  805|      0|                if (rowIndex==[pickerView selectedRowInComponent:componentIndex] && [rowTitle isEqual:pickerColumnValues[componentIndex]]){
  806|      0|                    [found_values replaceObjectAtIndex:componentIndex withObject:@(YES)];
  807|      0|                    break;
  808|      0|                }
  809|      0|                else if ([rowTitle isEqual:pickerColumnValues[componentIndex]]) {
  810|      0|                    [pickerView selectRow:rowIndex inComponent:componentIndex animated:NO];
  811|      0|                    KIFRunLoopRunInModeRelativeToAnimationSpeed(kCFRunLoopDefaultMode, 1.0f, NO);
  812|      0|                    // Even though selectRow says it's not animated - it really is. We need to wait for them to finish before continuing.
  813|      0|                    [tester waitForAnimationsToFinish];
  814|      0|                    
  815|      0|                    // Tap in the middle of the picker view to select the item
  816|      0|                    [pickerView tap];
  817|      0|                    [self waitForTimeInterval:0.5 relativeToAnimationSpeed:YES];
  818|      0|                    
  819|      0|                    // The combination of selectRow:inComponent:animated: and tap does not consistently result in
  820|      0|                    // pickerView:didSelectRow:inComponent: being called on the delegate. We need to do it explicitly.
  821|      0|                    if ([pickerView.delegate respondsToSelector:@selector(pickerView:didSelectRow:inComponent:)]) {
  822|      0|                        [pickerView.delegate pickerView:pickerView didSelectRow:rowIndex inComponent:componentIndex];
  823|      0|                    }
  824|      0|                    
  825|      0|                    [found_values replaceObjectAtIndex:componentIndex withObject:@(YES)];
  826|      0|                    break;
  827|      0|                }
  828|      0|            }
  829|      0|            if (found_values[componentIndex] == [NSNumber numberWithBool:YES]) {
  830|      0|                continue;
  831|      0|            }
  832|      0|        }
  833|      0|        
  834|      0|        // Support multiple column by adding flag to check if the value found in
  835|      0|        // at-least one column
  836|      0|        BOOL _foundInOneColumn = NO;
  837|      0|        for (NSInteger componentIndex = 0; componentIndex < columnCount; componentIndex++) {
  838|      0|            if (found_values[componentIndex] != [NSNumber numberWithBool:NO]) {
  839|      0|                _foundInOneColumn = YES;
  840|      0|            }
  841|      0|        }
  842|      0|        
  843|      0|        if (!_foundInOneColumn) {
  844|      0|            KIFTestCondition(NO, error, @"Failed to select from Picker.");
  845|      0|            return KIFTestStepResultFailure;
  846|      0|        }
  847|      0|        
  848|      0|        return KIFTestStepResultSuccess;
  849|      0|    }];
  850|      0|}
  851|       |
  852|       |- (void)setOn:(BOOL)switchIsOn forSwitchWithAccessibilityLabel:(NSString *)label
  853|      0|{
  854|      0|    UIView *view = nil;
  855|      0|    UIAccessibilityElement *element = nil;
  856|      0|
  857|      0|    [self waitForAccessibilityElement:&element view:&view withLabel:label value:nil traits:UIAccessibilityTraitButton tappable:YES];
  858|      0|
  859|      0|    if (![view isKindOfClass:[UISwitch class]]) {
  860|      0|        [self failWithError:[NSError KIFErrorWithFormat:@"View with accessibility label \"%@\" is a %@, not a UISwitch", label, NSStringFromClass([view class])] stopTest:YES];
  861|      0|    }
  862|      0|    UISwitch *switchView = (UISwitch *)view;
  863|      0|
  864|      0|    [self setSwitch:switchView element:element On:switchIsOn];
  865|      0|}
  866|       |
  867|       |- (void)setSwitch:(UISwitch *)switchView element:(UIAccessibilityElement *)element On:(BOOL)switchIsOn
  868|      0|{
  869|      0|    // No need to switch it if it's already in the correct position
  870|      0|    if (switchView.isOn == switchIsOn) {
  871|      0|        return;
  872|      0|    }
  873|      0|
  874|      0|    [self tapAccessibilityElement:element inView:switchView];
  875|      0|
  876|      0|    // If we succeeded, stop the test.
  877|      0|    if (switchView.isOn == switchIsOn) {
  878|      0|        return;
  879|      0|    }
  880|      0|
  881|      0|    NSLog(@"Faking turning switch %@", switchIsOn ? @"ON" : @"OFF");
  882|      0|    [switchView setOn:switchIsOn animated:[[self class] testActorAnimationsEnabled]];
  883|      0|    [switchView sendActionsForControlEvents:UIControlEventValueChanged];
  884|      0|    [self waitForTimeInterval:0.5 relativeToAnimationSpeed:YES];
  885|      0|
  886|      0|    // We gave it our best shot.  Fail the test.
  887|      0|    if (switchView.isOn != switchIsOn) {
  888|      0|        [self failWithError:[NSError KIFErrorWithFormat:@"Failed to toggle switch to \"%@\"; instead, it was \"%@\"", switchIsOn ? @"ON" : @"OFF", switchView.on ? @"ON" : @"OFF"] stopTest:YES];
  889|      0|    }
  890|      0|}
  891|       |
  892|       |
  893|       |
  894|       |- (void)setValue:(float)value forSliderWithAccessibilityLabel:(NSString *)label
  895|      0|{
  896|      0|    UISlider *slider = nil;
  897|      0|    UIAccessibilityElement *element = nil;
  898|      0|    [self waitForAccessibilityElement:&element view:&slider withLabel:label value:nil traits:UIAccessibilityTraitNone tappable:YES];
  899|      0|
  900|      0|    if (![slider isKindOfClass:[UISlider class]]) {
  901|      0|        [self failWithError:[NSError KIFErrorWithFormat:@"View with accessibility label \"%@\" is a %@, not a UISlider", label, NSStringFromClass([slider class])] stopTest:YES];
  902|      0|    }
  903|      0|    [self setValue:value forSlider:slider];
  904|      0|}
  905|       |
  906|       |- (void)setValue:(float)value forSlider:(UISlider *)slider
  907|      0|{
  908|      0|    if (value < slider.minimumValue) {
  909|      0|        [self failWithError:[NSError KIFErrorWithFormat:@"Cannot slide past minimum value of %f", slider.minimumValue] stopTest:YES];
  910|      0|    }
  911|      0|
  912|      0|    if (value > slider.maximumValue) {
  913|      0|        [self failWithError:[NSError KIFErrorWithFormat:@"Cannot slide past maximum value of %f", slider.maximumValue] stopTest:YES];
  914|      0|    }
  915|      0|
  916|      0|    CGRect trackRect = [slider trackRectForBounds:slider.bounds];
  917|      0|    CGPoint currentPosition = CGPointCenteredInRect([slider thumbRectForBounds:slider.bounds trackRect:trackRect value:slider.value]);
  918|      0|    CGPoint finalPosition = CGPointCenteredInRect([slider thumbRectForBounds:slider.bounds trackRect:trackRect value:value]);
  919|      0|
  920|      0|    if (value == slider.minimumValue) {
  921|      0|        finalPosition.x = 0;
  922|      0|    } else if (value == slider.maximumValue) {
  923|      0|        finalPosition.x = slider.bounds.size.width;
  924|      0|    }
  925|      0|
  926|      0|    [slider dragFromPoint:currentPosition toPoint:finalPosition steps:10];
  927|      0|}
  928|       |
  929|       |- (void)dismissPopover
  930|      0|{
  931|      0|    const NSTimeInterval tapDelay = 0.05;
  932|      0|    UIWindow *window = [[UIApplication sharedApplication] dimmingViewWindow];
  933|      0|    if (!window) {
  934|      0|        [self failWithError:[NSError KIFErrorWithFormat:@"Failed to find any dimming views in the application"] stopTest:YES];
  935|      0|    }
  936|      0|    UIView *dimmingView = [[window subviewsWithClassNamePrefix:@"UIDimmingView"] lastObject];
  937|      0|    [dimmingView tapAtPoint:CGPointMake(50.0f, 50.0f)];
  938|      0|    KIFRunLoopRunInModeRelativeToAnimationSpeed(kCFRunLoopDefaultMode, tapDelay, false);
  939|      0|}
  940|       |
  941|       |- (void)choosePhotoInAlbum:(NSString *)albumName atRow:(NSInteger)row column:(NSInteger)column
  942|      0|{
  943|      0|    // This is basically the same as the step to tap with an accessibility label except that the accessibility labels for the albums have the number of photos appended to the end, such as "My Photos (3)." This means that we have to do a prefix match rather than an exact match.
  944|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
  945|      0|        
  946|      0|        NSString *labelPrefix = [NSString stringWithFormat:@"%@", albumName];
  947|      0|        UIAccessibilityElement *element = [[UIApplication sharedApplication] accessibilityElementMatchingBlock:^(UIAccessibilityElement *element) {
  948|      0|            return [element.accessibilityLabel hasPrefix:labelPrefix];
  949|      0|        }];
  950|      0|        
  951|      0|        KIFTestWaitCondition(element, error, @"Failed to find photo album with name %@", albumName);
  952|      0|        
  953|      0|        UIView *view = [UIAccessibilityElement viewContainingAccessibilityElement:element];
  954|      0|        KIFTestWaitCondition(view, error, @"Failed to find view for photo album with name %@", albumName);
  955|      0|        
  956|      0|        if (![view isUserInteractionActuallyEnabled]) {
  957|      0|            if (error) {
  958|      0|                *error = [NSError KIFErrorWithFormat:@"Album picker is not enabled for interaction"];
  959|      0|            }
  960|      0|            return KIFTestStepResultWait;
  961|      0|        }
  962|      0|
  963|      0|        CGPoint tappablePointInElement = [self tappablePointInElement:element andView:view];
  964|      0|        [view tapAtPoint:tappablePointInElement];
  965|      0|        
  966|      0|        return KIFTestStepResultSuccess;
  967|      0|    }];
  968|      0|
  969|      0|    // Wait for media picker view controller to be pushed.
  970|      0|    [self waitForTimeInterval:1 relativeToAnimationSpeed:YES];
  971|      0|
  972|      0|    // Tap the desired photo in the grid
  973|      0|    // TODO: This currently only works for the first page of photos. It should scroll appropriately at some point.
  974|      0|     UIAccessibilityElement *headerElt = [[UIApplication sharedApplication] accessibilityElementMatchingBlock:^(UIAccessibilityElement *element) {
  975|      0|        return [NSStringFromClass(element.class) isEqual:@"UINavigationItemButtonView"];
  976|      0|    }];
  977|      0|    UIView* headerView = [UIAccessibilityElement viewContainingAccessibilityElement:headerElt];
  978|      0|    CGRect headerFrame = [headerView convertRect:headerView.frame toView:headerView.window];
  979|      0|    const CGFloat headerBottom =  headerFrame.origin.y + headerFrame.size.height;
  980|      0|    const CGSize thumbnailSize = CGSizeMake(75.0, 75.0);
  981|      0|    const CGFloat thumbnailMargin = 5.0;
  982|      0|    CGPoint thumbnailCenter;
  983|      0|    thumbnailCenter.x = thumbnailMargin + (MAX(0, column - 1) * (thumbnailSize.width + thumbnailMargin)) + thumbnailSize.width / 2.0;
  984|      0|    thumbnailCenter.y = headerBottom + thumbnailMargin + (MAX(0, row - 1) * (thumbnailSize.height + thumbnailMargin)) + thumbnailSize.height / 2.0;
  985|      0|    [self tapScreenAtPoint:thumbnailCenter];
  986|      0|}
  987|       |
  988|       |- (void)tapRowAtIndexPath:(NSIndexPath *)indexPath inTableViewWithAccessibilityIdentifier:(NSString *)identifier
  989|      0|{
  990|      0|    UITableView *tableView;
  991|      0|    [self waitForAccessibilityElement:NULL view:&tableView withIdentifier:identifier tappable:NO];
  992|      0|    [self tapRowAtIndexPath:indexPath inTableView:tableView];
  993|      0|}
  994|       |
  995|       |- (void)tapRowInTableViewWithAccessibilityLabel:(NSString *)tableViewLabel atIndexPath:(NSIndexPath *)indexPath
  996|      0|{
  997|      0|    UITableView *tableView = (UITableView *)[self waitForViewWithAccessibilityLabel:tableViewLabel];
  998|      0|    [self tapRowAtIndexPath:indexPath inTableView:tableView];
  999|      0|}
 1000|       |
 1001|       |- (void)tapRowAtIndexPath:(NSIndexPath *)indexPath inTableView:(UITableView *)tableView
 1002|      0|{
 1003|      0|    UITableViewCell *cell = [self waitForCellAtIndexPath:indexPath inTableView:tableView];
 1004|      0|    CGRect cellFrame = [cell.contentView convertRect:cell.contentView.frame toView:tableView];
 1005|      0|    [tableView tapAtPoint:CGPointCenteredInRect(cellFrame)];
 1006|      0|
 1007|      0|    [self waitForAnimationsToFinish];
 1008|      0|}
 1009|       |
 1010|       |- (void)swipeRowAtIndexPath:(NSIndexPath *)indexPath inTableView:(UITableView *)tableView inDirection:(KIFSwipeDirection)direction
 1011|      0|{
 1012|      0|    const NSUInteger kNumberOfPointsInSwipePath = 20;
 1013|      0|    
 1014|      0|    UITableViewCell *cell = [self waitForCellAtIndexPath:indexPath inTableView:tableView];
 1015|      0|    CGRect cellFrame = [cell.contentView convertRect:cell.contentView.frame toView:tableView];
 1016|      0|    CGPoint swipeStart = CGPointCenteredInRect(cellFrame);
 1017|      0|    KIFDisplacement swipeDisplacement = [self _displacementForSwipingInDirection:direction];
 1018|      0|    [tableView dragFromPoint:swipeStart displacement:swipeDisplacement steps:kNumberOfPointsInSwipePath];
 1019|      0|    
 1020|      0|    // Wait for the view to stabilize.
 1021|      0|    [tester waitForTimeInterval:0.5 relativeToAnimationSpeed:YES];
 1022|      0|    
 1023|      0|}
 1024|       |
 1025|      0|- (void)waitForDeleteStateForCellAtIndexPath:(NSIndexPath*)indexPath inTableView:(UITableView*)tableView {
 1026|      0|    UITableViewCell *cell = [self waitForCellAtIndexPath:indexPath inTableView:tableView];
 1027|      0|    [self waitForDeleteStateForCell:cell];
 1028|      0|}
 1029|       |
 1030|      0|- (void)waitForDeleteStateForCell:(UITableViewCell*)cell {
 1031|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
 1032|      0|        KIFTestWaitCondition(cell.showingDeleteConfirmation, error,
 1033|      0|                             @"Expected cell to get in the delete confirmation state: %@", cell);
 1034|      0|        return KIFTestStepResultSuccess;
 1035|      0|    }];
 1036|      0|}
 1037|       |
 1038|       |- (void)tapItemAtIndexPath:(NSIndexPath *)indexPath inCollectionViewWithAccessibilityIdentifier:(NSString *)identifier
 1039|      0|{
 1040|      0|    UICollectionView *collectionView;
 1041|      0|    [self waitForAccessibilityElement:NULL view:&collectionView withIdentifier:identifier tappable:NO];
 1042|      0|    [self tapItemAtIndexPath:indexPath inCollectionView:collectionView];
 1043|      0|}
 1044|       |
 1045|       |#if TARGET_IPHONE_SIMULATOR
 1046|       |
 1047|       |- (BOOL)acknowledgeSystemAlert
 1048|      0|{
 1049|      0|    return [UIAutomationHelper acknowledgeSystemAlert];
 1050|      0|}
 1051|       |
 1052|       |- (BOOL)acknowledgeSystemAlertWithIndex:(NSUInteger)index
 1053|      0|{
 1054|      0|    return [UIAutomationHelper acknowledgeSystemAlertWithIndex: index];
 1055|      0|}
 1056|       |
 1057|       |#endif
 1058|       |
 1059|       |- (void)tapItemAtIndexPath:(NSIndexPath *)indexPath inCollectionView:(UICollectionView *)collectionView
 1060|      0|{
 1061|      0|    UICollectionViewCell *cell;
 1062|      0|    cell = [self waitForCellAtIndexPath:indexPath inCollectionView:collectionView];
 1063|      0|
 1064|      0|    CGRect cellFrame = [cell.contentView convertRect:cell.contentView.frame toView:collectionView];
 1065|      0|    [collectionView tapAtPoint:CGPointCenteredInRect(cellFrame)];
 1066|      0|
 1067|      0|    [self waitForAnimationsToFinish];
 1068|      0|}
 1069|       |
 1070|       |- (void)swipeViewWithAccessibilityLabel:(NSString *)label inDirection:(KIFSwipeDirection)direction
 1071|      0|{
 1072|      0|    [self swipeViewWithAccessibilityLabel:label value:nil traits:UIAccessibilityTraitNone inDirection:direction];
 1073|      0|}
 1074|       |
 1075|       |- (void)swipeViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value inDirection:(KIFSwipeDirection)direction
 1076|      0|{
 1077|      0|    [self swipeViewWithAccessibilityLabel:label value:value traits:UIAccessibilityTraitNone inDirection:direction];
 1078|      0|}
 1079|       |
 1080|       |- (void)swipeViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value traits:(UIAccessibilityTraits)traits inDirection:(KIFSwipeDirection)direction
 1081|      0|{
 1082|      0|    UIView *viewToSwipe = nil;
 1083|      0|    UIAccessibilityElement *element = nil;
 1084|      0|
 1085|      0|    [self waitForAccessibilityElement:&element view:&viewToSwipe withLabel:label value:value traits:traits tappable:YES];
 1086|      0|
 1087|      0|    [self swipeAccessibilityElement:element inView:viewToSwipe inDirection:direction];
 1088|      0|}
 1089|       |
 1090|       |- (void)swipeAccessibilityElement:(UIAccessibilityElement *)element inView:(UIView *)viewToSwipe inDirection:(KIFSwipeDirection)direction
 1091|      0|{
 1092|      0|    // The original version of this came from http://groups.google.com/group/kif-framework/browse_thread/thread/df3f47eff9f5ac8c
 1093|      0|  
 1094|      0|    const NSUInteger kNumberOfPointsInSwipePath = 20;
 1095|      0|  
 1096|      0|    // Within this method, all geometry is done in the coordinate system of the view to swipe.
 1097|      0|    CGRect elementFrame = [self elementFrameForElement:element andView:viewToSwipe];
 1098|      0|
 1099|      0|    CGPoint swipeStart = CGPointCenteredInRect(elementFrame);
 1100|      0|
 1101|      0|    KIFDisplacement swipeDisplacement = [self _displacementForSwipingInDirection:direction];
 1102|      0|  
 1103|      0|    [viewToSwipe dragFromPoint:swipeStart displacement:swipeDisplacement steps:kNumberOfPointsInSwipePath];
 1104|      0|}
 1105|       |
 1106|       |- (void)pullToRefreshViewWithAccessibilityLabel:(NSString *)label
 1107|      0|{
 1108|      0|	[self pullToRefreshViewWithAccessibilityLabel:label value:nil pullDownDuration:0 traits:UIAccessibilityTraitNone];
 1109|      0|}
 1110|       |
 1111|       |- (void)pullToRefreshViewWithAccessibilityLabel:(NSString *)label pullDownDuration:(KIFPullToRefreshTiming) pullDownDuration
 1112|      0|{
 1113|      0|	[self pullToRefreshViewWithAccessibilityLabel:label value:nil pullDownDuration:pullDownDuration traits:UIAccessibilityTraitNone];
 1114|      0|}
 1115|       |
 1116|       |- (void)pullToRefreshViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value
 1117|      0|{
 1118|      0|	[self pullToRefreshViewWithAccessibilityLabel:label value:value pullDownDuration:0 traits:UIAccessibilityTraitNone];
 1119|      0|}
 1120|       |
 1121|       |- (void)pullToRefreshViewWithAccessibilityLabel:(NSString *)label value:(NSString *)value pullDownDuration:(KIFPullToRefreshTiming) pullDownDuration traits:(UIAccessibilityTraits)traits
 1122|      0|{
 1123|      0|	UIView *viewToSwipe = nil;
 1124|      0|	UIAccessibilityElement *element = nil;
 1125|      0|
 1126|      0|	[self waitForAccessibilityElement:&element view:&viewToSwipe withLabel:label value:value traits:traits tappable:YES];
 1127|      0|
 1128|      0|	[self pullToRefreshAccessibilityElement:element inView:viewToSwipe pullDownDuration:pullDownDuration];
 1129|      0|}
 1130|       |
 1131|       |- (void)pullToRefreshAccessibilityElement:(UIAccessibilityElement *)element inView:(UIView *)viewToSwipe pullDownDuration:(KIFPullToRefreshTiming) pullDownDuration
 1132|      0|{
 1133|      0|	//Based on swipeAccessibilityElement
 1134|      0|
 1135|      0|	const NSUInteger kNumberOfPointsInSwipePath = pullDownDuration ? pullDownDuration : KIFPullToRefreshInAboutAHalfSecond;
 1136|      0|
 1137|      0|    // Can handle only the touchable space.
 1138|      0|    CGRect elementFrame = [viewToSwipe convertRect:viewToSwipe.bounds toView:[UIApplication sharedApplication].keyWindow.rootViewController.view];
 1139|      0|    CGPoint swipeStart = CGPointCenteredInRect(elementFrame);
 1140|      0|	CGPoint swipeDisplacement = CGPointMake(CGRectGetMidX(elementFrame), CGRectGetMaxY(elementFrame));
 1141|      0|
 1142|      0|	[viewToSwipe dragFromPoint:swipeStart displacement:swipeDisplacement steps:kNumberOfPointsInSwipePath];
 1143|      0|}
 1144|       |
 1145|       |- (void)scrollViewWithAccessibilityLabel:(NSString *)label byFractionOfSizeHorizontal:(CGFloat)horizontalFraction vertical:(CGFloat)verticalFraction
 1146|      0|{
 1147|      0|    UIView *viewToScroll;
 1148|      0|    UIAccessibilityElement *element;
 1149|      0|    [self waitForAccessibilityElement:&element view:&viewToScroll withLabel:label value:nil traits:UIAccessibilityTraitNone tappable:NO];
 1150|      0|    [self scrollAccessibilityElement:element inView:viewToScroll byFractionOfSizeHorizontal:horizontalFraction vertical:verticalFraction];
 1151|      0|}
 1152|       |
 1153|       |- (void)scrollViewWithAccessibilityIdentifier:(NSString *)identifier byFractionOfSizeHorizontal:(CGFloat)horizontalFraction vertical:(CGFloat)verticalFraction
 1154|      0|{
 1155|      0|    UIView *viewToScroll;
 1156|      0|    UIAccessibilityElement *element;
 1157|      0|    [self waitForAccessibilityElement:&element view:&viewToScroll withIdentifier:identifier tappable:NO];
 1158|      0|    [self scrollAccessibilityElement:element inView:viewToScroll byFractionOfSizeHorizontal:horizontalFraction vertical:verticalFraction];
 1159|      0|}
 1160|       |
 1161|       |- (void)scrollAccessibilityElement:(UIAccessibilityElement *)element inView:(UIView *)viewToScroll byFractionOfSizeHorizontal:(CGFloat)horizontalFraction vertical:(CGFloat)verticalFraction
 1162|      0|{
 1163|      0|    const NSUInteger kNumberOfPointsInScrollPath = 5;
 1164|      0|
 1165|      0|    // Within this method, all geometry is done in the coordinate system of the view to scroll.
 1166|      0|    CGRect elementFrame = [self elementFrameForElement:element andView:viewToScroll];
 1167|      0|
 1168|      0|    KIFDisplacement scrollDisplacement = CGPointMake(elementFrame.size.width * horizontalFraction, elementFrame.size.height * verticalFraction);
 1169|      0|
 1170|      0|    CGPoint scrollStart = CGPointCenteredInRect(elementFrame);
 1171|      0|    scrollStart.x -= scrollDisplacement.x / 2;
 1172|      0|    scrollStart.y -= scrollDisplacement.y / 2;
 1173|      0|
 1174|      0|    [viewToScroll dragFromPoint:scrollStart displacement:scrollDisplacement steps:kNumberOfPointsInScrollPath];
 1175|      0|}
 1176|       |
 1177|       |- (void)waitForFirstResponderWithAccessibilityLabel:(NSString *)label
 1178|      0|{
 1179|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
 1180|      0|        UIResponder *firstResponder = [[[UIApplication sharedApplication] keyWindow] firstResponder];
 1181|      0|        if ([firstResponder isKindOfClass:NSClassFromString(@"UISearchBarTextField")]) {
 1182|      0|            do {
 1183|      0|                firstResponder = [(UIView *)firstResponder superview];
 1184|      0|            } while (firstResponder && ![firstResponder isKindOfClass:[UISearchBar class]]);
 1185|      0|        }
 1186|      0|        KIFTestWaitCondition([[firstResponder accessibilityLabel] isEqualToString:label], error, @"Expected accessibility label for first responder to be '%@', got '%@'", label, [firstResponder accessibilityLabel]);
 1187|      0|        
 1188|      0|        return KIFTestStepResultSuccess;
 1189|      0|    }];
 1190|      0|}
 1191|       |
 1192|       |- (void)waitForFirstResponderWithAccessibilityLabel:(NSString *)label traits:(UIAccessibilityTraits)traits
 1193|      0|{
 1194|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
 1195|      0|        UIResponder *firstResponder = [[[UIApplication sharedApplication] keyWindow] firstResponder];
 1196|      0|        
 1197|      0|        NSString *foundLabel = firstResponder.accessibilityLabel;
 1198|      0|        
 1199|      0|        // foundLabel == label checks for the case where both are nil.
 1200|      0|        KIFTestWaitCondition(foundLabel == label || [foundLabel isEqualToString:label], error, @"Expected accessibility label for first responder to be '%@', got '%@'", label, foundLabel);
 1201|      0|        KIFTestWaitCondition(firstResponder.accessibilityTraits & traits, error, @"Found first responder with accessibility label, but not traits. First responder: %@", firstResponder);
 1202|      0|        
 1203|      0|        return KIFTestStepResultSuccess;
 1204|      0|    }];
 1205|      0|}
 1206|       |
 1207|       |- (UITableViewCell *)waitForCellAtIndexPath:(NSIndexPath *)indexPath inTableViewWithAccessibilityIdentifier:(NSString *)identifier
 1208|      0|{
 1209|      0|    return [self waitForCellAtIndexPath:indexPath inTableViewWithAccessibilityIdentifier:identifier atPosition:UITableViewScrollPositionMiddle];
 1210|      0|}
 1211|       |
 1212|       |- (UITableViewCell *)waitForCellAtIndexPath:(NSIndexPath *)indexPath inTableViewWithAccessibilityIdentifier:(NSString *)identifier atPosition:(UITableViewScrollPosition)position
 1213|      0|{
 1214|      0|    UITableView *tableView;
 1215|      0|    [self waitForAccessibilityElement:NULL view:&tableView withIdentifier:identifier tappable:NO];
 1216|      0|    return [self waitForCellAtIndexPath:indexPath inTableView:tableView atPosition:position];
 1217|      0|}
 1218|       |
 1219|       |- (UITableViewCell *)waitForCellAtIndexPath:(NSIndexPath *)indexPath inTableView:(UITableView *)tableView
 1220|      0|{
 1221|      0|    return [self waitForCellAtIndexPath:indexPath inTableView:tableView atPosition:UITableViewScrollPositionMiddle];
 1222|      0|}
 1223|       |
 1224|       |- (UITableViewCell *)waitForCellAtIndexPath:(NSIndexPath *)indexPath inTableView:(UITableView *)tableView atPosition:(UITableViewScrollPosition)position
 1225|      0|{
 1226|      0|    if (![tableView isKindOfClass:[UITableView class]]) {
 1227|      0|        [self failWithError:[NSError KIFErrorWithFormat:@"View is not a table view"] stopTest:YES];
 1228|      0|    }
 1229|      0|
 1230|      0|    // If section < 0, search from the end of the table.
 1231|      0|    if (indexPath.section < 0) {
 1232|      0|        indexPath = [NSIndexPath indexPathForRow:indexPath.row inSection:tableView.numberOfSections + indexPath.section];
 1233|      0|    }
 1234|      0|
 1235|      0|    // If row < 0, search from the end of the section.
 1236|      0|    if (indexPath.row < 0) {
 1237|      0|        indexPath = [NSIndexPath indexPathForRow:[tableView numberOfRowsInSection:indexPath.section] + indexPath.row inSection:indexPath.section];
 1238|      0|    }
 1239|      0|
 1240|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
 1241|      0|
 1242|      0|        KIFTestWaitCondition(indexPath.section < tableView.numberOfSections, error, @"Section %ld is not found in table view", (long)indexPath.section);
 1243|      0|
 1244|      0|        KIFTestWaitCondition(indexPath.row < [tableView numberOfRowsInSection:indexPath.section], error, @"Row %ld is not found in section %ld of table view", (long)indexPath.row, (long)indexPath.section);
 1245|      0|
 1246|      0|        return KIFTestStepResultSuccess;
 1247|      0|    }];
 1248|      0|
 1249|      0|    __block UITableViewCell *cell = nil;
 1250|      0|    __block CGFloat lastYOffset = CGFLOAT_MAX;
 1251|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
 1252|      0|        [tableView scrollToRowAtIndexPath:indexPath atScrollPosition:position animated:[[self class] testActorAnimationsEnabled]];
 1253|      0|        cell = [tableView cellForRowAtIndexPath:indexPath];
 1254|      0|        KIFTestWaitCondition(!!cell, error, @"Table view cell at index path %@ not found", indexPath);
 1255|      0|        
 1256|      0|        if (lastYOffset != tableView.contentOffset.y) {
 1257|      0|            lastYOffset = tableView.contentOffset.y;
 1258|      0|            KIFTestWaitCondition(NO, error, @"Didn't finish scrolling to cell.");
 1259|      0|        }
 1260|      0|        
 1261|      0|        return KIFTestStepResultSuccess;
 1262|      0|    }];
 1263|      0|
 1264|      0|    [self waitForTimeInterval:0.1 relativeToAnimationSpeed:YES]; // Let things settle.
 1265|      0|
 1266|      0|
 1267|      0|    return cell;
 1268|      0|}
 1269|       |
 1270|       |- (UICollectionViewCell *)waitForCellAtIndexPath:(NSIndexPath *)indexPath inCollectionViewWithAccessibilityIdentifier:(NSString *)identifier
 1271|      0|{
 1272|      0|    UICollectionView *collectionView;
 1273|      0|    [self waitForAccessibilityElement:NULL view:&collectionView withIdentifier:identifier tappable:NO];
 1274|      0|    return [self waitForCellAtIndexPath:indexPath inCollectionView:collectionView];
 1275|      0|}
 1276|       |
 1277|       |- (UICollectionViewCell *)waitForCellAtIndexPath:(NSIndexPath *)indexPath inCollectionView:(UICollectionView *)collectionView
 1278|      0|{
 1279|      0|    if (![collectionView isKindOfClass:[UICollectionView class]]) {
 1280|      0|        [self failWithError:[NSError KIFErrorWithFormat:@"View is not a collection view"] stopTest:YES];
 1281|      0|    }
 1282|      0|
 1283|      0|    NSInteger section = indexPath.section;
 1284|      0|    NSInteger item = indexPath.item;
 1285|      0|
 1286|      0|    // If section < 0, search from the end of the table.
 1287|      0|    if (section < 0) {
 1288|      0|        section += collectionView.numberOfSections;
 1289|      0|    }
 1290|      0|
 1291|      0|    // If item < 0, search from the end of the section.
 1292|      0|    if (item < 0) {
 1293|      0|        item += [collectionView numberOfItemsInSection:section];
 1294|      0|    }
 1295|      0|
 1296|      0|    indexPath = [NSIndexPath indexPathForItem:item inSection:section];
 1297|      0|
 1298|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
 1299|      0|
 1300|      0|        KIFTestWaitCondition(indexPath.section < collectionView.numberOfSections, error, @"Section %ld is not found in collection view", (long)indexPath.section);
 1301|      0|
 1302|      0|        KIFTestWaitCondition(indexPath.row < [collectionView numberOfItemsInSection:indexPath.section], error, @"Item %ld is not found in section %ld of collection view", (long)indexPath.row, (long)indexPath.section);
 1303|      0|
 1304|      0|        return KIFTestStepResultSuccess;
 1305|      0|    }];
 1306|      0|
 1307|      0|    [collectionView scrollToItemAtIndexPath:indexPath
 1308|      0|                           atScrollPosition:UICollectionViewScrollPositionCenteredHorizontally | UICollectionViewScrollPositionCenteredVertically
 1309|      0|                                   animated:[[self class] testActorAnimationsEnabled]];
 1310|      0|
 1311|      0|    // waitForAnimationsToFinish doesn't allow collection view to settle when animations are sped up
 1312|      0|    // So use waitForTimeInterval instead
 1313|      0|    const NSTimeInterval animationWaitTime = 0.5f;
 1314|      0|    [self waitForTimeInterval:animationWaitTime relativeToAnimationSpeed:YES];
 1315|      0|    UICollectionViewCell *cell = [collectionView cellForItemAtIndexPath:indexPath];
 1316|      0|
 1317|      0|    //For big collection views with many cells the cell might not be ready yet. Relayout and try again.
 1318|      0|    if(cell == nil) {
 1319|      0|        [collectionView layoutIfNeeded];
 1320|      0|        [collectionView scrollToItemAtIndexPath:indexPath
 1321|      0|                               atScrollPosition:UICollectionViewScrollPositionCenteredHorizontally | UICollectionViewScrollPositionCenteredVertically
 1322|      0|                                       animated:NO];
 1323|      0|        // waitForAnimationsToFinish doesn't allow collection view to settle when animations are sped up
 1324|      0|        [self waitForTimeInterval:animationWaitTime relativeToAnimationSpeed:YES];
 1325|      0|        cell = [collectionView cellForItemAtIndexPath:indexPath];
 1326|      0|    }
 1327|      0|    
 1328|      0|    if (!cell) {
 1329|      0|        [self failWithError:[NSError KIFErrorWithFormat:@"Collection view cell at index path %@ not found", indexPath] stopTest:YES];
 1330|      0|    }
 1331|      0|
 1332|      0|    return cell;
 1333|      0|}
 1334|       |
 1335|       |- (void)tapStatusBar
 1336|      0|{
 1337|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
 1338|      0|        KIFTestWaitCondition(![UIApplication sharedApplication].statusBarHidden, error, @"Expected status bar to be visible.");
 1339|      0|        return KIFTestStepResultSuccess;
 1340|      0|    }];
 1341|      0|
 1342|      0|    UIWindow *statusBarWindow = [[UIApplication sharedApplication] statusBarWindow];
 1343|      0|    NSArray *statusBars = [statusBarWindow subviewsWithClassNameOrSuperClassNamePrefix:@"UIStatusBar"];
 1344|      0|
 1345|      0|    if (statusBars.count == 0) {
 1346|      0|        [self failWithError:[NSError KIFErrorWithFormat:@"Could not find the status bar"] stopTest:YES];
 1347|      0|    }
 1348|      0|
 1349|      0|    [self tapAccessibilityElement:statusBars[0] inView:statusBars[0]];
 1350|      0|}
 1351|       |
 1352|       |- (void)moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath inTableViewWithAccessibilityIdentifier:(NSString *)identifier
 1353|      0|{
 1354|      0|    UITableView *tableView;
 1355|      0|    [self waitForAccessibilityElement:NULL view:&tableView withIdentifier:identifier tappable:NO];
 1356|      0|    [self moveRowAtIndexPath:sourceIndexPath toIndexPath:destinationIndexPath inTableView:tableView];
 1357|      0|}
 1358|       |
 1359|       |- (void)moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath inTableView:(UITableView *)tableView
 1360|      0|{
 1361|      0|    UITableViewCell *cell = [self waitForCellAtIndexPath:sourceIndexPath inTableView:tableView];
 1362|      0|
 1363|      0|    NSError *error = nil;
 1364|      0|    if (![tableView dragCell:cell toIndexPath:destinationIndexPath error:&error]) {
 1365|      0|        [self failWithError:error stopTest:YES];
 1366|      0|    }
 1367|      0|}
 1368|       |
 1369|      0|- (void)deactivateAppForDuration:(NSTimeInterval)duration {
 1370|      0|    [system deactivateAppForDuration:duration];
 1371|      0|}
 1372|       |
 1373|       |-(void) tapStepperWithAccessibilityLabel: (NSString *)accessibilityLabel increment: (KIFStepperDirection) stepperDirection
 1374|      0|{
 1375|      0|	@autoreleasepool {
 1376|      0|		UIView *view = nil;
 1377|      0|		UIAccessibilityElement *element = nil;
 1378|      0|		[self waitForAccessibilityElement:&element view:&view withLabel:accessibilityLabel value:nil traits:UIAccessibilityTraitNone tappable:YES];
 1379|      0|		[self tapStepperWithAccessibilityElement:element increment:stepperDirection inView:view];
 1380|      0|	}
 1381|      0|}
 1382|       |
 1383|       |//inspired by http://www.raywenderlich.com/61419/ios-ui-testing-with-kif
 1384|       |- (void)tapStepperWithAccessibilityElement:(UIAccessibilityElement *)element increment: (KIFStepperDirection) stepperDirection inView:(UIView *)view
 1385|      0|{
 1386|      0|	[self runBlock:^KIFTestStepResult(NSError **error) {
 1387|      0|
 1388|      0|		KIFTestWaitCondition(view.isUserInteractionActuallyEnabled, error, @"View is not enabled for interaction: %@", view);
 1389|      0|
 1390|      0|        CGPoint stepperPointToTap = [self tappablePointInElement:element andView:view];
 1391|      0|
 1392|      0|		switch (stepperDirection)
 1393|      0|		{
 1394|      0|			case KIFStepperDirectionIncrement:
 1395|      0|				stepperPointToTap.x += CGRectGetWidth(view.frame) / 4;
 1396|      0|				break;
 1397|      0|			case KIFStepperDirectionDecrement:
 1398|      0|				stepperPointToTap.x -= CGRectGetWidth(view.frame) / 4;
 1399|      0|				break;
 1400|      0|		}
 1401|      0|
 1402|      0|		// This is mostly redundant of the test in _accessibilityElementWithLabel:
 1403|      0|		KIFTestWaitCondition(!isnan(stepperPointToTap.x), error, @"View is not tappable: %@", view);
 1404|      0|		[view tapAtPoint:stepperPointToTap];
 1405|      0|
 1406|      0|		KIFTestCondition(![view canBecomeFirstResponder] || [view isDescendantOfFirstResponder], error, @"Failed to make the view into the first responder: %@", view);
 1407|      0|
 1408|      0|		return KIFTestStepResultSuccess;
 1409|      0|	}];
 1410|      0|
 1411|      0|	[self waitForAnimationsToFinish];
 1412|      0|}
 1413|       |
 1414|       |- (CGRect) elementFrameForElement:(UIAccessibilityElement *)element andView:(UIView *)view
 1415|      0|{
 1416|      0|    CGRect elementFrame;
 1417|      0|
 1418|      0|    // If the accessibilityFrame is not set, fallback to the view frame.
 1419|      0|    if (CGRectEqualToRect(CGRectZero, element.accessibilityFrame)) {
 1420|      0|        elementFrame.origin = CGPointZero;
 1421|      0|        elementFrame.size = view.frame.size;
 1422|      0|    } else {
 1423|      0|        elementFrame = [view.windowOrIdentityWindow convertRect:element.accessibilityFrame toView:view];
 1424|      0|    }
 1425|      0|    return elementFrame;
 1426|      0|}
 1427|       |
 1428|       |- (CGPoint) tappablePointInElement:(UIAccessibilityElement *)element andView:(UIView *)view
 1429|      0|{
 1430|      0|    CGRect elementFrame = [self elementFrameForElement:element andView:view];
 1431|      0|    CGPoint tappablePoint = [view tappablePointInRect:elementFrame];
 1432|      0|
 1433|      0|    return tappablePoint;
 1434|      0|}
 1435|       |
 1436|       |- (KIFDisplacement)_displacementForSwipingInDirection:(KIFSwipeDirection)direction;
 1437|      0|{
 1438|      0|    switch (direction) {
 1439|      0|            // As discovered on the Frank mailing lists, it won't register as a
 1440|      0|            // swipe if you move purely horizontally or vertically, so need a
 1441|      0|            // slight orthogonal offset too.
 1442|      0|        case KIFSwipeDirectionRight:
 1443|      0|            return CGPointMake(UIScreen.mainScreen.majorSwipeDisplacement, kKIFMinorSwipeDisplacement);
 1444|      0|        case KIFSwipeDirectionLeft:
 1445|      0|            return CGPointMake(-UIScreen.mainScreen.majorSwipeDisplacement, kKIFMinorSwipeDisplacement);
 1446|      0|        case KIFSwipeDirectionUp:
 1447|      0|            return CGPointMake(kKIFMinorSwipeDisplacement, -UIScreen.mainScreen.majorSwipeDisplacement);
 1448|      0|        case KIFSwipeDirectionDown:
 1449|      0|            return CGPointMake(kKIFMinorSwipeDisplacement, UIScreen.mainScreen.majorSwipeDisplacement);
 1450|      0|    }
 1451|      0|}
 1452|       |
 1453|       |+ (BOOL)testActorAnimationsEnabled;
 1454|      3|{
 1455|      3|    return KIFUITestActorAnimationsEnabled;
 1456|      3|}
 1457|       |
 1458|       |+ (void)setTestActorAnimationsEnabled:(BOOL)animationsEnabled;
 1459|      0|{
 1460|      0|    KIFUITestActorAnimationsEnabled = animationsEnabled;
 1461|      0|}
 1462|       |
 1463|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Classes/KIFUIViewTestActor.m:
    1|       |//
    2|       |//  KIFUIViewActor.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Alex Odawa on 1/21/15.
    6|       |//
    7|       |//
    8|       |
    9|       |#import "KIFUIViewTestActor.h"
   10|       |
   11|       |#import "KIFTestActor_Private.h"
   12|       |#import "KIFUIObject.h"
   13|       |#import "KIFUITestActor_Private.h"
   14|       |#import "NSPredicate+KIFAdditions.h"
   15|       |#import "NSString+KIFAdditions.h"
   16|       |#import "UIAccessibilityElement-KIFAdditions.h"
   17|       |#import "UIApplication-KIFAdditions.h"
   18|       |#import "UIWindow-KIFAdditions.h"
   19|       |
   20|       |@interface KIFUIViewTestActor ()
   21|       |
   22|       |@property (nonatomic, strong, readonly) KIFUITestActor *actor;
   23|       |@property (nonatomic, strong, readwrite) NSPredicate *predicate;
   24|       |@property (nonatomic, assign) BOOL validateEnteredText;
   25|       |
   26|       |@end
   27|       |
   28|       |
   29|       |@implementation KIFUIViewTestActor
   30|       |
   31|       |NSString *const inputFieldTestString = @"Testing";
   32|       |
   33|       |#pragma mark - Initialization
   34|       |
   35|       |- (instancetype)initWithFile:(NSString *)file line:(NSInteger)line delegate:(id<KIFTestActorDelegate>)delegate;
   36|      0|{
   37|      0|    self = [super initWithFile:file line:line delegate:delegate];
   38|      0|    NSParameterAssert(self);
   39|      0|    _validateEnteredText = YES;
   40|      0|    return self;
   41|      0|}
   42|       |
   43|       |#pragma mark - Behavior modifiers
   44|       |
   45|       |- (instancetype)validateEnteredText:(BOOL)validateEnteredText;
   46|      0|{
   47|      0|    self.validateEnteredText = validateEnteredText;
   48|      0|    return self;
   49|      0|}
   50|       |
   51|       |#pragma mark - Searching for Accessibility Elements
   52|       |
   53|       |- (instancetype)usingPredicate:(NSPredicate *)predicate;
   54|      0|{
   55|      0|    [self _appendPredicate:predicate];
   56|      0|    return  self;
   57|      0|}
   58|       |
   59|       |- (instancetype)usingLabel:(NSString *)accessibilityLabel;
   60|      0|{
   61|      0|    int systemVersion = [UIDevice currentDevice].systemVersion.intValue;
   62|      0|    NSPredicate *predicate;
   63|      0|    if ([accessibilityLabel rangeOfString:@"\n"].location == NSNotFound || systemVersion == 6) {
   64|      0|        predicate = [NSPredicate predicateWithBlock:^BOOL(id evaluatedObject, NSDictionary *bindings) {
   65|      0|            id label = [evaluatedObject accessibilityLabel];
   66|      0|            return [accessibilityLabel KIF_isEqualToStringOrAttributedString:label];
   67|      0|        }];
   68|      0|    }
   69|      0|    else {
   70|      0|        // On iOS 6 the accessibility label may contain line breaks, so when trying to find the
   71|      0|        // element, these line breaks are necessary. But on iOS 7 the system replaces them with
   72|      0|        // spaces. So the same test breaks on either iOS 6 or iOS 7. iOS 8 befuddles this again by
   73|      0|        // limiting replacement to spaces in between strings.
   74|      0|        // UNLESS the accessibility label is set programatically in which case the line breaks remain regardless of OS version.
   75|      0|        // To work around this replace the line breaks using the preferred method and try matching both.
   76|      0|        
   77|      0|        __block NSString *alternate = nil;
   78|      0|        if (systemVersion == 7) {
   79|      0|            alternate = [accessibilityLabel stringByReplacingOccurrencesOfString:@"\n" withString:@" "];
   80|      0|        } else {
   81|      0|            alternate = [accessibilityLabel stringByReplacingOccurrencesOfString:@"\\b\\n\\b" withString:@" " options:NSRegularExpressionSearch range:NSMakeRange(0, accessibilityLabel.length)];
   82|      0|        }
   83|      0|        
   84|      0|        predicate = [NSPredicate predicateWithBlock:^BOOL(id evaluatedObject, NSDictionary *bindings) {
   85|      0|            id label = [evaluatedObject accessibilityLabel];
   86|      0|            return ([accessibilityLabel KIF_isEqualToStringOrAttributedString:label] || [alternate KIF_isEqualToStringOrAttributedString:label]);
   87|      0|        }];
   88|      0|    }
   89|      0|    predicate.kifPredicateDescription = [NSString stringWithFormat:@"Accessibility label equal to \"%@\"", accessibilityLabel];
   90|      0|    return [self usingPredicate:predicate];
   91|      0|}
   92|       |
   93|       |- (instancetype)usingIdentifier:(NSString *)accessibilityIdentifier;
   94|      0|{
   95|      0|    NSPredicate *predicate = [NSPredicate predicateWithBlock:^BOOL(id evaluatedObject, NSDictionary *bindings) {
   96|      0|        id identifier = [evaluatedObject accessibilityIdentifier];
   97|      0|
   98|      0|        return [accessibilityIdentifier KIF_isEqualToStringOrAttributedString:identifier];
   99|      0|    }];
  100|      0|    
  101|      0|    predicate.kifPredicateDescription = [NSString stringWithFormat:@"Accessibility identifier equal to \"%@\"", accessibilityIdentifier];
  102|      0|
  103|      0|    return [self usingPredicate:predicate];
  104|      0|}
  105|       |
  106|       |- (instancetype)usingTraits:(UIAccessibilityTraits)accessibilityTraits;
  107|      0|{
  108|      0|    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"(accessibilityTraits & %@) == %@", @(accessibilityTraits), @(accessibilityTraits)];
  109|      0|    predicate.kifPredicateDescription = [NSString stringWithFormat:@"Accessibility traits including \"%@\"", [UIAccessibilityElement stringFromAccessibilityTraits:accessibilityTraits]];
  110|      0|    
  111|      0|    return [self usingPredicate:predicate];
  112|      0|}
  113|       |
  114|       |- (instancetype)usingAbsenceOfTraits:(UIAccessibilityTraits)accessibilityTraits;
  115|      0|{
  116|      0|    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"(accessibilityTraits & %@) != %@", @(accessibilityTraits), @(accessibilityTraits)];
  117|      0|    predicate.kifPredicateDescription = [NSString stringWithFormat:@"Accessibility traits excluding \"%@\"", [UIAccessibilityElement stringFromAccessibilityTraits:accessibilityTraits]];
  118|      0|
  119|      0|    return [self usingPredicate:predicate];
  120|      0|}
  121|       |
  122|       |- (instancetype)usingValue:(NSString *)accessibilityValue;
  123|      0|{
  124|      0|    NSPredicate *predicate = [NSPredicate predicateWithBlock:^BOOL(id evaluatedObject, NSDictionary *bindings) {
  125|      0|        NSString *value = [evaluatedObject accessibilityValue];
  126|      0|        if ([value isKindOfClass:[NSAttributedString class]]) {
  127|      0|            value = [(NSAttributedString *)value string];
  128|      0|        }
  129|      0|        return [value isEqualToString:accessibilityValue];
  130|      0|    }];
  131|      0|    predicate.kifPredicateDescription = [NSString stringWithFormat:@"Accessibility Value equal to \"%@\"", accessibilityValue];
  132|      0|    
  133|      0|    return [self usingPredicate:predicate];
  134|      0|}
  135|       |
  136|       |- (instancetype)usingFirstResponder;
  137|      0|{
  138|      0|    NSPredicate *predicate = [NSPredicate predicateWithBlock:^BOOL(id evaluatedObject, NSDictionary *bindings) {
  139|      0|        // The current first responder can be in any application window
  140|      0|        for (UIWindow *window in [[UIApplication sharedApplication] windowsWithKeyWindow]) {
  141|      0|            if ([evaluatedObject isEqual:window.firstResponder]) {
  142|      0|                return YES;
  143|      0|            }
  144|      0|        }
  145|      0|        return NO;
  146|      0|    }];
  147|      0|    predicate.kifPredicateDescription = [NSString stringWithFormat:@"Is First Responder"];
  148|      0|    
  149|      0|    return [self usingPredicate:predicate];
  150|      0|}
  151|       |
  152|       |#pragma mark - System Actions
  153|       |
  154|       |#if TARGET_IPHONE_SIMULATOR
  155|       |- (BOOL)acknowledgeSystemAlert;
  156|      0|{
  157|      0|    return [self.actor acknowledgeSystemAlert];
  158|      0|}
  159|       |#endif
  160|       |
  161|       |- (void)tapStatusBar;
  162|      0|{
  163|      0|    [self.actor tapStatusBar];
  164|      0|}
  165|       |
  166|       |- (void)dismissPopover;
  167|      0|{
  168|      0|    [self.actor dismissPopover];
  169|      0|}
  170|       |
  171|       |#pragma mark - Waiting
  172|       |
  173|       |- (UIView *)waitForView;
  174|      0|{
  175|      0|    return [self _predicateSearchWithRequiresMatch:YES mustBeTappable:NO].view;
  176|      0|}
  177|       |
  178|       |- (void)waitForAbsenceOfView;
  179|      0|{
  180|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
  181|      0|        // If the app is ignoring interaction events, then wait before doing our analysis
  182|      0|        KIFTestWaitCondition(![[UIApplication sharedApplication] isIgnoringInteractionEvents], error, @"Application is ignoring interaction events.");
  183|      0|        
  184|      0|        // If the element can't be found, then we're done
  185|      0|        KIFUIObject *found = [self _predicateSearchWithRequiresMatch:NO mustBeTappable:NO];
  186|      0|        if (!found) {
  187|      0|            return KIFTestStepResultSuccess;
  188|      0|        }
  189|      0|        
  190|      0|        // If we found an element, but it's not associated with a view, then something's wrong. Wait it out and try again.
  191|      0|        KIFTestWaitCondition(found.view, error, @"Cannot find view containing accessibility element \"%@\"", found.element);
  192|      0|        
  193|      0|        // Hidden views count as absent
  194|      0|        KIFTestWaitCondition([found.view isHidden] || [found.view superview] == nil, error, @"Accessibility element \"%@\" is visible and not hidden.", found);
  195|      0|        
  196|      0|        return KIFTestStepResultSuccess;
  197|      0|    }];
  198|      0|}
  199|       |
  200|       |- (UIView *)waitForTappableView;
  201|      0|{
  202|      0|    return [self _predicateSearchWithRequiresMatch:YES mustBeTappable:YES].view;
  203|      0|}
  204|       |
  205|       |- (void)waitToBecomeTappable;
  206|      0|{
  207|      0|    [self _predicateSearchWithRequiresMatch:YES mustBeTappable:YES];
  208|      0|}
  209|       |
  210|       |- (void)waitToBecomeFirstResponder;
  211|      0|{
  212|      0|    [self runBlock:^KIFTestStepResult(NSError **error) {
  213|      0|        UIResponder *firstResponder = [[[UIApplication sharedApplication] keyWindow] firstResponder];
  214|      0|
  215|      0|        KIFTestWaitCondition([self.predicate evaluateWithObject:firstResponder], error, @"Expected first responder to match '%@', got '%@'", self.predicate, firstResponder);
  216|      0|        return KIFTestStepResultSuccess;
  217|      0|    }];
  218|      0|}
  219|       |
  220|       |- (void)waitForAnimationsToFinish;
  221|      0|{
  222|      0|    [self.actor waitForAnimationsToFinishWithTimeout:self.animationWaitingTimeout stabilizationTime:self.animationStabilizationTimeout];
  223|      0|}
  224|       |
  225|       |#pragma mark Typist Waiting
  226|       |
  227|       |- (void)waitForSoftwareKeyboard;
  228|      0|{
  229|      0|    [self.actor waitForSoftwareKeyboard];
  230|      0|}
  231|       |- (void)waitForAbsenceOfSoftwareKeyboard;
  232|      0|{
  233|      0|    [self.actor waitForAbsenceOfSoftwareKeyboard];
  234|      0|}
  235|       |- (void)waitForKeyInputReady;
  236|      0|{
  237|      0|    [self.actor waitForKeyInputReady];
  238|      0|}
  239|       |
  240|       |#pragma mark - Conditionals
  241|       |
  242|       |- (BOOL)tryFindingView;
  243|      0|{
  244|      0|    return ([self _predicateSearchWithRequiresMatch:NO mustBeTappable:NO] != nil);
  245|      0|}
  246|       |
  247|       |- (BOOL)tryFindingTappableView;
  248|      0|{
  249|      0|    return ([self _predicateSearchWithRequiresMatch:NO mustBeTappable:YES] != nil);
  250|      0|}
  251|       |
  252|       |
  253|       |#pragma mark - Tap Actions
  254|       |
  255|       |- (void)tap;
  256|      0|{
  257|      0|    @autoreleasepool {
  258|      0|        KIFUIObject *found = [self _predicateSearchWithRequiresMatch:YES mustBeTappable:YES];
  259|      0|        [self.actor tapAccessibilityElement:found.element inView:found.view];
  260|      0|    }
  261|      0|}
  262|       |
  263|       |- (void)longPress;
  264|      0|{
  265|      0|    [self longPressWithDuration:.5];
  266|      0|}
  267|       |
  268|       |- (void)longPressWithDuration:(NSTimeInterval)duration;
  269|      0|{
  270|      0|    @autoreleasepool {
  271|      0|        KIFUIObject *found = [self _predicateSearchWithRequiresMatch:YES mustBeTappable:YES];
  272|      0|        [self.actor longPressAccessibilityElement:found.element inView:found.view duration:duration];
  273|      0|    }
  274|      0|}
  275|       |
  276|       |#pragma mark - Text Actions;
  277|       |
  278|       |- (void)clearText;
  279|      0|{
  280|      0|    @autoreleasepool {
  281|      0|        KIFUIObject *found = [self _predicateSearchWithRequiresMatch:YES mustBeTappable:NO];
  282|      0|        [self.actor clearTextFromElement:found.element inView:found.view];
  283|      0|    }
  284|      0|}
  285|       |
  286|       |- (void)clearTextFromFirstResponder;
  287|      0|{
  288|      0|    [self.actor clearTextFromFirstResponder];
  289|      0|}
  290|       |
  291|       |- (void)enterText:(NSString *)text;
  292|      0|{
  293|      0|    [self enterText:text expectedResult:nil];
  294|      0|}
  295|       |
  296|       |- (void)enterText:(NSString *)text expectedResult:(NSString *)expectedResult;
  297|      0|{
  298|      0|    if (!self.validateEnteredText && expectedResult) {
  299|      0|        [self failWithMessage:@"Can't supply an expectedResult string if `validateEnteredText` is NO."];
  300|      0|    }
  301|      0|
  302|      0|    @autoreleasepool {
  303|      0|        KIFUIObject *found = [self _predicateSearchWithRequiresMatch:YES mustBeTappable:NO];
  304|      0|        [self.actor enterText:text intoElement:found.element inView:found.view expectedResult:expectedResult];
  305|      0|    }
  306|      0|}
  307|       |
  308|       |- (void)clearAndEnterText:(NSString *)text;
  309|      0|{
  310|      0|    [self clearAndEnterText:text expectedResult:nil];
  311|      0|}
  312|       |
  313|       |- (void)clearAndEnterText:(NSString *)text expectedResult:(NSString *)expectedResult;
  314|      0|{
  315|      0|    [self clearText];
  316|      0|    [self enterText:text expectedResult:expectedResult];
  317|      0|}
  318|       |
  319|       |- (void)enterTextIntoCurrentFirstResponder:(NSString *)text;
  320|      0|{
  321|      0|    [self.actor enterTextIntoCurrentFirstResponder:text];
  322|      0|}
  323|       |
  324|       |- (void)enterTextIntoCurrentFirstResponder:(NSString *)text fallbackView:(UIView *)fallbackView;
  325|      0|{
  326|      0|    [self.actor enterTextIntoCurrentFirstResponder:text fallbackView:fallbackView];
  327|      0|}
  328|       |
  329|       |- (void)setText:(NSString *)text;
  330|      0|{
  331|      0|    [self runBlock:^KIFTestStepResult(NSError *__autoreleasing *error) {
  332|      0|        KIFUIObject *found = [self _predicateSearchWithRequiresMatch:YES mustBeTappable:NO];
  333|      0|        if (!found.view) {
  334|      0|            return KIFTestStepResultWait;
  335|      0|        }
  336|      0|
  337|      0|        if (![found.view respondsToSelector:@selector(setText:)]) {
  338|      0|            return KIFTestStepResultFailure;
  339|      0|        }
  340|      0|
  341|      0|        [found.view performSelector:@selector(setText:) withObject:text];
  342|      0|        return KIFTestStepResultSuccess;
  343|      0|    }];
  344|      0|}
  345|       |
  346|       |- (void)expectToContainText:(NSString *)expectedResult;
  347|      0|{
  348|      0|    @autoreleasepool {
  349|      0|        KIFUIObject *found = [self _predicateSearchWithRequiresMatch:YES mustBeTappable:NO];
  350|      0|        [self.actor expectView:found.view toContainText:expectedResult];
  351|      0|    }
  352|      0|}
  353|       |
  354|       |#pragma mark - Touch Actions
  355|       |
  356|       |- (void)tapScreenAtPoint:(CGPoint)screenPoint;
  357|      0|{
  358|      0|    [self.actor tapScreenAtPoint:screenPoint];
  359|      0|}
  360|       |
  361|       |- (void)swipeInDirection:(KIFSwipeDirection)direction;
  362|      0|{
  363|      0|    @autoreleasepool {
  364|      0|        KIFUIObject *found = [self _predicateSearchWithRequiresMatch:YES mustBeTappable:NO];
  365|      0|        [self.actor swipeAccessibilityElement:found.element inView:found.view inDirection:direction];
  366|      0|    }
  367|      0|}
  368|       |
  369|       |#pragma mark - Scroll/Table/CollectionView Actions
  370|       |
  371|       |- (void)scrollByFractionOfSizeHorizontal:(CGFloat)horizontalFraction vertical:(CGFloat)verticalFraction;
  372|      0|{
  373|      0|    @autoreleasepool {
  374|      0|        KIFUIObject *found = [self _predicateSearchWithRequiresMatch:YES mustBeTappable:NO];
  375|      0|        [self.actor scrollAccessibilityElement:found.element inView:found.view byFractionOfSizeHorizontal:horizontalFraction vertical:verticalFraction];
  376|      0|    }
  377|      0|}
  378|       |
  379|       |- (void)tapRowInTableViewAtIndexPath:(NSIndexPath *)indexPath;
  380|      0|{
  381|      0|    @autoreleasepool {
  382|      0|        KIFUIObject *found = [[self _usingExpectedClass:[UITableView class]] _predicateSearchWithRequiresMatch:YES mustBeTappable:NO];
  383|      0|        [self.actor tapRowAtIndexPath:indexPath inTableView:(UITableView *)found.view];
  384|      0|    }
  385|      0|}
  386|       |
  387|       |- (UITableViewCell *)waitForCellInTableViewAtIndexPath:(NSIndexPath *)indexPath;
  388|      0|{
  389|      0|    return [self waitForCellInTableViewAtIndexPath:indexPath atPosition:UITableViewScrollPositionMiddle];
  390|      0|}
  391|       |
  392|       |- (UITableViewCell *)waitForCellInTableViewAtIndexPath:(NSIndexPath *)indexPath atPosition:(UITableViewScrollPosition)position;
  393|      0|{
  394|      0|    @autoreleasepool {
  395|      0|        KIFUIObject *found = [[self _usingExpectedClass:[UITableView class]] _predicateSearchWithRequiresMatch:YES mustBeTappable:NO];
  396|      0|        return [self.actor waitForCellAtIndexPath:indexPath inTableView:(UITableView *)found.view atPosition:position];
  397|      0|    }
  398|      0|}
  399|       |
  400|       |- (void)moveRowInTableViewAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath;
  401|      0|{
  402|      0|    @autoreleasepool {
  403|      0|        KIFUIObject *found = [[self _usingExpectedClass:[UITableView class]] _predicateSearchWithRequiresMatch:YES mustBeTappable:NO];
  404|      0|        [self.actor moveRowAtIndexPath:sourceIndexPath toIndexPath:destinationIndexPath inTableView:(UITableView *)found.view];
  405|      0|    }
  406|      0|}
  407|       |
  408|       |
  409|       |- (void)tapCollectionViewItemAtIndexPath:(NSIndexPath *)indexPath;
  410|      0|{
  411|      0|    @autoreleasepool {
  412|      0|        KIFUIObject *found = [[self _usingExpectedClass:[UICollectionView class]] _predicateSearchWithRequiresMatch:YES mustBeTappable:NO];
  413|      0|        [self.actor tapItemAtIndexPath:indexPath inCollectionView:(UICollectionView *)found.view];
  414|      0|    }
  415|      0|}
  416|       |
  417|       |- (UICollectionViewCell *)waitForCellInCollectionViewAtIndexPath:(NSIndexPath *)indexPath;
  418|      0|{
  419|      0|    @autoreleasepool {
  420|      0|        KIFUIObject *found = [[self _usingExpectedClass:[UICollectionView class]] _predicateSearchWithRequiresMatch:YES mustBeTappable:NO];
  421|      0|        return [self.actor waitForCellAtIndexPath:indexPath inCollectionView:(UICollectionView *)found.view];
  422|      0|    }
  423|      0|}
  424|       |
  425|       |
  426|       |#pragma mark - UIControl Actions
  427|       |
  428|       |- (void)setSliderValue:(float)value;
  429|      0|{
  430|      0|    @autoreleasepool {
  431|      0|        KIFUIObject *found = [[self _usingExpectedClass:[UISlider class]] _predicateSearchWithRequiresMatch:YES mustBeTappable:NO];
  432|      0|        [self.actor setValue:value forSlider:(UISlider *)found.view];
  433|      0|    }
  434|      0|}
  435|       |
  436|       |- (void)setSwitchOn:(BOOL)switchIsOn;
  437|      0|{
  438|      0|    @autoreleasepool {
  439|      0|        KIFUIObject *found = [[self _usingExpectedClass:[UISwitch class]] _predicateSearchWithRequiresMatch:YES mustBeTappable:NO];
  440|      0|        [self.actor setSwitch:(UISwitch *)found.view element:found.element On:switchIsOn];
  441|      0|    }
  442|      0|}
  443|       |
  444|       |#pragma mark - Picker Actions
  445|       |
  446|       |- (void)selectPickerViewRowWithTitle:(NSString *)title;
  447|      0|{
  448|      0|    [self selectPickerViewRowWithTitle:title inComponent:0];
  449|      0|}
  450|       |
  451|       |- (void)selectPickerViewRowWithTitle:(NSString *)title inComponent:(NSInteger)component;
  452|      0|{
  453|      0|    @autoreleasepool {
  454|      0|        KIFUIObject *found = [[self _usingExpectedClass:[UIPickerView class]] _predicateSearchWithRequiresMatch:YES mustBeTappable:NO];
  455|      0|        UIPickerView *picker = (UIPickerView *) found.view;
  456|      0|        [self.actor selectPickerViewRowWithTitle:title inComponent:component fromPicker:picker withSearchOrder:KIFPickerSearchForwardFromStart];
  457|      0|    }
  458|      0|}
  459|       |
  460|       |- (void)selectDatePickerViewRowWithTitle:(NSString *)title inComponent:(NSInteger)component;
  461|      0|{
  462|      0|    @autoreleasepool {
  463|      0|        KIFUIObject *found = [[self _usingExpectedClass:[UIDatePicker class]] _predicateSearchWithRequiresMatch:YES mustBeTappable:NO];
  464|      0|        UIPickerView *picker = [self _getDatePickerViewFromPicker:found.view];
  465|      0|        [self.actor selectPickerViewRowWithTitle:title inComponent:component fromPicker:picker withSearchOrder:KIFPickerSearchForwardFromStart];
  466|      0|    }
  467|      0|}
  468|       |
  469|       |- (void)selectDatePickerValue:(NSArray *)datePickerColumnValues;
  470|      0|{
  471|      0|    [self selectDatePickerValue:datePickerColumnValues withSearchOrder:KIFPickerSearchForwardFromStart];
  472|      0|}
  473|       |
  474|       |- (void)selectDatePickerValue:(NSArray *)datePickerColumnValues withSearchOrder:(KIFPickerSearchOrder)searchOrder;
  475|      0|{
  476|      0|    @autoreleasepool {
  477|      0|        KIFUIObject *found = [[self _usingExpectedClass:[UIDatePicker class]] _predicateSearchWithRequiresMatch:NO mustBeTappable:NO];
  478|      0|        UIPickerView *picker = [self _getDatePickerViewFromPicker:found.view];
  479|      0|        [self.actor selectDatePickerValue:datePickerColumnValues fromPicker:picker withSearchOrder:searchOrder];
  480|      0|    }
  481|      0|}
  482|       |
  483|       |#pragma mark - Photo Picker
  484|       |
  485|       |- (void)choosePhotoInAlbum:(NSString *)albumName atRow:(NSInteger)row column:(NSInteger)column;
  486|      0|{
  487|      0|    [self.actor choosePhotoInAlbum:albumName atRow:row column:column];
  488|      0|}
  489|       |
  490|       |#pragma mark - Pull to Refresh
  491|       |
  492|       |- (void)pullToRefresh;
  493|      0|{
  494|      0|    @autoreleasepool {
  495|      0|        KIFUIObject *found = [self _predicateSearchWithRequiresMatch:YES mustBeTappable:NO];
  496|      0|        [self.actor pullToRefreshAccessibilityElement:found.element inView:found.view pullDownDuration:0];
  497|      0|    }
  498|      0|}
  499|       |
  500|       |- (void)pullToRefreshWithDuration:(KIFPullToRefreshTiming)pullDownDuration;
  501|      0|{
  502|      0|    @autoreleasepool {
  503|      0|        KIFUIObject *found = [self _predicateSearchWithRequiresMatch:YES mustBeTappable:NO];
  504|      0|        [self.actor pullToRefreshAccessibilityElement:found.element inView:found.view pullDownDuration:pullDownDuration];
  505|      0|    }
  506|      0|}
  507|       |
  508|       |#pragma mark - Getters
  509|       |
  510|       |- (UIView *)view;
  511|      0|{
  512|      0|    return [self _predicateSearchWithRequiresMatch:YES mustBeTappable:NO].view;
  513|      0|}
  514|       |
  515|       |- (UIAccessibilityElement *)element;
  516|      0|{
  517|      0|    return [self _predicateSearchWithRequiresMatch:YES mustBeTappable:NO].element;
  518|      0|}
  519|       |
  520|       |- (KIFUITestActor *)actor;
  521|      0|{
  522|      0|    return [[[[[KIFUITestActor actorInFile:self.file atLine:self.line delegate:self.delegate] usingTimeout:self.executionBlockTimeout] usingAnimationWaitingTimeout:self.animationWaitingTimeout] usingAnimationStabilizationTimeout:self.animationStabilizationTimeout] validateEnteredText:self.validateEnteredText];
  523|      0|}
  524|       |
  525|       |#pragma mark - NSObject
  526|       |
  527|       |- (NSString *)description;
  528|      0|{
  529|      0|    KIFUIObject *found = [self _predicateSearchWithRequiresMatch:YES mustBeTappable:NO];
  530|      0|    return [NSString stringWithFormat:@"<%@; view=%@; element=%@; predicate=%@>", [super description], found.view, found.element, self.predicate];
  531|      0|}
  532|       |
  533|       |#pragma mark - Private Methods
  534|       |
  535|       |- (instancetype)_usingExpectedClass:(Class)expectedClass;
  536|      0|{
  537|      0|    NSPredicate *predicate = [NSPredicate predicateWithBlock:^BOOL(id evaluatedObject, NSDictionary *bindings) {
  538|      0|        return [evaluatedObject isKindOfClass:expectedClass];
  539|      0|    }];
  540|      0|    
  541|      0|    predicate.kifPredicateDescription = [NSString stringWithFormat:@"is kind of Class \"%@\"", NSStringFromClass(expectedClass)];
  542|      0|    return [self usingPredicate:predicate];
  543|      0|}
  544|       |
  545|       |- (void)_appendPredicate:(NSPredicate *)newPredicate;
  546|      0|{
  547|      0|    if (!self.predicate) {
  548|      0|        self.predicate = newPredicate;
  549|      0|    } else {
  550|      0|        NSPredicate *compoundPredicate = [NSCompoundPredicate andPredicateWithSubpredicates:@[ self.predicate, newPredicate ]];
  551|      0|        self.predicate = compoundPredicate;
  552|      0|    }
  553|      0|}
  554|       |
  555|       |- (UIPickerView *)_getDatePickerViewFromPicker:(UIView *)picker;
  556|      0|{
  557|      0|    for (UIView *view in picker.subviews) {
  558|      0|        if ([NSStringFromClass([view class]) hasPrefix:@"_UIDatePickerView"]) {
  559|      0|            return (UIPickerView *) view;
  560|      0|        }
  561|      0|    }
  562|      0|    return nil;
  563|      0|}
  564|       |
  565|       |- (KIFUIObject *)_predicateSearchWithRequiresMatch:(BOOL)requiresMatch mustBeTappable:(BOOL)tappable;
  566|      0|{
  567|      0|    __block UIView *foundView = nil;
  568|      0|    __block UIAccessibilityElement *foundElement = nil;
  569|      0|
  570|      0|    if (requiresMatch) {
  571|      0|        [self.actor waitForAccessibilityElement:&foundElement view:&foundView withElementMatchingPredicate:self.predicate tappable:tappable];
  572|      0|    } else {
  573|      0|        NSError *error;
  574|      0|        [self tryRunningBlock:^KIFTestStepResult(NSError **error) {
  575|      0|            KIFTestWaitCondition([self.actor tryFindingAccessibilityElement:&foundElement view:&foundView withElementMatchingPredicate:self.predicate tappable:tappable error:error], error, @"Waiting on view matching %@", self.predicate.kifPredicateDescription);
  576|      0|            return KIFTestStepResultSuccess;
  577|      0|        } complete:nil timeout:1.0 error:&error];
  578|      0|    }
  579|      0|
  580|      0|    if (foundView && foundElement) {
  581|      0|        return [[KIFUIObject alloc] initWithElement:foundElement view:foundView];
  582|      0|    }
  583|      0|    return nil;
  584|      0|}
  585|       |
  586|       |@end

/Users/salgado/Documents/iOSProj/TesteiOSv2/Bank App/Pods/KIF/Classes/UIAutomationHelper.m:
    1|       |//
    2|       |//  UIAutomationHelper.m
    3|       |//  KIF
    4|       |//
    5|       |//  Created by Joe Masilotti on 12/1/14.
    6|       |//
    7|       |//
    8|       |
    9|       |#import "UIAutomationHelper.h"
   10|       |#import <dlfcn.h>
   11|       |#import <objc/runtime.h>
   12|       |#import "UIApplication-KIFAdditions.h"
   13|       |
   14|       |@interface UIAXElement : NSObject
   15|       |- (BOOL)isValid;
   16|       |@end
   17|       |
   18|       |@interface UIAElement : NSObject <NSCopying>
   19|       |- (void)tap;
   20|       |- (void)tapWithOptions:(NSDictionary *)options;
   21|       |- (NSNumber *)pid;
   22|       |- (UIAXElement *)uiaxElement;
   23|       |@end
   24|       |
   25|       |@interface UIAElementArray : NSArray
   26|       |- (id)firstWithPredicate:(id)predicate;
   27|       |@end
   28|       |
   29|       |@interface UIAAlert : UIAElement
   30|       |- (NSArray *)buttons;
   31|       |- (BOOL)isValid;
   32|       |- (BOOL)isVisible;
   33|       |@end
   34|       |
   35|       |@interface UIAApplication : UIAElement
   36|       |- (UIAAlert *)alert;
   37|       |- (NSString *)name;
   38|       |- (id)appItemScrollView;
   39|       |@end
   40|       |
   41|       |@interface UIATarget : UIAElement
   42|       |+ (UIATarget *)localTarget;
   43|       |- (UIAApplication *)frontMostApp;
   44|       |- (void)deactivateAppForDuration:(NSNumber *)duration;
   45|       |@end
   46|       |
   47|       |@interface UIAElementNil : UIAElement
   48|       |
   49|       |@end
   50|       |
   51|       |@implementation UIAutomationHelper
   52|       |
   53|       |static UIAApplication * (*frontMostAppIMP)(id, SEL);
   54|       |static id (*firstWithPredicateIMP)(id, SEL, id);
   55|       |
   56|       |static UIAApplication * KIF_frontMostApp(id self, SEL _cmd)
   57|      0|{
   58|      0|    UIAApplication *frontMostApp = frontMostAppIMP(self, _cmd);
   59|      0|    if (![frontMostApp name] && [@(getpid()) isEqual:[frontMostApp pid]]) {
   60|      0|        NSBundle *mainBundle = [NSBundle mainBundle];
   61|      0|        NSString *appName = [mainBundle objectForInfoDictionaryKey:@"CFBundleDisplayName"] ?: [mainBundle objectForInfoDictionaryKey:@"CFBundleName"];
   62|      0|        [frontMostApp setValue:appName forKey:@"name"];
   63|      0|    }
   64|      0|    return frontMostApp;
   65|      0|}
   66|       |
   67|       |static id KIF_firstWithPredicate(id self, SEL _cmd, id predicate)
   68|      0|{
   69|      0|    NSArray *callStackSymbols = [NSThread callStackSymbols];
   70|      0|    if (callStackSymbols.count > 1 && [callStackSymbols[1] containsString:@"-[UIATarget reactivateApp]"]) {
   71|      0|        id firstWithPredicate = firstWithPredicateIMP(self, _cmd, predicate);
   72|      0|        // -[UIATarget reactivateApp] was not rewritten for the new iOS 9 app switcher
   73|      0|        return [firstWithPredicate isValid] ? firstWithPredicate : [[[[UIAutomationHelper sharedHelper] target] frontMostApp] appItemScrollView];
   74|      0|    } else {
   75|      0|        return firstWithPredicateIMP(self, _cmd, predicate);
   76|      0|    }
   77|      0|}
   78|       |
   79|       |static void FixReactivateApp(void)
   80|      0|{
   81|      0|    NSProcessInfo *processInfo = [NSProcessInfo processInfo];
   82|      0|    if ([processInfo respondsToSelector:@selector(isOperatingSystemAtLeastVersion:)] && [processInfo isOperatingSystemAtLeastVersion:(NSOperatingSystemVersion){9, 0, 0}]) {
   83|      0|        // Workaround bug in iOS 9: https://github.com/kif-framework/KIF/issues/703
   84|      0|        Method frontMostApp = class_getInstanceMethod(objc_lookUpClass("UIATarget"), @selector(frontMostApp));
   85|      0|        frontMostAppIMP = (__typeof__(frontMostAppIMP))method_getImplementation(frontMostApp);
   86|      0|        method_setImplementation(frontMostApp, (IMP)KIF_frontMostApp);
   87|      0|        
   88|      0|        Method firstWithPredicate = class_getInstanceMethod(objc_lookUpClass("UIAElementArray"), @selector(firstWithPredicate:));
   89|      0|        firstWithPredicateIMP = (__typeof__(firstWithPredicateIMP))method_getImplementation(firstWithPredicate);
   90|      0|        method_setImplementation(firstWithPredicate, (IMP)KIF_firstWithPredicate);
   91|      0|    }
   92|      0|}
   93|       |
   94|       |+ (UIAutomationHelper *)sharedHelper
   95|      0|{
   96|      0|    static dispatch_once_t once;
   97|      0|    static UIAutomationHelper *sharedHelper = nil;
   98|      0|    dispatch_once(&once, ^{
   99|      0|        sharedHelper = [[self alloc] init];
  100|      0|        [sharedHelper linkAutomationFramework];
  101|      0|    });
  102|      0|    return sharedHelper;
  103|      0|}
  104|       |
  105|      0|+ (BOOL)acknowledgeSystemAlert {
  106|      0|    return [[self sharedHelper] acknowledgeSystemAlert];
  107|      0|}
  108|       |
  109|      0|+ (BOOL)acknowledgeSystemAlertWithIndex:(NSUInteger)index {
  110|      0|    return [[self sharedHelper] acknowledgeSystemAlertWithIndex:index];
  111|      0|}
  112|       |
  113|      0|+ (void)deactivateAppForDuration:(NSNumber *)duration {
  114|      0|    [[self sharedHelper] deactivateAppForDuration:duration];
  115|      0|}
  116|       |
  117|      0|- (BOOL)acknowledgeSystemAlert {
  118|      0|	UIAAlert* alert = [[self target] frontMostApp].alert;
  119|      0|    // Even though `acknowledgeSystemAlertWithIndex:` checks the index, we have to have
  120|      0|    // an additional check here to ensure that when `alert.buttons.count` is 0, subtracting one doesn't cause a wrap-around (2^63 - 1).
  121|      0|    if (alert.buttons.count > 0) {
  122|      0|        return [self acknowledgeSystemAlertWithIndex:alert.buttons.count - 1];
  123|      0|    }
  124|      0|    return NO;
  125|      0|}
  126|       |
  127|       |// Inspired by:  https://github.com/jamesjn/KIF/tree/acknowledge-location-alert
  128|      0|- (BOOL)acknowledgeSystemAlertWithIndex:(NSUInteger)index {
  129|      0|    UIAApplication *application = [[self target] frontMostApp];
  130|      0|    UIAAlert *alert = application.alert;
  131|      0|    BOOL isIndexInRange = index < alert.buttons.count;
  132|      0|    if (![alert isKindOfClass:[self nilElementClass]] && [self _alertIsValidAndVisible:alert] && isIndexInRange) {
  133|      0|        [alert.buttons[index] tap];
  134|      0|        while ([self _alertIsValidAndVisible:alert]) {
  135|      0|            // Wait for button press to complete.
  136|      0|            KIFRunLoopRunInModeRelativeToAnimationSpeed(UIApplicationCurrentRunMode, 0.1, false);
  137|      0|        }
  138|      0|        // Wait for alert dismissial animation.
  139|      0|        KIFRunLoopRunInModeRelativeToAnimationSpeed(UIApplicationCurrentRunMode, 0.4, false);
  140|      0|        return YES;
  141|      0|    }
  142|      0|    return NO;
  143|      0|}
  144|       |
  145|      0|- (void)deactivateAppForDuration:(NSNumber *)duration {
  146|      0|    @try {
  147|      0|        [[self target] deactivateAppForDuration:duration];
  148|      0|    }
  149|      0|    @catch(NSException *e) {
  150|      0|        #pragma clang diagnostic push
  151|      0|        #pragma clang diagnostic ignored "-Wunused-variable"
  152|      0|        NSOperatingSystemVersion iOS11 = {11, 0, 0};
  153|      0|        NSAssert([NSProcessInfo instancesRespondToSelector:@selector(isOperatingSystemAtLeastVersion:)] && [[NSProcessInfo new] isOperatingSystemAtLeastVersion:iOS11], @"The issue of resuming from SpringBoard is only known to occur on iOS 11+.");
  154|      0|        NSAssert([[[[self target] frontMostApp] name] isEqual:@"SpringBoard"], @"If reactivation is failing, the app is likely still open to SpringBoard.");
  155|      0|        
  156|      0|        // Tap slightly above the middle of the screen, otherwise it doesn't resume on an iPad Pro
  157|      0|        [[[self target] frontMostApp] tapWithOptions:@{@"tapOffset": @{@"x": @(.5), @"y": @(.36)}}];
  158|      0|
  159|      0|        // Wait for app to foreground
  160|      0|        CFRunLoopRunInMode(UIApplicationCurrentRunMode, 0.1, false);
  161|      0|        
  162|      0|        // Ensure our test app has returned to being the front most app
  163|      0|        NSString *testAppName = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleDisplayName"];
  164|      0|        NSAssert([[[[self target] frontMostApp] name] isEqual:testAppName], @"After tapping, the main app should be relaunched.");
  165|      0|        #pragma clang diagnostic pop
  166|      0|    }
  167|      0|}
  168|       |
  169|       |#pragma mark - Private
  170|       |
  171|       |- (BOOL)_alertIsValidAndVisible:(UIAAlert *)alert;
  172|      0|{
  173|      0|    // Ignore alert if in process; calling isVisible on alert in process causes a signal such as EXC_BAD_INSTRUCTION (not a catchable exception)
  174|      0|    UIAApplication *application = [[self target] frontMostApp];
  175|      0|    if ([@(getpid()) isEqual:[application pid]])
  176|      0|        return false;
  177|      0|
  178|      0|    // [alert isValid] is returning an __NSCFBoolean which is really hard to compare against.
  179|      0|    // Translate the __NSCFBoolean into a vanilla BOOL.
  180|      0|    // See https://www.bignerdranch.com/blog/bools-sharp-corners/ for more details.
  181|      0|    
  182|      0|    BOOL visible = NO;
  183|      0|    
  184|      0|    @try {
  185|      0|        visible = [[alert valueForKeyPath:@"isVisible"] boolValue];
  186|      0|    }
  187|      0|    @catch (NSException *exception) { } 
  188|      0|
  189|      0|    return ([alert isValid] && visible);
  190|      0|}
  191|       |
  192|      0|- (void)linkAutomationFramework {
  193|      0|    dlopen([@"/Developer/Library/PrivateFrameworks/UIAutomation.framework/UIAutomation" fileSystemRepresentation], RTLD_LOCAL);
  194|      0|    FixReactivateApp();
  195|      0|
  196|      0|    // Keep trying until the accessibility server starts up (it takes a little while on iOS 7)
  197|      0|    UIATarget *target = nil;
  198|      0|    while (!target) {
  199|      0|        @try {
  200|      0|            target = [self target];
  201|      0|        }
  202|      0|        @catch (NSException *exception) { }
  203|      0|        @finally { }
  204|      0|    }
  205|      0|}
  206|       |
  207|      0|- (UIATarget *)target {
  208|      0|    return [NSClassFromString(@"UIATarget") localTarget];
  209|      0|}
  210|       |
  211|      0|- (Class)nilElementClass {
  212|      0|    return NSClassFromString(@"UIAElementNil");
  213|      0|}
  214|       |
  215|       |@end

